version: "2"

linters:
  default: none

  enable:
    # https://golangci-lint.run/docs/linters/configuration/#arangolint
    # https://github.com/Crocmagnon/arangolint
    # Необходим при работе с arangodb
    # В случае работы с данной базой необходимо включить
    #
    # Выключаем
    # - arangolint

    # https://golangci-lint.run/docs/linters/configuration/#asasalint
    # https://github.com/alingse/asasalint
    # Проверяет случаи верной передачи []any в функции с параметром ...any
    - asasalint

    # https://golangci-lint.run/docs/linters/configuration/#asciicheck
    # https://github.com/golangci/asciicheck
    # Проверяет код на наличие non-ACII символов в названии
    - asciicheck

    # https://golangci-lint.run/docs/linters/configuration/#bidichk
    # https://github.com/breml/bidichk
    # Проверяет на наличие опасных символов (см README.md в репозитории bidichk)
    # Не вижу практической пользы
    #
    # Выключаем
    # - bidichk

    # https://golangci-lint.run/docs/linters/configuration/#bodyclose
    # https://github.com/timakin/bodyclose
    # Проверяет закрытие *http.Response.Body
    - bodyclose

    # https://golangci-lint.run/docs/linters/configuration/#canonicalheader
    # https://github.com/lasiar/canonicalheader
    # Проверяет название заголовков в http.Header
    # http.Header сам может модифицировать некорректные названия
    # Однако линтер помогает избежать непредвиденных ситуаций связанных с этим
    - canonicalheader

    # https://golangci-lint.run/docs/linters/configuration/#containedctx
    # https://github.com/sivchari/containedctx
    # Проверяет наличие поля с типом context.Context в структурах
    # Не вижу практической пользы
    # - containedctx
    # https://golangci-lint.run/docs/linters/configuration/#contextcheck
    # https://github.com/kkHAIKE/contextcheck
    # Если функция использует внутри себя контекст, значит этот контекст обязан приходить извне
    # Помогает избежать использования context.Background() или context.TODO() там где это не надо
    - contextcheck

    # https://golangci-lint.run/docs/linters/configuration/#copyloopvar
    # https://github.com/karamaru-alpha/copyloopvar
    # Проверяет копирование переменной в цикле
    # Потерял свою актуальность начиная с версии go 1.21
    # - copyloopvar
    # https://golangci-lint.run/docs/linters/configuration/#cyclop
    # https://github.com/bkielbasa/cyclop
    # Проверяет цикломатичную вложенность функций и пакетов, современная альтернатива gocyclo
    # Настройки по умолчанию вполне нас устраивают
    #
    # gocognit выполняет ту же самую фукнцию
    # revive.cognitive-complexity выполняет ту же самую функцию
    #
    # Был отключен в пользу линтеров оценивающих когнитивную сложность функций
    # По скольку помимо оценки вложенности (которую эти линтеры так же оценивают)
    # Необходимо оценивать общую сложность функций
    #
    # Выключаем
    # - cyclop

    # https://golangci-lint.run/docs/linters/configuration/#decorder
    # https://gitlab.com/bosi/decorder
    # Устанавливает правила определения блоков var, const, func, type
    # Нет нужды в жетском определении порядка блоков
    # Будет приводить к частым nolint
    # - decorder
    # https://golangci-lint.run/docs/linters/configuration/#depguard
    # https://github.com/OpenPeeDeeP/depguard
    # Устанавливает правила блока import (...)
    # Даёт возможность запретить импорт отдельного пакета
    # Если есть необходимость в запрете импорта отдельного пакета то следует включить
    # В gosec есть ряд правил которые запрещают испльзование небезопасных алгоритмов шифрования
    # Прекрасный use case для линтера
    - depguard

    # https://golangci-lint.run/docs/linters/configuration/#dogsled
    # https://github.com/alexkohler/dogsled
    # В случае если видит 2 и более (количество настраивается) _, _, a := foo() присвоения переменных то сообщает об этом
    # Не вижу практической пользы
    #
    # Выключаем
    # - dogsled

    # https://golangci-lint.run/docs/linters/configuration/#dupl
    # https://github.com/mibk/dupl
    # Проверяет код на наличие дубликатов кода
    # Вполне устраивает настройка по умолчанию в 150 токенов
    - dupl

    # https://golangci-lint.run/docs/linters/configuration/#dupword
    # https://github.com/Abirdcfly/dupword
    # Проверяет и исправляет (--fix) повторения ключевых слов в комментариях
    # Примеры исправлений в популярных проектах https://github.com/Abirdcfly/dupword/issues/3
    # Безвреден и не навязчив, но требует настройки
    # Включить если пишите много комментариев
    #
    # Выключаем
    # - dupword

    # https://golangci-lint.run/docs/linters/configuration/#durationcheck
    # https://github.com/Abirdcfly/dupword
    # Проверки умножения времени
    # Если ты умножаешь time.Second * time.Second то получается достаточно большое число
    - durationcheck

    # https://golangci-lint.run/docs/linters/configuration/#embeddedstructfieldcheck
    # https://github.com/manuelarte/embeddedstructfieldcheck
    # Запрещает встраивать мьютексы
    # Проверяет что встраиваемые структуры расположены выше остальных полей
    - embeddedstructfieldcheck

    # https://golangci-lint.run/docs/linters/configuration/#err113
    # https://github.com/Djarvur/go-err113
    # Устанавливает правила для работы с ошибками после go 1.13
    # Запрещает делать fmt.Errorf() c динамическими полями помимо одной error
    # Не имеет настройки отдельных правил
    # Замещен errcheck, errorlint, wrapcheck
    #
    # errcheck, errorlint, wrapcheck выполяют ту же самую функцию
    #
    # Выключаем
    # - err113

    # https://golangci-lint.run/docs/linters/configuration/#errcheck
    # https://github.com/kisielk/errcheck
    # Анализирует наличие проверки на ошибку (if err != nil)
    # В случае её отсутствия сообщает о ней
    # Есть отдельная настройка для совместимости с errchkjson
    - errcheck

    # https://golangci-lint.run/docs/linters/configuration/#errchkjson
    # https://github.com/breml/errchkjson
    # Проверяет типы которые попадают в json.Marshal
    # Позволяет быть уверенным в json.Marshal и в ряде случаев не проверять на ошибки
    - errchkjson

    # https://golangci-lint.run/docs/linters/configuration/#errname
    # https://github.com/Antonboom/errname
    # Правило именования переменных типа error, а также типов которые имплементируют error
    # Обязывает именовать типы type XError
    # Обязывает именовать ошибки [e|E]rrX
    #
    # Не реагирует на случаи когда переменная error не экспортируется
    #
    # var internal = errors.New("internal")
    - errname

    # https://golangci-lint.run/docs/linters/configuration/#errorlint
    # https://github.com/polyfloyd/go-errorlint
    # Правила работы с ошибками в golang
    # ВНИМАНИЕ ИМЕЕТ СВОЙСТВО --fix КОТОРОЕ МОЖЕТ ВЛИЯТЬ НА ЛОГИКУ КОДА
    - errorlint

    # https://golangci-lint.run/docs/linters/configuration/#exhaustive
    # https://github.com/nishanths/exhaustive
    # Проверяет значения enum в switch
    # Крайне полезен
    - exhaustive

    # https://golangci-lint.run/docs/linters/configuration/#exhaustruct
    # https://github.com/GaijinEntertainment/go-exhaustruct
    # Обязывает заполнять все поля в структурах
    # Крайне полезен
    - exhaustruct

    # https://golangci-lint.run/docs/linters/configuration/#exptostd
    # https://github.com/ldez/exptostd
    # Проверяет возможность замены использования пакетов golang.org/x/exp/ на пакеты стандартной библиотеки
    # Микрополезно
    - exptostd

    # https://golangci-lint.run/docs/linters/configuration/#fatcontext
    # https://github.com/Crocmagnon/fatcontext
    # ВНИМАНИЕ ИМЕЕТ СВОЙСТВО --fix КОТОРОЕ МОЖЕТ ВЛИЯТЬ НА ЛОГИКУ КОДА
    # В циклах предотвращает переназначение исходной переменной ctx
    # Исправляет автоматически, следует иметь это ввиду
    - fatcontext

    # https://golangci-lint.run/docs/linters/configuration/#forbidigo
    # https://github.com/ashanbrown/forbidigo
    # Позволяет запретить использовать любое выражение в коде
    # Кроме ключевых слов языка таких как goto, fallthrough
    # Настраивается через regexp
    - forbidigo

    # https://golangci-lint.run/docs/linters/configuration/#forcetypeassert
    # https://github.com/gostaticanalysis/forcetypeassert
    # Запрещает force type assert a := x.(*Type)
    # Каждый type assert должен быть обработан
    - forcetypeassert

    # https://golangci-lint.run/docs/linters/configuration/#funcorder
    # https://github.com/manuelarte/funcorder
    # Проверяет порядок расположения функций, методов и конструкторов.
    # Можно включить для специфических ситуаций
    # - funcorder

    # https://golangci-lint.run/docs/linters/configuration/#funlen
    # https://github.com/ultraware/funlen
    # Валидирует длину функций в строчках, по умолчанию 60
    # Настраивается
    - funlen

    # https://golangci-lint.run/docs/linters/configuration/#ginkgolinter
    # https://github.com/nunnatsa/ginkgolinter
    # ginkgo https://onsi.github.io/ginkgo/ - Популярных тестовый фреймворк для go
    # gomega https://onsi.github.io/gomega/ - Пакет для assertion
    # В случае использования этих инструментов следует включить и настроить
    # - ginkgolinter

    # https://golangci-lint.run/docs/linters/configuration/#gocheckcompilerdirectives
    # https://github.com/leighmcculloch/gocheckcompilerdirectives
    # Проверяет верность записи //go:embed //go:generate //go:build и т.д. (лишние пробелы, опечатки)
    - gocheckcompilerdirectives

    # https://golangci-lint.run/docs/linters/configuration/#gochecknoglobals
    # https://github.com/leighmcculloch/gochecknoglobals
    #
    # Запрещает объявлять глобальные переменные
    # Имеет ряд исключений которые описаны в репозитории
    #
    # Запрещает любые глобальные переменные независимо от их употребления
    # Является черезчур жестким правилом, приводит к false-positive
    #
    # Глобальные переменные остаются на совести разработчиков
    #
    # Выключаем
    # - gochecknoglobals

    # https://golangci-lint.run/docs/linters/configuration/#gochecknoinits
    # https://github.com/leighmcculloch/gochecknoinits
    # Запрещает использование init() функций
    # Мне не нужен этот линтер
    # - gochecknoinits

    # https://golangci-lint.run/docs/linters/configuration/#gochecksumtype
    # https://github.com/alecthomas/go-check-sumtype
    # Посмотри что такое https://github.com/BurntSushi/go-sumtype (что-то вроде enum в Rust на go интерфейсах)
    # Делает дополнительные проверки в switch case таких sum-type на предмет проверки соответствия всем типам
    - gochecksumtype

    # https://golangci-lint.run/docs/linters/configuration/#gocognit
    # https://github.com/uudashr/gocognit
    # Проверяет сложность функции
    # В отличие от gocyclo уделяет внимание вложенности деклараций if, for, switch
    - gocognit

    # https://golangci-lint.run/docs/linters/configuration/#goconst
    # https://github.com/jgautheron/goconst
    # Анализирует код на наличие одних и тех же строк
    # Предлагает вынести их в константы
    - goconst

    # https://golangci-lint.run/docs/linters/configuration/#gocritic
    # https://github.com/go-critic/go-critic
    # Множество правил по коду, расширенная версия govet
    # Правила приложены в настройках этого линтера
    - gocritic

    # https://golangci-lint.run/docs/linters/configuration/#gocyclo
    # https://github.com/fzipp/gocyclo
    # Считает сложность функции
    # Заменен на cyclop, более современную альтернативу
    # - gocyclo

    # https://golangci-lint.run/docs/linters/configuration/#godot
    # https://github.com/tetafro/godot
    # Валидирует комментарии, настраиваемый
    # Выключен за ненадобностью
    # - godot

    # https://golangci-lint.run/docs/linters/configuration/#godox
    # https://github.com/matoous/godox
    # Обнаруживает использование ключевых слов в комментариях
    # По умолчанию ищет TODO FIXME BUG
    # Удобно только в случае поиска данных слов, во всех остальных только мешает
    # Выключаем
    # - godox

    # https://golangci-lint.run/docs/linters/configuration/#goheader
    # https://github.com/denis-tingaikin/go-header
    # Проверяет что файл начинатся с определенного формата
    # Удобно при введении лицензии когда вам необходимо чтобы каждый файл начинался с определенного текста
    # Имеет гибкую настройку
    # Имеет опцию auto-fix
    # В обычной ситуации отключаем
    # - goheader

    # https://golangci-lint.run/docs/linters/configuration/#gomoddirectives
    # https://github.com/ldez/gomoddirectives
    # Линтер для управления директивами go.mod (replace, retract, tool, excludes и т.д)
    # Выключаем за ненадобностью настройки
    # - gomoddirectives

    # https://golangci-lint.run/docs/linters/configuration/#gomodguard
    # https://github.com/ryancurrah/gomodguard
    # Содержит ряд различных правил по управлению зависимостями в go.mod
    # Позволяет запретить добавлять зависимость в go.mod
    # Позволяет запретить использовать зависимость ниже или выше определённой версии
    # Выключаем за ненадобностью настройки go.mod
    # - gomodguard

    # https://golangci-lint.run/docs/linters/configuration/#goprintffuncname
    # https://github.com/golangci/go-printf-func-name
    # Если функция подходит под формат (format string, args ...interface{}) // на ...any не работает, при чем названия аргументов тоже важны
    # И название функции не оканчивается на 'f' то просит добавить символ в конец
    # https://github.com/golangci/go-printf-func-name/issues/3
    # Выключаем
    # TODO заменить на ruleguard, мне не нравится что на ...any линтер не срабатывает
    # - goprintffuncname

    # https://golangci-lint.run/docs/linters/configuration/#gosec
    # https://github.com/securego/gosec
    # Содержит множество проверок на потенциальные уязвимости и ошибки в коде
    # Правила приложены в настройках этого линтера
    - gosec

    # https://golangci-lint.run/docs/linters/configuration/#gosmopolitan
    # https://github.com/xen0n/gosmopolitan
    # Выявляет проблемы которые могут мешать интернационализации и локализации
    # Запреащет использовать time.Local
    # однако есть множество обходных путей получения локального времени
    # которые требуют "ручной" валидации
    # Китайский линтер, на кириллицу не реагирует
    # Выключаем
    # - gosmopolitan

    # https://golangci-lint.run/docs/linters/configuration/#govet
    # https://pkg.go.dev/cmd/vet
    # Самый базовый линтер по golang, поставляемый от разработчиков языка
    - govet

    # https://golangci-lint.run/docs/linters/configuration/#grouper
    # https://github.com/leonklingele/grouper
    # Устанавливает правило объявления блоков var, type, import
    # Частично этим занимаются gofumpt
    # По умолчанию и так всё выключено
    # Имеет опции для настройки
    # type a struct{}
    # type b struct{}
    # Выключаем
    # - grouper

    # https://golangci-lint.run/docs/linters/configuration/#iface
    # https://github.com/uudashr/iface
    # Содержит набор правил по интерфейсам
    # по умолчанию обнаруживает "идентичные линтеры"
    # type A interface{ Call() } // дубликаты с одинаковыми сигнатурами функций
    # type B interface{ Call() } //
    - iface

    # https://golangci-lint.run/docs/linters/configuration/#importas
    # https://github.com/julz/importas
    # Позволяет настроить alias import
    # Для тех кто действительно хочет соблюдать import as политики будет полезно
    # Выключаем
    # - importas

    # https://golangci-lint.run/docs/linters/configuration/#inamedparam
    # https://github.com/macabu/inamedparam
    # Обязывает подписывать входные переменные у методов интерфейсов
    # type NonNamed interface{ Hello(string) (string, error) } // ошибка, необходимо подписать входные параметры
    # есть настройка для того чтобы позволять не подписывать входные параметры
    # если их количество равно 1
    - inamedparam

    # https://golangci-lint.run/docs/linters/configuration/#ineffassign
    # https://github.com/gordonklaus/ineffassign
    # Проверяет бесполезные присваивания переменным
    # a := 0
    # print(a) // использование
    # a = 1 // далее переменная нигде не используется, этого присвоения можно избежать
    - ineffassign

    # https://golangci-lint.run/docs/linters/configuration/#interfacebloat
    # https://golangci-lint.run/docs/linters/configuration/#interfacebloat
    # Регулирует максимально количество методов у интерфейсов
    # По умолчанию 10 методов, но значение настроивается
    - interfacebloat

    # https://golangci-lint.run/docs/linters/configuration/#intrange
    # https://github.com/ckaznocha/intrange
    # for i := 0; i < 1100; i++ {} // старый синтаксис, неправильно
    # for i := range 1100 // новой синтаксис, идиоматично
    # modernize.rangeint выполняет ту же самую функции
    # Выключаем
    # - intrange

    # https://golangci-lint.run/docs/linters/configuration/#iotamixing
    # https://github.com/AdminBenni/iota-mixing
    # Проверяет наличие заданных костант в const блоке
    # const ( // в блоке присутствует лишняя константа four = 4 которая не использует iota
    # 	one = iota
    # 	two
    # 	three
    # 	four = 4
    # )
    # Есть баг не работает на случаи когда iota идёт с доп конструкциями
    # const ( // линтер не обработает такой случай
    # 	one = iota + 1
    # 	two
    # 	three
    # 	four = 4
    # )
    # Оставил ISSUE https://github.com/AdminBenni/iota-mixing/issues/4
    - iotamixing

    # https://golangci-lint.run/docs/linters/configuration/#ireturn
    # https://github.com/butuzov/ireturn
    # Реализует правило Accept Interfaces, Return Concrete Types.
    # Проверяет функции которые возвращают интерфейсы, вместо конкретных типов
    # func NewService() Service {return &MyServiceImpl{}} // сообщит об ошибке из-за возврата интерфейса
    # func NewService() *MyServiceImpl {return &MyServiceImpl{}} // OK
    # Настраивается
    #
    # Бывает напряжно
    # Плохая интеграция с generic (отсутствует, либой возврат generic параметра будет расцениваться как нарушение)
    #
    # Выключаем
    # - ireturn

    # https://golangci-lint.run/docs/linters/configuration/#lll
    # https://github.com/walle/lll // на самом сайте не указан
    # Сообщает о слишком длинных строках
    # Настраивается
    - lll

    # https://golangci-lint.run/docs/linters/configuration/#loggercheck
    # https://github.com/timonwong/loggercheck
    # Логгер который проверяет правильность паттерна ключ-значения для ряда популярных логгеров
    # Пример на slog
    # slog.Info("mymsg", "value") // первый аргумент является сообщением, нет ключа для "value"
    # в таком случае будет выведено
    # INFO mymsg !BADKEY=value
    # slog.Info("mymsg", "key", "value") // правильно
    # в таком случае будет выведено
    # INFO mymsg key=value
    - loggercheck

    # https://golangci-lint.run/docs/linters/configuration/#maintidx
    # https://github.com/yagipy/maintidx?tab=readme-ov-file
    # Японский линтер
    # Оценивает индекс поддерживаемости для каждой функции
    # Настраивается только параметр индекса
    # Не разобрался как точно работает
    # Оставлю
    # Сомнительно
    #
    # gocognit выполняет ту же самую функцию
    #
    # Было принято решение что для оценки сложности используем gocognit
    #
    # Выключаем
    # - maintidx

    # https://golangci-lint.run/docs/linters/configuration/#makezero
    # https://github.com/ashanbrown/makezero
    # Анализируют случаи вставки в массив который был проинициализирован с ненулевой длиной
    # mySlice := make([]int, 10)
    # mySlice = append(mySlice, 1) // ошибка вставка в массив который был проинициализован с ненулевой длиной
    # Имеет опцию для настройки строго режима, который запрещает вообще инициализацию
    # массива с ненулевым значением
    - makezero

    # https://golangci-lint.run/docs/linters/configuration/#mirror
    # https://github.com/butuzov/mirror
    # Автор линтера собирает донаты на помощь Украине
    # Разбирает ряд случаев неоптимальных преобразований []byte в mirror
    # _, _ = new(strings.Builder).WriteString(string([]byte("foobar"))) // want `avoid allocations with \(\*strings\.Builder\)\.Write`
    - mirror

    # https://golangci-lint.run/docs/linters/configuration/#misspell
    # https://github.com/golangci/misspell
    # Обнаруживает грамматические ошибки в ряде популярных английских слов
    # Настраивается
    - misspell

    # https://golangci-lint.run/docs/linters/configuration/#mnd
    # https://github.com/tommy-muehle/go-mnd#checks
    # Запрещает использовать цифры кроме 0 или 1 без объявления их как переменную или константу
    # Есть ряд правил которые представляют собой виды мест где необходимо проверять наличие чисел
    # Числа которые не стоит проверять так же настраиваются
    #
    # const myTimeout = 5 * time.Second // не будет реагировать
    # myTimeout := 5 * time.Second      // для переменной такое неприемлимо
    #
    # revive.add-constant выполняет ту же самую фукнцию
    # Однако проверяет к тому же количество встречаемых строк
    # И предлагает заменить их на константу
    # К тому же сообщение об ошибке у него более насыщено смысловой ценностью
    #
    # Выключаем
    # - mnd

    # https://golangci-lint.run/docs/linters/configuration/#modernize
    # https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/modernize
    # Содержит ряд правил сообщающих об устарелых кусках кода
    # Подробнее в настройках
    # Как и govet включен в стандартные подсказки gopls
    - modernize

    # https://golangci-lint.run/docs/linters/configuration/#musttag
    # https://github.com/go-simpler/musttag
    # Обязывает тегировать поля структур которые будут преобразовываться в данные различных форматов
    #
    # type MyMarshaledStruct struct {
    #   Field string
    # }
    # По скольку есть код где структура маршалится
    # и поле Field не обозначено тегом линтер пожалуется на код
    #
    # _, _ = json.Marshal(MyMarshaledStruct{Field: "Name"})
    #
    #
    # Чтобы исправить issue нам необходимо добавить json тег к полю Field
    # type MyMarshaledStruct struct {
    #   Field string `json:"file_id"`
    # }
    #
    # Настраивается
    - musttag

    # https://golangci-lint.run/docs/linters/configuration/#nakedret
    # https://github.com/alexkohler/nakedret
    # Предупреждает о пустых return с именоваными возвращаемыми значениями
    # только при условии что фукнция длиннее определенного количества строк
    # Выглядит как частный случай revive.bare-return
    # revive.bare-return выполняет ту же самую функцию
    # Выключаем
    # - nakedret

    # https://golangci-lint.run/docs/linters/configuration/#nestif
    # https://github.com/nakabonne/nestif
    # Ряд линтеров revive выполняет ту же самую функцию
    # А именно max-control-nesting, early-return
    # Выключаем
    # - nestif

    # https://golangci-lint.run/docs/linters/configuration/#nilerr
    # https://github.com/gostaticanalysis/nilerr
    # Сообщает о случаях когда при проверке на err != nil мы возвращаем error(nil)
    #	err := doSomeNetwork()
    # if err != nil {
    # 	return error(nil) // Возвращаем error(nil) несмотря на то что исходная ошибка err != nil
    # }
    - nilerr

    # https://golangci-lint.run/docs/linters/configuration/#nilnesserr
    # https://github.com/alingse/nilnesserr
    # Сообщает о случаях когда при проверке на err1 != nil мы возвращаем совсем другое значение
    # Обрабатывает так же случаи и с обработкой значения
    #
    # err := do()
    # if err != nil {
    #     return err
    # }
    #
    # err2 := do2()
    # if err2 != nil {
    #     return err // мы возвращаем заведомо nil значение
    # }
    - nilnesserr

    # https://golangci-lint.run/docs/linters/configuration/#nilnil
    # https://github.com/Antonboom/nilnil
    # Сообщает о случае когда мы возвращаем все nil значения
    # где последним аргументом функции является error
    - nilnil

    # https://golangci-lint.run/docs/linters/configuration/#nlreturn
    # https://github.com/ssgreg/nlreturn
    # Перед return должна идти пустая линия
    # if do2() == nil {
    # 	return nil, nil, io.ErrUnexpectedEOF
    # }
    # return make(chan int), nil, io.ErrUnexpectedEOF
    #
    # wsl_v5.return выполняет ту же самую функцию
    #
    # Выключаем
    # - nlreturn

    # https://golangci-lint.run/docs/linters/configuration/#noctx
    # https://github.com/sonatard/noctx
    # Сообщает о ряде функций которые не принимают в себя контекст
    # при этом имеющие альтернативы использующие контекст
    # Содержит ряд проверок для стандартной библиотек
    # Рассмотрим для *sql.DB
    #
    # _, _ = db.Begin()
    # ^
    # |
    # имеет context альтернативу в виде BeginTx которая примает в себя контекст
    - noctx

    # https://golangci-lint.run/docs/linters/configuration/#noinlineerr
    # https://github.com/AlwxSin/noinlineerr
    # Запрещает использовать конструкции вида
    # if err := http.ListenAndServe("localhost:9909", nil); err != nil {
    #
    # обязывает писать их в две строчки
    # err := http.ListenAndServe("localhost:9909", nil)
    # if err != nil {...}
    - noinlineerr

    # https://golangci-lint.run/docs/linters/configuration/#nolintlint
    # https://github.com/golangci/golangci-lint/tree/HEAD/pkg/golinters/nolintlint/internal
    # Настраивает правила для nolint директив
    # Контрится //nolint:nolintlint
    # Настраивается
    - nolintlint

    # https://golangci-lint.run/docs/linters/configuration/#nonamedreturns
    # https://github.com/firefart/nonamedreturns
    # Запрещает делать инменованые аргументы в функциях
    # func foo() (named int, err error)
    # Конфликтует с gocritic.unnamedResult, выбор сделан в пользу последнего
    # Есть настройка для включений значений в defer
    # Выключаем
    # - nonamedreturns

    # https://golangci-lint.run/docs/linters/configuration/#nosprintfhostport
    # https://github.com/stbenjam/no-sprintf-host-port
    # Указывает на некоррестные использования fmt.Sprintf для соединения адреса и порта для различных протоколов
    # fmt.Sprintf("http://%s:%d/foo", host, port) // неверно
    # fmt.Sprintf("http://%s/foo", net.JoinHostPort(host, fmt.Sprint(port))) // верно
    # На удивление не конфликтует с gosec G114
    - nosprintfhostport

    # https://golangci-lint.run/docs/linters/configuration/#paralleltest
    # https://github.com/kunwardeep/paralleltest
    # Обязывает использовать t.Parallel в каджом тесте
    # может генерировать false positive
    # Настраивается
    # Выключаем
    # - paralleltest

    # https://golangci-lint.run/docs/linters/configuration/#perfsprint
    # https://github.com/catenacyber/perfsprint
    #
    # Проверяет возможность замены fmt.Sprint более быстрой альтернативой
    #
    # Например
    #
    # _ = fmt.Sprint(1)
    # Может быть заменено
    # _ = strconv.Itoa(1)
    #
    # Настраивается
    - perfsprint

    # https://golangci-lint.run/docs/linters/configuration/#prealloc
    # https://github.com/alexkohler/prealloc
    # Обнаруживает случаи когда можно преаллоцировать массив
    # var y []rune
    # for _, r := range "Hello" {
    # 	y = append(y, r) // можно преаллоцировать массив y
    # }
    #
    # Не работает если y инициализован с make([]rune, 0)
    # что делает его почти бесполезным
    # Пусть будет
    - prealloc

    # https://golangci-lint.run/docs/linters/configuration/#predeclared
    # https://github.com/nishanths/predeclared
    # Сообщает о именах переменных чьё название перекрывает ключевое слово языка
    # func new() {} // переопределяет встроенную функцию new()
    # type Item stuct {new rune} // поле new переопределяет встроенную фукнцию new()
    # Настраивается
    - predeclared

    # https://golangci-lint.run/docs/linters/configuration/#promlinter
    # https://github.com/yeya24/promlinter
    # Содержит ряд правил для работы с github.com/prometheus/client_golang/prometheus
    # Настраивается
    # Подробнее в настройках линтера
    - promlinter

    # https://golangci-lint.run/docs/linters/configuration/#protogetter
    # https://github.com/ghostiam/protogetter
    # Обязывает вас использовать GetProtoField вместо доступа к ProtoField непосредственно
    #	req := &zoo.AddAnimalRequest{
    # 	Name: "Hello",
    # }
    # _ = req.Name
    # _ = req.GetName()
    #
    # Сомнительно, ведь если это опциональное поле
    # мы не сможет различить его отсутствие с пустым значением
    # потому что в геттерах всегда идёт проверка на nil
    # и возвращается значение а не указатель
    #
    # Выключаем
    # - protogetter

    # https://golangci-lint.run/docs/linters/configuration/#promlinter
    # https://github.com/yeya24/promlinter
    # Проверяет что глобальные переменные из других пакетов не изменяются в коде программы
    # gocritic.externalErrorReassign выполняет ту же функцию
    # Однако реагирует на все переназначения глобальных переменных типа error
    # независимо от названия
    #
    # Например в базовой конфигураци reassign не заметит этого
    # context.Canceled = nil
    # Однако gocritic.externalErrorReassign обнаружит подобное нарушение
    #
    # Настраивается
    # Данный линтер настраивается путём указания паттернов поиска имен
    # что может быть достаточно хлопотно настраивать под каждый отдельный случай
    # Выключаем
    # - reassign

    # https://golangci-lint.run/docs/linters/configuration/#recvcheck
    # https://github.com/raeperd/recvcheck
    # Обнаруживает конфликты в методах структур
    #
    # type Human struct{}
    #
    # func (*Human) Hello() {} // Обращение по указателю
    # func (Human) Bye()    {} // Обращение по значению
    #
    # Необходимо сделать оба метода с обращением по указателю
    #
    # func (*Human) Hello() {}
    # func (*Human) Bye()   {}
    #
    # Или сделать оба метода с обращением по значениею
    #
    # func (Human) Hello() {}
    # func (Human) Bye()   {}
    - recvcheck

    # https://golangci-lint.run/docs/linters/configuration/#revive
    # https://github.com/mgechev/revive
    # Мощный линтер со множеством правил
    # Позволяет писать кастомные правила
    - revive

    # https://golangci-lint.run/docs/linters/configuration/#rowserrcheck
    # https://github.com/jingyugao/rowserrcheck
    #
    # Обязывает вас проверять sql.Rows.Err() после сканирования
    #
    # До
    # ctx := context.Background()
    #
    # db := new(sql.DB)
    #
    # rows, err := db.QueryContext(ctx, "SELECT * FROM animals")
    # if err != nil {
    # 	panic(err)
    # }
    #
    # _ = rows
    #
    #
    # После
    # ctx := context.Background()
    #
    # db := new(sql.DB)
    #
    # rows, err := db.QueryContext(ctx, "SELECT * FROM animals")
    # if err != nil {
    # 	panic(err)
    # }
    #
    # if rows.Err() != nil {
    # 	panic(rows.Err())
    # }
    #
    # Позволяет настроить список пакетов который необходимо проверять
    #
    # Есть ньанс с тем что если пакет не импортирован то его тип Rows не будет проверен
    #
    # Такое можно воспроизвести с помощью sqlx.QueryContext который возвращает database/sql.Rows
    # при этом сам database/sql не импортируется
    #
    # Создал ISSUE https://github.com/jingyugao/rowserrcheck/issues/33
    - rowserrcheck

    # https://golangci-lint.run/docs/linters/configuration/#sloglint
    # https://github.com/go-simpler/sloglint
    #
    # Является конфигурируемой настройкой для использования slog.Logger
    - sloglint

    # https://golangci-lint.run/docs/linters/configuration/#spancheck
    # https://github.com/jjti/go-spancheck
    #
    # Добавляет ряд правил при работе со спанами
    #
    # Проверяет спаны из следующих пакетов:
    # go.opentelemetry.io/otel/trace
    # go.opencensus.io/trace
    - spancheck

    # https://golangci-lint.run/docs/linters/configuration/#sqlclosecheck
    # https://github.com/ryanrolds/sqlclosecheck
    #
    # Проверяет начилие вызова Close() для sql.Rows, sql.Stmt, sqlx.NamedStmt, pgx.Query
    #
    # До
    # ctx := context.Background()
    #
    # db := new(sql.DB)
    #
    # rows, err := db.QueryContext(ctx, "SELECT * FROM animals")
    # if err != nil {
    # 	panic(err)
    # }
    #
    # // отсутствует вызов rows.Close()
    #
    # if rows.Err() != nil {
    # 	panic(rows.Err())
    # }
    #
    # После
    #
    # ctx := context.Background()
    #
    # db := new(sql.DB)
    #
    # rows, err := db.QueryContext(ctx, "SELECT * FROM animals")
    # if err != nil {
    # 	panic(err)
    # }
    #
    # defer func() { _ = rows.Close() }() // присутствует вызов rows.Close
    #
    # if rows.Err() != nil {
    # 	panic(rows.Err())
    # }
    #
    # По аналогии с rowserrcheck не распространяется на случаи когда sql.Rows была получена через sqlx
    #
    # ctx := context.Background()
    #
    # db := new(sqlx.DB)
    #
    # rows, err := db.QueryContext(ctx, "SELECT * FROM animals")
    # if err != nil {
    # 	panic(err)
    # }
    #
    # // вызов rows.Close отсутствует, однако никакого предпреждения линтер не выдаст
    #
    # for rows.Next() {
    # 	_ = rows.Scan()
    # }
    - sqlclosecheck

    # https://golangci-lint.run/docs/linters/configuration/#staticcheck
    # https://github.com/dominikh/go-tools
    - staticcheck

    # https://golangci-lint.run/docs/linters/configuration/#tagalign
    # https://github.com/4meepo/tagalign
    #
    # Проверяет теги, имеет гибкую настройку
    #
    # revive.struct-tag выполняет ту же самую фукнцию валидации тегов
    #
    # Однако проверяет правила публичных полей
    # есть опции для сортировки тегов
    #
    # golines.reformat-tags выполняет ту же самую фукнцию форматирования тегов
    #
    # Выключаем
    # - tagalign

    # https://golangci-lint.run/docs/linters/configuration/#tagliatelle
    # https://github.com/ldez/tagliatelle
    #
    # Добавляет правила валидации имен тегов
    - tagliatelle

    # https://golangci-lint.run/docs/linters/configuration/#testableexamples
    # https://github.com/maratori/testableexamples
    #
    # Проверяет что func Example_foo() имеют "// Output:" комментарий для проверки выходных данных
    #
    #
    # func foo() {
    # 	_, _ = fmt.Fprintf(os.Stdout, "Hello %s!\n", "World")
    # }
    #
    # До
    #
    # func Example_foo() {
    # 	foo()
    # } // такой пример не будет запущен в go test . и не будет считаться примером, в go test -list . тоже не отпечатается
    #
    # После
    #
    # func Example_foo() {
    # 	foo()
    # 	// Output: Hello World!
    # } // данный пример будет запущен и сверит данные в stdout с Hello World!, в случае несовпадения напишет ошибку
    #
    - testableexamples

    # https://golangci-lint.run/docs/linters/configuration/#testifylint
    # https://github.com/Antonboom/testifylint
    #
    # Содержит набор правил для пакета testify
    # https://github.com/stretchr/testify
    #
    # Агрессивный auto-fix, будьте осторожны
    - testifylint

    # https://golangci-lint.run/docs/linters/configuration/#testpackage
    # https://github.com/maratori/testpackage
    #
    # Проверяет что тестовый пакет имеет суффикс _test
    #
    # Выключаем
    # - testpackage

    # https://golangci-lint.run/docs/linters/configuration/#thelper
    # https://github.com/kulti/thelper
    #
    # Проверяет наличие t.Helper() в функциях куда передаётся *testing.T, *testing.B, testing.TB, *testing.F
    - thelper

    # https://golangci-lint.run/docs/linters/configuration/#tparallel
    # https://github.com/moricho/tparallel
    #
    # Валидирует использование *testing.T.Parallel
    #
    # Если тест параллелен то его саб-тесты тоже должны быть параллельными
    #
    # До
    # func Test_foo(t *testing.T) {
    # 	t.Parallel()
    #
    # 	t.Run("single", func(t *testing.T) {})
    # 	t.Run("two", func(t *testing.T) {})
    # }
    #
    # После
    # func Test_foo(t *testing.T) {
    # 	t.Parallel()
    #
    # 	t.Run("single", func(t *testing.T) { t.Parallel() })
    # 	t.Run("two", func(t *testing.T) { t.Parallel() })
    # }
    #
    # И наоборот
    # Если саб-тесты вызывают t.Parallel основной также должен вызывать t.Parallel
    #
    # func Test_Func1(t *testing.T) { // want "Test_Func1 should call t.Parallel on the top level as well as its subtests"
    # 	teardown := setup("Test_Func1")
    # 	t.Cleanup(teardown)
    #
    # 	t.Run("Func1_Sub1", func(t *testing.T) {
    # 		call("Func1_Sub1")
    # 		t.Parallel()
    # 	})
    #
    # 	t.Run("Func1_Sub2", func(t *testing.T) {
    # 		call("Func1_Sub2")
    # 		t.Parallel()
    # 	})
    # }
    - tparallel

    # https://golangci-lint.run/docs/linters/configuration/#unconvert
    # https://github.com/mdempsky/unconvert
    #
    # Указывает на бесполезные преобразования
    #
    # func getInt() int {
    # 	var res int
    #
    # 	return int(res) // в данном преобразовании нет смысла
    # }
    - unconvert

    # https://golangci-lint.run/docs/linters/configuration/#unparam
    # https://github.com/mvdan/unparam
    #
    # Несет в себе широкий спектр проверки неиспользуемых параметров и их значений
    #
    # func doSomething(a int, b string) int {
    # 	if b == "constant" {
    # 		return a
    # 	}
    #
    # 	return 0
    # }
    #
    # // Вызовы всегда с b = "constant"
    # // Результирующее значение никогда не используется
    #
    # func main() {
    # 	_ = doSomething(10, "constant")
    # 	_ = doSomething(5, "constant")
    # }
    #
    # Имеет настройку для проверки публичных функций
    # Следует отключить для IDE по скольку там линтер может запускатья лишь в рамках одной директории
    # Что может генерировать false positive
    #
    - unparam

    # https://golangci-lint.run/docs/linters/configuration/#unparam
    # https://github.com/mvdan/unparam
    #
    # Проверяет наличие SELECT * (паттерны настраиваются) в строках и функциях базы данных
    #
    # func main() {
    # 	db := new(sql.DB)
    #
    # 	_, _ = db.ExecContext(context.Background(), "SELECT * FROM table") // проверяет вызовы с SELECT *
    # 	_ = "SELECT * FROM TABLE"                                          // проверяет строки c SELECT *
    # 	_ = squirrel.Select("*").From("table")                             // если включен check-sql-builder
    # }
    - unqueryvet

    # https://golangci-lint.run/docs/linters/configuration/#unused
    # https://github.com/dominikh/go-tools/tree/HEAD/unused
    #
    # Сообщает о неиспользуемом коде (поля, параметры, переменные, типы)
    - unused

    # https://golangci-lint.run/docs/linters/configuration/#usestdlibvars
    # https://github.com/sashamelentyev/usestdlibvars
    #
    # Сообщает о использовании значений которые могут быть заменены
    # на константы стандартной библиотеки
    - usestdlibvars

    # https://golangci-lint.run/docs/linters/configuration/#usetesting
    # https://github.com/ldez/usetesting
    #
    # Линтер нацелен на проверку функций в аргументах которой содержится *testing.T, *testing.B
    #
    # На *testing.F не распространяется
    #
    # Настройки позволяют управлять функциями на которые распространяются проверки
    # В них входит ряд функций создания директорий, присваивания переменных окружения и методы контекста
    #
    - usetesting

    # https://golangci-lint.run/docs/linters/configuration/#varnamelen
    # https://github.com/blizzy78/varnamelen
    #
    # Сообщает о коротких названиях переменных
    #
    # Настраивается
    - varnamelen

    # https://golangci-lint.run/docs/linters/configuration/#wastedassign
    # https://github.com/sanposhiho/wastedassign
    #
    # ineffassign выполняет ту же самую функцию
    #
    # Выключаем
    # ineffassign появился раньше в списке линтеров
    # ineffassign в golangci-lint начиная с версии 1.0.0
    #
    # - wastedassign

    # https://golangci-lint.run/docs/linters/configuration/#whitespace
    # https://github.com/ultraware/whitespace
    #
    # Сообщает о нежелательных пустых строках
    #
    # До
    # func main() { // Нежелательная пустая строка ниже
    #
    # 	os.Exit(0)
    #
    # } // Нежелательная пустая строка выше
    #
    # После
    # func main() {
    # 	os.Exit(0)
    # }
    #
    # gofumpt formatter убирает лишние линии
    #
    - whitespace

    # https://golangci-lint.run/docs/linters/configuration/#wrapcheck
    # https://github.com/tomarrell/wrapcheck
    #
    # Сообщает об ошибках из внешних источников которые не были обернуты
    #
    # Настраивается
    - wrapcheck

    # https://golangci-lint.run/docs/linters/configuration/#wsl_v5
    # https://github.com/bombsimon/wsl
    #
    # Набор правил для отступов
    - wsl_v5

    # https://golangci-lint.run/docs/linters/configuration/#zerologlint
    # https://github.com/ykadowak/zerologlint
    #
    #
    # Сообщает о забытых *zerolog.Event.Send или *zerolog.Event.Msg методах
    # без которых сообщение будет записано
    #
    # Все прочие методы, это лишь часть builder pattern
    #
    # До
    # log.Info().Str("key", "value") // Не имеет никакого эффекта
    #
    # После
    #	log.Info().Str("key", "value").Msg("entered") // Выведет сообщение в out
    #
    # {"level":"info","key":"value","time":"2025-12-07T21:24:58+04:00","message":"entered"}
    #
    # False Positive
    #
    # Если мы возвращаем *zerolog.Event из функции линтер так же сообщит о проблеме
    #
    # func main() {
    # 	makeEvent().Send()
    # }
    #
    # func makeEvent() *zerolog.Event {
    # 	return log.Info().Str("key", "value") // линтер сообщит о пропущенных Send или Msg методах
    # }
    #
    - zerologlint

  settings:
    cyclop:
      # The maximal code complexity to report.
      # Default: 10
      max-complexity: 5

      # The maximal average package complexity.
      # If it's higher than 0.0 (float) the check is enabled.
      # Default: 0.0
      package-average: 0.0

    depguard:
      rules:
        archived:
          deny:
            - pkg: "github.com/golang/mock"
              desc: "this package is archived, use go.uber.org/mock/mockgen"
        rand:
          deny:
            - pkg: "math/rand"
              desc: "use crypto/rand"
            - pkg: "math/rand/v2"
              desc: "use crypto/rand"
        crypto:
          deny:
            - pkg: "crypto/md5"
              desc: "weak crypto algoritm"
            - pkg: "crypto/sha1"
              desc: "weak crypto algoritm"
            - pkg: "crypto/des"
              desc: "weak crypto algoritm"
            - pkg: "crypto/rc4"
              desc: "weak crypto algoritm"
            - pkg: "golang.org/x/crypto/md4"
              desc: "weak crypto algoritm"
            - pkg: "golang.org/x/crypto/ripemd160"
              desc: "weak crypto algoritm"

    errcheck:
      # Внимание на настройку errchkjson.check-error-free-encoding
      exclude-functions:
        - encoding/json.Marshal
        - encoding/json.MarshalIndent

    errchkjson:
      # Сообщает о струтурах которые попадают в json.Marshal при этом не имея публичных полей
      report-no-exported: true
      # По скольку мы точно знаем что переменную безопасно маршалить, ошибка в таких местах недостижима
      # Ошибку в таких местах можно безопасно проигнорировать
      check-error-free-encoding: true

    errorlint:
      # Все вызовы с fmt.Errorf() где оборачивается ошибка пренепременно должны быть с %w
      # Работает не совсем гладко, в случае когда у нас есть уже обернутая ошибка пропускает
      # Надо будет им закинуть на доработку
      # fmt.Errorf("erro1: %w, error2: %v", io.ErrShortBuffer, io.ErrNoProgress)
      errorf: true
      # Запрещает оборачивать с помощью fmt.Errorf более чем одну ошибку
      # Вероятно поэтому errorf в некоторых случаях работает не совсем корректно
      errorf-multi: false
      # Запрещает делать error.(type), необходимо использовать errors.As
      # Агресивный --fix
      # Будет автоматически исправлять все error.(ErrorType) на вызовы errors.As через функцию замыкание
      asserts: true
      # Запрещает использовать == между двумя ошибками, необходимо использовать errors.Is
      # Агресивный --fix
      # Будет автоматически исправлять все err == target на errors.Is(err, target)
      comparison: true

    exhaustruct:
      # В случаях когда не заполнено ни одно поле не жалуемся
      allow-empty: true

      exclude:
        # не реагируем на http.Server
        - '.+/http\.Server$'
        # не реагируем на http.Client
        - '.+/http\.Client$'
        # не реагируем на http.Transport
        - '.+/http\.Transport$'

        # Структуры которые обозначают опции и конфигурации зачастую
        # имеют множество опциональных полей, не обязательных к присвоению
        # данные регулярные выражения позволяют избежать проверки этих структур
        - ".*Opts$"
        - ".*Options$"
        - ".*Config$"

    forbidigo:
      forbid:
        - pattern: ^(fmt.Print(|f|ln)|print|println)$
          msg: direct output to stdout is forbidden

        - pattern: uuid.Nil
          msg: prefer use uuid.UUID{} as zero value, because uuid.Nil is global variable and can be reassigned

        - pattern: sql.LevelDefault
          msg: use concrete isolation level, not default

        - pattern: runtime.SetFinalizer
          msg: use runtime.AddCleaup modern and safer implementation

        - pattern: time.Sleep
          msg: use <-time.After, this more runtime efficent way to delay code execution

    funlen:
      # Считает только тело функции
      # Учитывает пустые строчки
      # Предпочту ориентироваться на количество языковых конструкций а не на сырую длину тела функции
      lines: -1

      # Учитывает объявление переменной, присваивание, if, for, else, switch, case, default, select и т.д.
      # Не учитывает количество пустых строк
      statements: 40

      # Не учитываем комменты при подсчете длины функции
      ignore-comments: true

    gochecksumtype:
      # Независимо от наличия ветки default должны быть осуществлены все возможные type assertion в switch case
      default-signifies-exhaustive: false

      # Сложная надстройка, ломает строгость позволяет при некоторых случаях в перечиcление передавать interface
      # При этом линтер не будет указывать на ошибку
      # ПРИЗНАН АНТИПАТТЕРНОМ
      include-shared-interfaces: false

    gocognit:
      min-complexity: 10

    gocritic:
      disable-all: true
      enable-all: false

      enabled-checks:
        # https://go-critic.com/overview.html#appendassign
        # Сообщает о некорректных вызовах функций append
        # Когда нашему slice присваивается результат append другого slice
        # p.positives = append(p.negatives, x)
        # p.negatives = append(p.negatives, y)
        # Не допустит ситуации выше
        - appendAssign

        # https://go-critic.com/overview.html#appendcombine
        # Замечает неэффективные вставки в slice
        # До
        # xs = append(xs, 1)
        # xs = append(xs, 2)
        # После
        # xs = append(xs, 1, 2)
        - appendCombine

        # https://go-critic.com/overview.html#argorder
        # Проверяет порядок аргументов в ряде функций
        # Пример
        # strings.HasPrefix(userpass, "#"), если мы поменяем местами аргументы то линтер сообщит об этом
        # Так как для подобных функций константа всегда идёт вторым аргументом
        - argOrder

        # https://go-critic.com/overview.html#assignop
        # До
        # x = x * 2
        # После
        # x *= 2
        - assignOp

        # https://go-critic.com/overview.html#badcall
        # Запрещает ряд "бесполезных" вызовов функций
        # Например
        # До
        # strings.Replace(s, from, to, 0)
        # После
        # strings.Replace(s, from, to, -1)
        - badCall

        # https://go-critic.com/overview.html#badcond
        # Обнаруживает ряд некорректных выражений
        # До
        # for i := 0; i > n; i++ {...}
        # После
        # for i := 0; i < n; i++
        - badCond

        # https://go-critic.com/overview.html#badlock
        # Обнаруживает некорректные блокировки мьютексов
        # До
        # mu.Lock(); mu.Unlock()
        # После
        # mu.Lock(); defer mu.Unlock()
        - badLock

        # https://go-critic.com/overview.html#badregexp
        # Проверяет регулярные выражения
        # До
        # regexp.MustCompile(`(?:^aa|bb|cc)foo[aba]`)
        # После
        # regexp.MustCompile(`^(?:aa|bb|cc)foo[ab]`)
        - badRegexp

        # https://go-critic.com/overview.html#badsorting
        # Обнаруживает некорректные использования пакета sort
        # Мне не нравится пример который приведен, кажется что он притянут за уши
        # Мне не нравится что данная проверка помечена как experimental
        # Линтер кажется не шибко полезным
        # Можно выключить
        # - badSorting

        # https://go-critic.com/overview.html#badsynconcefunc
        # Проверяет корректное использование sync.OnceFunc
        # Экспериментальный
        # До
        # sync.OnceFunc(foo)()
        # После
        # fooOnce := sync.OnceFunc(foo); ...; fooOnce()
        - badSyncOnceFunc

        # https://go-critic.com/overview.html#boolexprsimplify
        # Обнаруживает булевы выражения которые могут быть упрощены
        # Экспериментальный
        # До
        # a := !(elapsed >= expectElapsedMin)
        # b := !(x) == !(y)
        # После
        # a := elapsed < expectElapsedMin
        # b := (x) == (y)
        - boolExprSimplify

        # https://go-critic.com/overview.html#builtinshadow
        # Запрещает использование ключевых слов языка в названии переменных
        # Экспериментальный
        # До
        # len := 10
        # После
        # length := 10
        #
        # predeclared выполняет ту же самую фукнцию
        # но настраивается и имеет возможность проверять поля
        # Выключаем
        # - builtinShadow

        # https://go-critic.com/overview.html#builtinshadowdecl
        # Запрещает использование ключевых слов языка в названии типов, интерфейсов и т.д. (top level declarations)
        # До
        # type int struct {}
        # После
        # type myInt struct {}
        # predeclared выполняет ту же самую фукнцию
        # но настраивается и имеет возможность проверять поля
        # Выключаем
        # - builtinShadowDecl

        # https://go-critic.com/overview.html#captlocal
        # Запрещает писать капсов для переменных
        # До
        # func f(IN int, OUT *int) (ERR error) {}
        # После
        # func f(in int, out *int) (err error) {}
        - captLocal

        # https://go-critic.com/overview.html#caseorder
        # Проверяет порядок в switch x.(type)
        # Если интерфейсы идут раньше конкретных значений то код описанный в касте на конкретное значение никогда не выполнится
        # switch x.(type) {
        #        case ast.Expr:
        #           fmt.Println("expr")
        #        case *ast.BasicLit:
        #           fmt.Println("basic lit") // Never executed
        #  }
        - caseOrder

        # https://go-critic.com/overview.html#codegencomment
        # Проверяет правильность коментов в codegen
        # До
        # // This file was automatically generated by foogen
        # После
        # // Code generated by foogen. DO NOT EDIT.
        - codegenComment

        # https://go-critic.com/overview.html#commentformatting
        # Форматирует комментарии
        # До
        # //This is a comment
        # После
        # // This is a comment
        - commentFormatting

        # https://go-critic.com/overview.html#commentedoutcode
        # Обнаруживает комментарии внутри тел функций
        # Достаточно умный, хотя и не исключаю некоторого количества false positive
        # Экспериментальный
        # До
        # // fmt.Println("Debugging hard")
        # foo(1, 2)
        # После
        # foo(1, 2)
        - commentedOutCode

        # https://go-critic.com/overview.html#commentedoutimport
        # Проверяет закоменченные импорты
        # Достаточно умный, хотя и не исключаю некоторого количества false positive
        # Не всегда срабатывает
        # Экспериментальный
        - commentedOutImport

        # https://go-critic.com/overview.html#defaultcaseorder
        # Запрещает вставлять default в switch куда либо кроме начала или конца
        #
        # Плохо
        # switch {
        # 	case true:
        # 	default:
        # 	case false:
        # }
        #
        # Хорошо
        # switch {
        # default:
        # case true:
        # case false:
        # }
        #
        # Хорошо
        # switch {
        # case true:
        # case false:
        # default:
        # }
        #
        # меня не устраивает что он позволяет делать default первой по порядку
        #
        # revive.enforce-switch-style выполняет ту же функцию
        # Однако он позволяет ставить default только последним
        # и проверяет наличие default ветки в каждом switch case
        #
        # Выключаем
        # - defaultCaseOrder

        # https://go-critic.com/overview.html#deferinloop
        # Запрещает вызывать defer в циклах
        #
        # Выглядит как частный случай revive.defer
        #
        # revive.defer выполняет ту же самую функцию
        # Однако спектр правил гораздо больше
        #
        # Выключаем
        # - deferInLoop

        # https://go-critic.com/overview.html#deferunlambda
        # Обнаруживает случаи когда вызов defer функции можно упростить
        # Экспериментальный
        # До
        # defer func() { f() }()
        # После
        # defer f()
        - deferUnlambda

        # https://go-critic.com/overview.html#deprecatedcomment
        # Проверяет правильность написания Deprecated коментов
        # До
        # // deprecated, use FuncNew instead
        # После
        # // Deprecated: use FuncNew instead
        - deprecatedComment

        # https://go-critic.com/overview.html#docstub
        # Запрещает писать затычки на коменты рода Foo ...
        # Включить в случае если в revive включено соответствующая проверка
        # - docStub

        # https://go-critic.com/overview.html#duparg
        # Анализирует код на подозрительные повторения аргументов
        # До
        # copy(dst, dst)
        # После
        # copy(dst, src)
        - dupArg

        # https://go-critic.com/overview.html#dupbranchbody
        # Обнаруживает случаи когда в if и else блоках заключен один и тот же код
        #
        # revive.identical-branches выполняет ту же самую функцию
        #
        # Выключаем
        # - dupBranchBody

        # https://go-critic.com/overview.html#dupcase
        # Обнаруживает повторения в switch case которые не в силах обнаружить компилятор
        #
        # До
        # case ys[0], ys[1], ys[2], ys[0], ys[4]:
        # После
        # case ys[0], ys[1], ys[2], ys[3], ys[4]:
        #
        # revive.identical-switch-conditions выполняет ту же самую функцию
        #
        # Выключаем
        # - dupCase

        # https://go-critic.com/overview.html#dupimport
        #
        # Обнаруживает дубликаты импортов под разными названиями
        # import (
        # 	"fmt"
        # 	printing "fmt" // Imported the second time
        # )
        #
        # staticcheck.ST1019 выполняет ту же самую функцию
        # revive.duplicated-imports выполняет ту же самую функцию
        #
        # Выбор сделан в пользу duplicated-imports
        #
        # Выключаем
        - dupImport

        # https://go-critic.com/overview.html#dupoption
        # Обнаруживает дубликаты функций при Option pattern
        #	_ = newPanel("hello",
        # 	withWidth(w),
        # 	withHeight(h),
        # 	/*! function argument `withWidth(w)` is duplicated */
        # 	withWidth(w),
        # )
        # Если используется та же функция-опция но с другими значениями линтер не реагирует
        - dupOption

        # https://go-critic.com/overview.html#dupsubexpr
        # Обнаруживает подозрительные дублирующиеся выражения
        #        sort.Slice(xs, func(i, j int) bool {
        #             return xs[i].v < xs[i].v // Duplicated index
        #        })
        #
        # staticcheck.SA4000 выполняет ту же самую функцию
        # revive.constant-logical-expr выполняет ту же самую функцию
        #
        # Выключаем в пользу revive.constant-logical-expr
        # - dupSubExpr

        # https://go-critic.com/overview.html#dynamicfmtstring
        # Обнаруживает некорректные использования fmt.Sprintf, fmt.Errorf функций
        # staticcheck.S1039 выполняет ту же самую функцию
        - dynamicFmtString

        # https://go-critic.com/overview.html#elseif
        # Обнаруживает код с if вложенным в else блок
        # Предлагает заменить на elseif
        # Достаточно туповат и пример с доки не воспроизводится
        # Если у нас во вложенном блоке есть конструкция вида if x := cond2; x elseif не репортит ничего
        - elseif

        # https://go-critic.com/overview.html#emptydecl
        - emptyDecl
        # https://go-critic.com/overview.html#emptyfallthrough
        # Связан с fallthrough который ОБЪЯВЛЕН АНТИПАТТЕРНОМ
        # Бесполезен
        # - emptyFallthrough

        # Detects empty string checks that can be written more idiomatically.
        # https://go-critic.com/overview.html#emptystringtest
        - emptyStringTest

        # https://go-critic.com/overview.html#equalfold
        # Обнаруживает неоптимальные сравнения строк
        # До
        # strings.ToLower(x) == strings.ToLower(y)
        # После
        # strings.EqualFold(x, y)
        - equalFold

        # https://go-critic.com/overview.html#evalorder
        # Обнаруживает нежелательные преобразования при вызове return
        # До
        # return x, f(&x)
        # После
        # err := f(&x)
        # return x, err
        - evalOrder

        # https://go-critic.com/overview.html#exitafterdefer
        # При наличии defer вызовов перед функциями запрещает вызов функций приводящих к закрытию программы через os.Exit
        # log.Fatal, log.Fatalf, os.Exit и т.д.
        # Полезно ведь defer в таком случае не будет вызван
        - exitAfterDefer

        # https://go-critic.com/overview.html#exposedsyncmutex
        # Запрещает встраивание sync.Mutex
        # Данную функцию уже выполняет другой линтер embeddedstructfieldcheck
        # Выключаем
        # - exposedSyncMutex

        # https://go-critic.com/overview.html#externalerrorreassign
        # Запрещает переназначать переменные типа error из других пакетов
        # context.Canceled = nil
        - externalErrorReassign

        # https://go-critic.com/overview.html#filepathjoin
        # Замечает некорректное использование filepath.Join
        # До
        # filepath.Join("dir/", filename)
        # После
        # filepath.Join("dir", filename)
        - filepathJoin

        # https://go-critic.com/overview.html#flagderef
        # Запрещает делать разименование для функций flag
        # До
        # b := *flag.Bool("b", false, "b docs")
        # После
        # var b bool; flag.BoolVar(&b, "b", false, "b docs")
        - flagDeref

        # https://go-critic.com/overview.html#flagname
        # Обнаруживает некорректные названия флагов (пробелы, другие некорректные символы)
        # До
        # b := flag.Bool(" foo ", false, "description")
        # После
        # b := flag.Bool("foo", false, "description")
        - flagName

        # https://go-critic.com/overview.html#hexliteral
        # Обнаруживает шестнадцинарные литералы со смешанными цифрами регистра
        # До
        # x := 0X12
        # y := 0xfF
        # После
        # x := 0x12
        # y := 0xff (A)
        # y := 0xFF (B)
        - hexLiteral

        # https://go-critic.com/overview.html#httpnobody
        # Замечает использования nil значений в боде http.NewRequest и просит заменить на http.NoBody
        # До
        # http.NewRequest("GET", url, nil)
        # После
        # http.NewRequest("GET", url, http.NoBody)
        - httpNoBody

        # https://go-critic.com/overview.html#hugeparam
        # Обнаруживает "тяжелые структуры" которые оптимальней было бы передавать через указатель вместо копирования
        # По умолчанию 80
        # До
        # func f(x [1024]int) {}
        # После
        # func f(x *[1024]int) {}
        - hugeParam

        # https://go-critic.com/overview.html#ifelsechain
        # Обнаруживает if else конструкции которые можно переписать на switch case
        - ifElseChain

        # https://go-critic.com/overview.html#importshadow
        # Определяет, когда импортированные имена пакетов затенены в назначениях.
        #
        # func main() {
        # 	fmt.Println("Hello World!")
        #
        # 	fmt := "Hello World"
        # 	_ = fmt
        # }
        #
        # revive.import-shadowing выполняет ту же самую функцию
        #
        # Выключаем
        # - importShadow

        # https://go-critic.com/overview.html#indexalloc
        # Обнаруживает когда вызов strings.Index можно заменить на bytes.Index вместо лишних аллокаций
        # До
        # strings.Index(string(x), y)
        # После
        # bytes.Index(x, []byte(y))
        - indexAlloc

        # https://go-critic.com/overview.html#initclause
        # Запрещает вызов функций в блоке if
        # До
        # if sideEffect(); cond {...}
        # После
        # sideEffect()
        # if cond {...}
        - initClause

        # https://go-critic.com/overview.html#mapkey
        # Обнаруживает странные включения в map ключах
        # Выглядит малополезным, c возможностью генераций неприятных false positive
        # - mapKey

        # https://go-critic.com/overview.html#methodexprcall
        # Обнаруживает обнаруживает методы которые могут быть сокращены
        # Мне не нравится сама суть линтера и показанный пример
        # Очень вероятно будет генерировать множесто false positive
        # - methodExprCall

        # https://go-critic.com/overview.html#nestingreduce
        # Обнаруживает места где можно избавится от лишней вложенности
        - nestingReduce

        # https://go-critic.com/overview.html#newderef
        # Обнаруживает немедленное разыменование new(Type).
        # До
        # x := *new(bool)
        # После
        # x := false
        - newDeref

        # https://go-critic.com/overview.html#nilvalreturn
        # Обнаруживает возвращающие операторы, результаты которых оценивают как ноль
        # Если оператор возвращает переменную чьё значение точно равно nil, предлагает заменить на явное определение
        # if err == nil {
        # 	return err
        # }
        # Предложит заменить на
        # if err == nil {
        #   return nil
        # }
        - nilValReturn

        # https://go-critic.com/overview.html#octalliteral
        # Обнаруживает восьмитеральные литералы старого стиля.
        # До
        # foo(02)
        # После
        # foo(0o2)
        # Позволяет подметить неожиданные использования
        # i := 010 равно одному разряду в восьмиричной системе
        # i == 8 (true)
        # i == 10 (false)
        - octalLiteral

        # https://go-critic.com/overview.html#offby1
        # Обнаруживает различные ошибки связанные со смещением на единицу
        # До
        # xs[len(xs)]
        # После
        # xs[len(xs)-1]
        - offBy1

        # https://go-critic.com/overview.html#paramtypecombine
        # Обязывает группировать переменные функции по типу
        # До
        # func foo(a, b int, c, d int, e, f int, g int) {}
        # После
        # func foo(a, b, c, d, e, f, g int) {}
        - paramTypeCombine

        # https://go-critic.com/overview.html#preferdecoderune
        # В случаях когда нам нужно получить первый символ строки предлагает заменить
        # r := []rune(s)[0]
        # На
        # r, _ := utf8.DecodeRuneInString(s)
        # Потому что последний случай не предполагает дополнительных аллокаций вызванных []rune(s)
        - preferDecodeRune

        # https://go-critic.com/overview.html#preferfilepathjoin
        # Обнаруживает некорректный способ конкатенации с os.PathSeparator
        # Предлагает заменить на filepath.Join
        # До
        # x + string(os.PathSeparator) + y
        # После
        # filepath.Join(x, y)
        # Не реагирует на какие либо другие способы конкатенации, только с os.PathSeparator
        - preferFilepathJoin

        # https://go-critic.com/overview.html#preferfprint
        # Обнаруживает случаи когда fmt.Sprint(f/ln) может быть заменено на fmt.Fprint(f/ln)
        #
        # До
        # w.Write([]byte(fmt.Sprintf("%x", 10)))
        #
        # После
        # fmt.Fprintf(w, "%x", 10)
        #
        - preferFprint

        # https://go-critic.com/overview.html#preferstringwriter
        # Если Writer имеет метод WriteString предлагает заменить вызов
        # w.Write([]byte("foo"))
        # На
        # w.WriteString("foo")
        # mirror выполняет ту же самую функцию, однако разбирает гораздо больше случаев
        # Выключаем
        # - preferStringWriter

        # https://go-critic.com/overview.html#preferwritebyte
        # Обнаруживает случаи когда руна переданная
        # В
        # w.WriteRune(<rune>)
        # Является ASCII символом, соответственно умещается в один байт и может быть заменена
        # На
        # w.WriteByte(<rune>)
        - preferWriteByte

        # https://go-critic.com/overview.html#ptrtorefparam
        # Анализирует входные/выходные параметры на предмет наличия указателей на референсные типы
        # До
        # func f(m *map[string]int) (*chan *int)
        # После
        # func f(m map[string]int) (chan *int)
        - ptrToRefParam

        # https://go-critic.com/overview.html#rangeappendall
        # Обнаруживает вставку всего слайса во время итерации вместо встаки отдельного параметра
        # for _, n := range ns {
        # 	rs = append(rs, ns...) // append all slice data
        #   Заменит на
        #   rs = append(rs, n)
        # }
        # Не вижу практической пользы, может генерировать кучу false positive
        # - rangeAppendAll

        # https://go-critic.com/overview.html#rangeexprcopy
        # Обнаруживает излишнее копирование array при итерации
        # var data []byte
        # До
        # for _, x := range data // копирует 2048 байт
        # После
        # for _, x := range &data // копирования данный не происходит
        - rangeExprCopy

        # https://go-critic.com/overview.html#rangevalcopy
        # Обнаруживает циклы которые на каждую итерацию копируют большие объемы данных
        # var data make([][1024]byte, 100)
        # До
        # for _, x := range data // на каждую итерацию происходит копирование 1024 байт
        # После
        # for i := range xs
        # x := &xs[i] // доступ по указателю
        - rangeValCopy

        # https://go-critic.com/overview.html#redundantsprint
        # Проверяет на наличие излишних fmt.Sprint
        #
        # До
        # fmt.Sprint(x)
        # После
        # x.String()
        #
        - redundantSprint

        # https://go-critic.com/overview.html#regexpmust
        # В случаях когда на вход regexp.Compile подаётся константа предлагает заменить на regexp.MustCompile
        # Не зависит от того проверяем мы ошибку или нет, ключевым фактором является строковая константа в аргументе функции
        # До
        # re, _ := regexp.Compile("const pattern")
        # После
        # re := regexp.MustCompile("const pattern")
        - regexpMust

        # https://go-critic.com/overview.html#regexppattern
        # Проверяет регулярные выражения на распространённые ошибки
        # Например неэкранированная точка
        # До
        # regexp.MustCompile(`google.com|yandex.ru`)
        # После
        # regexp.MustCompile(`google\.com|yandex\.ru`)
        - regexpPattern

        # https://go-critic.com/overview.html#regexpsimplify
        # Проверяет регулярные выражения на возможность упрощения
        # До
        # regexp.MustCompile(`(?:a|b|c)   [a-z][a-z]*`)
        # После
        # regexp.MustCompile(`[abc] {3}[a-z]+`)
        - regexpSimplify

        # https://go-critic.com/overview.html#returnafterhttperror
        # Обнаруживает вызовы http.Error после которых не последовал return
        # До
        # if err != nil { http.Error(...); }
        # После
        # if err != nil { http.Error(...); return; }
        - returnAfterHttpError

        # https://go-critic.com/overview.html#ruleguard
        # https://github.com/quasilyte/go-ruleguard
        # https://go-ruleguard.github.io/by-example/
        # Очень мощный инструмент для проверок
        # Позволяет писать собственные линтеры в файлах go
        # Настраиваемый
        # - ruleguard

        # https://go-critic.com/overview.html#singlecaseswitch
        # Если наш switch case состоит из одного case предлагает заменить его на if
        # До
        # switch x := x.(type) {
        #     case int:
        #         body()
        # }
        # После
        # if x, ok := x.(int); ok {
        #     body()
        # }
        - singleCaseSwitch

        # https://go-critic.com/overview.html#sliceclear
        # Обнаруживает циклы зачищающие массивы
        # Выглядит излишним
        # Не вижу практического применения
        # Выглядит как частный случай intrange
        # intrange выполняет ту же самую функцию
        # Выключаем
        # - sliceClear

        # https://go-critic.com/overview.html#sloppylen
        # Результат функции len() имеет тип int
        # Однако он не может быть меньше нуля
        # До
        # len(arr) <= 0
        # После
        # len(arr) == 0
        #
        # staticcheck.SA4024 выполняет ту же самую фукнцию
        # Однако работает на cap
        #
        # Выключаем
        # - sloppyLen

        # https://go-critic.com/overview.html#sloppyreassign
        # Обнаруживает неуместные, подозрительные, странные переназначения переменных
        # До
        # if err = f(); err != nil { return err }
        # После
        # if err := f(); err != nil { return err }
        - sloppyReassign

        # https://go-critic.com/overview.html#sloppytypeassert
        # Сообщает о неуместных, бессмысленных type assert
        # staticcheck.S1040 выполняет ту же самую функцию
        - sloppyTypeAssert

        # https://go-critic.com/overview.html#sortslice
        # Обнаруживает некорректные использования sort.Slice
        # Некорректный порядок i, j
        # Более не нашёл, должен подсказывать замену sort.Slice на sort.Ints, sort.Strings при соответствующих типах элементов массива
        # Но ничего такого не происходит
        # Оставляю
        - sortSlice

        # https://go-critic.com/overview.html#sprintfquotedstring
        # Обнаруживает директивы форматирования «%s», которые могут быть заменены на %q.
        # До
        # fmt.Sprintf(`"%s"`, s)
        # После
        # fmt.Sprintf(`%q`, s)
        - sprintfQuotedString

        # https://go-critic.com/overview.html#sqlquery
        # Если мы не используем возвращаемое значение из db.Query, db.QueryContext предлагает заменить на db.Exec и db.ExecContext соответственно
        # Не работает на db.QueryRow и db.QueryRowContext
        - sqlQuery

        # https://go-critic.com/overview.html#stringconcatsimplify
        # Сообщает о случаях когда конкатенация строк может быть упрощена
        # До
        # strings.Join([]string{x, y}, "_")
        # После
        # x + "_" + y
        - stringConcatSimplify

        # https://go-critic.com/overview.html#stringxbytes
        # Сообщает об излишних конверсиях между string и []byte
        # До
        # copy(b, []byte(s))
        # После
        # copy(b, s)
        - stringXbytes

        # https://go-critic.com/overview.html#stringscompare
        # Запрещает использовать strings.Compare
        # Заменяет на встроенное сравнение
        # До
        # strings.Compare(x, y)
        # После
        # x < y
        # Может генерить false positive однако как часто мы вообще используем strings.Compare
        # Оправдан
        - stringsCompare

        # https://go-critic.com/overview.html#switchtrue
        # Запрещает делать switch true constant
        # При чем с false всё хорошо
        # До
        # switch true {...}
        # После
        # switch {...}
        - switchTrue

        # https://go-critic.com/overview.html#syncmaploadanddelete
        # Обнаруживает последовательный вызов функций sync.Map Load + Delete и предлагает заменить на один вызов функции LoadAndDelete
        # До
        # v, ok := m.Load(k); if ok { m.Delete($k); f(v); }
        # После
        # v, deleted := m.LoadAndDelete(k); if deleted { f(v) }
        - syncMapLoadAndDelete

        # https://go-critic.com/overview.html#timeexprsimplify
        # Обнаруживает случаи ручной конвертации времени в миллисекунды
        # Достаточно туповат работает только на один кейс
        # mnd всегда выручит в подобной ситуации
        # До
        # t.Unix() / 1000
        # После
        # t.UnixMilli()
        - timeExprSimplify

        # https://go-critic.com/overview.html#todocommentwithoutdetail
        # Запрещает писать пустые TODO
        # До
        # // TODO
        # После
        # // TODO(admin): pass context.TODO() instead of nil
        - todoCommentWithoutDetail

        # https://go-critic.com/overview.html#toomanyresultschecker
        # Запрещает возвращать из функции больше определённого количества аргументов
        # Настраивается (по умолчанию 5)
        # До
        # func fn() (a, b, c, d float32, _ int, _ bool)
        # После
        # func fn() (resultStruct, bool)
        #
        # revive.function-result-limit выполняет ту же самую функцию
        #
        # Выключаем
        # - tooManyResultsChecker

        # https://go-critic.com/overview.html#truncatecmp
        # Обнаруживает потенциальные случаи переполнения при конвертации числовых типов
        # При сравнении двух чисел разных типов, приведение должно быть к большему разряду
        # Так как иначе возможен срез и неопределённое поведение
        # x := int32()
        # y := int16()
        # До
        # int16(x) < y // если x больше чем 32767 то произодёт переполнение
        # После
        # x < int32(y)
        # Пример как работает переполнение при конвертации типов
        # x := 1000000
        # println(int16(int32(x))) // выведет 16960
        # Разбирает лишь случаи переполнения при сравнении
        # Выглядит как частный случай gosec.G115, который покрывает все случае конвертации
        # gosec.G115 выполняет ту же самую функцию
        # Выключаем
        # - truncateCmp

        # https://go-critic.com/overview.html#typeassertchain
        # Обнаруживает ветки if else c type assertion и предлагает заменить на switch x.(type)
        - typeAssertChain

        # https://go-critic.com/overview.html#typedeffirst
        # Если метод структуры объявлен в коде раньше чем сама структура выведет предупреждение
        - typeDefFirst

        # https://go-critic.com/overview.html#typeswitchvar
        #
        # Обнаруживает переключатели типа, которые могут извлечь выгоду из предложения защиты типа с переменной
        # staticcheck.S1034 выполняет ту же самую функцию
        #
        # var reader io.Reader
        #
        # До
        # switch reader.(type) {
        # case *bytes.Buffer: // reader всё ещё имеет тип io.Reader, необходимо дополнительно кастить тип
        # 	_, ok := reader.(*bytes.Buffer)
        # 	_ = ok
        # case *strings.Reader: // reader всё ещё имеет тип io.Reader, необходимо дополнительно кастить тип
        # 	_, ok := reader.(*strings.Reader)
        # 	_ = ok
        # }
        #
        # После
        # switch reader := reader.(type) {
        # case *bytes.Buffer:
        # 	var _ *bytes.Buffer = reader // reader имеет тип *bytes.Buffer
        # case *strings.Reader:
        # 	var _ *strings.Reader = reader // reader имеет тип *strings.Reader
        # }
        #
        # staticcheck.S1034 выполняет ту же самую функцию
        #
        # Однако мне понравилось что он подсвечивает именно ветки (case), а не просто указывает
        # на switch где есть проблема
        #
        # Выключаем
        #
        # - typeSwitchVar

        # https://go-critic.com/overview.html#typeunparen
        # Убирает лишние скобочки при объявлении переменных
        # До
        # type foo [](func([](func())))
        # После
        # type foo []func([]func())
        - typeUnparen

        # https://go-critic.com/overview.html#uncheckedinlineerr
        # Обнаруживает непроверенные ошибки в if
        # Только при инлайнинге
        # До
        # if err := expr(); err2 != nil { /*...*/ }
        # После
        # if err := expr(); err != nil { /*...*/ }
        - uncheckedInlineErr

        # https://go-critic.com/overview.html#underef
        # Обнаруживает разыменования которые могут быть опущены
        # До
        # (*k).field = 5
        # v := (*a)[5] // only if a is array
        # После
        # k.field = 5
        # v := a[5]
        - underef

        # https://go-critic.com/overview.html#unlabelstmt
        # Обнаруживает избыточные метки оператора
        # derp: // может быть опущена
        #   for x := range xs {
        #       if x == 0 {
        # 	        break derp // может быть опущена
        #       }
        #   }
        - unlabelStmt

        # https://go-critic.com/overview.html#unlambda
        # Обнарживает использования функций которые могут быть сокращены
        # До
        # slices.SortFunc(nums, func(a, b int) int { return cmp.Compare(a, b) })
        # После
        # slices.SortFunc(nums, cmp.Compare)
        - unlambda

        # https://go-critic.com/overview.html#unnamedresult
        #
        # Функция не может возвращать больше двух элементов благодаря gocritic.tooManyResultsChecker
        # Соответственно в случаях когда мы возвращаем 2 аргумента среди которых нет error мы обязаны их назвать
        #
        # В случае если мы возвращаем два агумента среди которых нет последней error мы обязаны их назвать
        # func manyResults() (int, int) { return 0, 0 } // в таком случае обязаны назвать результаты функции
        # func manyResults() (x, y int) { return 0, 0 } // Всё верно
        #
        # revive.confusing-results выполняет ту же самую функцию
        #
        # Выключаем
        #
        # - unnamedResult

        # https://go-critic.com/overview.html#unnecessaryblock
        # Обнаруживает неуместное использование блоков {...}
        # До
        # x := 1
        # {
        #     print(x)
        # }
        # После
        # x := 1
        # print(x)
        - unnecessaryBlock

        # https://go-critic.com/overview.html#unnecessarydefer
        # Обнаруживает избыточные употребления defer
        # До
        # func foo(name string) { defer os.Remove(name) }
        # После
        # func foo(name string) { os.Remove(name) }
        - unnecessaryDefer

        # https://go-critic.com/overview.html#unslice
        # Обнаруживает избыточные употребления unslice [:]
        # До
        # copy(b[:], values...)
        # После
        # copy(b, values...)
        - unslice

        # https://go-critic.com/overview.html#valswap
        # Предлагает более оптимальный вариант обмена значений переменных там где это возможно
        # До
        # *tmp = *x; *x = *y; *y = *tmp
        # После
        # *x, *y = *y, *x
        - valSwap

        # https://go-critic.com/overview.html#weakcond
        # Проверяет ряд условий которые не являются исключающими, которые при этом могут привести к ошибкам
        # До
        # xs != nil && xs[0] != nil // xs может быть non-nil пустым массивом, следовательно второе условие вызовет панику
        # После
        # len(xs) != 0 && xs[0] != nil // второе условие выполнится только в случае когда длина массива равно 1 и более
        - weakCond

        # https://go-critic.com/overview.html#whynolint
        # Запрещает писать //nolint без объяснение причин
        # До
        # //nolint
        # После
        # //nolint // reason
        # Для регулирования проверок относительно nolint объявлений существует специальный линтер
        # nolintlint выполняет ту же самую фукнцию
        # Но при этом настраивается
        # Выключаем
        # - whyNoLint

        # https://go-critic.com/overview.html#wrapperfunc
        # Обнаруживает функции которые могут быть заменены на соответствующие обертки
        # До
        # wg.Add(-1)
        # После
        # wg.Done()
        - wrapperFunc

        # https://go-critic.com/overview.html#yodastyleexpr
        # Обнаруживает Yoda style выражения и предлагает заменить на обычные
        # При сравнении переменной с константой сначала идёт переменная и только потом константа
        # До
        # return nil != ptr
        # После
        # return ptr != nil
        - yodaStyleExpr

        # https://go-critic.com/overview.html#zerobyterepeat
        # Обнаруживает заполнения []byte c помощью функции bytes.Repeat
        # когда []byte заполняется пустыми значениями
        # До
        # bytes.Repeat([]byte{0}, x)
        # После
        # make([]byte, x)
        - zeroByteRepeat

      settings:
        commentedOutCode:
          # Если хоть один символ есть закоменченный то он должен быть убран
          minLength: 0

        rangeValCopy:
          # Пропускаем тестовы функции
          skipTestFuncs: true

        # Закоменчено из-за того что gocritic пишет warning если для выключенного линтера не указаны настройки
        # ruleguard:
        #   # Папка с файлами содержащими правила
        #   rules: rules/*.go

    gosec:
      config:
        # важно включать разрешение в кавычки, иначе разрешение не переопределяется
        G306: "0o666"
      # To select a subset of rules to run.
      # Available rules: https://github.com/securego/gosec#available-rules
      # Default: [] - means include all rules
      includes:
        # https://github.com/securego/gosec/blob/master/RULES.md
        # Проверяет захардкоженные переменные которые потенциально могут быть секретами
        # Например захардкоженная строка
        # var secretToken = "asdfasfdaskljfla"
        # Будет замечена этим правилом
        # Оставляем, полезно
        # Регулярное выражение для поиска credentials настроивается
        - G101 # Look for hard coded credentials

        # Запрещает использование "0.0.0.0" для IPv4 и "::" для IPv6
        # Использование таких интерфейсов открывает приложение доступным для всех
        # Что может быть нежелательно в ряде случаев
        # Умный, просто на строки не реагирует, только на непосредственное подключение
        # Но легко обманывается если хост становится переменной
        # Тем не менее полезно
        - G102 # Bind to all interfaces

        # Запрещает пользоваться функциями из пакета unsafe
        - G103 # Audit the use of unsafe block

        # https://github.com/securego/gosec/blob/master/RULES.md#g104
        # Проверяет обработку ошибок
        # Выключаем так как этим уже занимается настроенным нами errcheck
        # errcheck выполняет ту же самую фукнцию
        # - G104 # Audit errors not checked

        # Было связано с использованием math/big.Int.Exp
        # В настроящее время исправлено
        # Данное правило удалено из линтера и больше не поддерживается
        # - G105

        # Запрещает использование ssh.InsecureIgnoreHostKey
        # Игнорирование проверки ssh ключей может привести к атаке MITM (Man In The Middle)
        - G106 # Audit the use of ssh.InsecureIgnoreHostKey

        # Запрещает делать http.Get, http.Post, http.Do, http.Head, http.PostForm с url из сторонних источников
        # http.NewRequest при этом проходит
        # Очень странный
        # Выключаем
        # - G107 # Url provided to HTTP request as taint input

        # Запрещает использовать импорт _ net/http/pprof
        # По умолчанию он регистрирует их к http.DefaultServeMux что может привести к нежелательным последствиям
        # Необходимо регистрировать их вручную к вашему http серверу
        - G108 # Profiling endpoint automatically exposed on /debug/pprof

        # Предупреждает о потенциальном переполнении чисел при использовании strconv.Atoi
        # Ты можешь конвертировать строку в число, при этом его значение будет больше чем int32
        # Далее ты конвертируешь это число до int32 что может привести к переполнению
        # Так как размер int платформозависимый
        # Выглядит как частный случай G115 и может приводить к дублям
        # Выключаем
        # - G109 # Potential Integer overflow made by strconv.Atoi result conversion to int16/32

        # В случае если в функцию io.Copy, io.CopyBuffer в качестве src io.Reader параметра передан тип gzip.*Reader
        # В данный список входят ряд типов, возвращаемых функциями пакетов
        # которые предоставляют функционал работы с архивами
        # Сообщит о возможной опасности
        # Требует указывать максимальное количество данных которое желаете копировать
        # Иначе может привести с нежелательному исчерпанию памяти
        # Независимо от dst io.Writer параметра, даже если ты копируешь не в оперативную память а на диск
        # Безвредно, пусть будет
        - G110 # Potential DoS vulnerability via decompression bomb

        # https://github.com/securego/gosec/blob/master/RULES.md#g111
        # Запрещает http.Dir("/"), что даёт доступ ко всем файлам в файловой системе
        # Настраиваемый
        - G111 # Potential directory traversal

        # slowloris - тип DoS атаки когда злоумышленник
        # поддерживает их как можно больше, медленно отправляя данные
        # что приводит к отказу в обслуживании
        # Правило срабатывает если в http.Server не указан ReadHeaderTimeout или ReadTimeout
        # ReadHeaderTimeout, IdleTimeout в случае если не определены используют значение ReadTimeout
        # Если же и ReadTimeout не определен то значения остаются не заданными и срабатывает линтер
        - G112 # Potential slowloris attack

        # Продолжение предыдущего правила, запрещает использование функций http которые не поддерживают timeout
        # А именно ListenAndServe, ListenAndServeTLS, Serve, ServeTLS
        - G114 # Use of net/http serve function that has no support for setting timeouts

        # Запрещает конвертацию чисел большей битности в меньшую
        # i := int64(rand.Int())
        # _ = int32(i)
        - G115 # Potential integer overflow when converting between integer types

        # Запрещает использовать результат фунции fmt.Sprintf в качестве аргумента
        # query в типах стандартной библиотеки
        # Не работает на сторонние библиотеки
        # Обманывается оборачиваением в функцию и параметризацией query
        # Обманывается через fmt.Fprintf
        - G201 # SQL query construction using format string

        # Продолжение предыдущего правила
        # Запрещает использовать строки, сконкатенированные с переменными
        # При конкатенации статичных строк правило не срабатывает
        # 	_, _ = db.Exec("SELECT " + "a, b, c " + "FROM " + "requests") - только статичные строки, правило не работает
        # 	_, _ = db.Exec("SELECT " + "a, b, c " + "FROM " + table - table переменная типа string, правило работает
        # Не работает на сторонние библиотеки
        # Обманывается оборачиваением в функцию и параметризацией query
        - G202 # SQL query construction using string concatenation

        # Запрещает оборачивание в следующие типы данных из внешних источников (не статичный контент) включая embed
        # html.template.CSS
        # html.template.HTML
        # html.template.HTMLAttr
        # html.template.JS
        # html.template.JSStr
        # html.template.Srcset
        # html.template.URL
        # так как эти типы используются как маркер надежных данных которые не требуют экранирования
        # неверные данные могут привести к XSS атакам
        - G203 # Use of unescaped data in HTML templates

        # Запрещает создавать дочерний процесс с данными из внешних источников
        # os/exec.Command|CommandContext и все функции которые так или иначе создают новый процесс
        # Может генерить достаточно большое количество false positive
        # Выключаем
        # - G204 # Audit use of command execution

        # Часть следующих линтеров связаны с файловыми разрешениями
        # 4 - чтение, 2 - запись, 1 - выполнение
        # Разберем допустимое разрешение 750
        # Первый символ означает разрешения для владельца, в данный линтер разреш
        # 7 = 4 + 2 + 1 = Чтение(4) + Запись(2) + Выполнение(1)
        # Второй символ означает разрешения для группы (группу можно узнать с помощью ls -l имя_файла)
        # 5 = 4 + 1     = Чтение(4) + Выполнение(1)
        # Третий символ означает разрешения для пользователя который
        # А) Не является владельцем файла
        # Б) Не входит в группу-владелец
        # Такой пользователь попадает в категорию (остальные)
        # 0 = 0 - никакие действия с файлом недоступны

        # https://github.com/securego/gosec/blob/master/RULES.md#g301-g302-g306-g307
        # Указывает максимально допустимые разрешения при создании директорий
        # Срабатывает при вызове функций os.Mkdir, os.MkdirAll с разрешением выше 750
        # 7 - для владельца директории нет ограничений
        # 5 - для группы возможно только Чтение(4) + Выполнение(1)
        # 0 - для прочих пользователей недопустимы никакие действия с директорией
        # Допустимое разрешение настраивается
        # Запрещает создавать папки которые заведомо могут быть доступны нежелательным пользователям
        - G301 # Poor file permissions used when creating a directory

        # https://github.com/securego/gosec/blob/master/RULES.md#g301-g302-g306-g307
        # Указывает максимально допустимые разрешения при создании директорий
        # Срабатывает при вызове функций os.OpenFile, os.Chmod с разрешением выше 600
        # 6 - для владельца возможны только Чтение(4) + Запись(2)
        # 0 - для группы недопустимы никакие действия
        # 0 - для прочих пользователей недопустимы никакие действия
        # Допустимое разрешение настраивается
        # Запрещает менять разрешение в большую сторону
        # Запрещает открывать файл для выполнения, читать или писать файл кому либо кроме владельца
        - G302 # Poor file permissions used with chmod

        # Запрещает создавать файлы в /tmp /var директориях с помощью стандартных функций
        # Для создания файла в подобных директориях необходимо использовать os.CreateTemp
        - G303 # Creating tempfile using a predictable path

        # Запрещает открывать файлы по пути полученных из строковых переменных
        # Разрешается открывать файлы только из статичных строк, известных на этапе компиляции
        # В go 1.24 добавили os.Root, с помощью него можно решить данную проблему
        # методы работы с файлами в структуре os.Root не позволяют открыть файл извне рутовой директории
        - G304 # File path provided as taint input

        # Запрещает следующие конструкции кода
        # _ = path.Join(new(zip.File).Name)
        # _ = filepath.Join(new(tar.Header).Name)
        # При разархивации мы создаём копию всех файлов в архиве включая названия
        # Если файл будет содержать в своем названии ../filename
        # При разархивации мы можем создать файл в некорреткной локации
        # Решение: разархивировать с помощью os.Root или проверять пути файлов которые мы создаем
        # Хорошо комбинируется с предыдущим файлом
        - G305 # File traversal when extracting zip/tar archive

        # https://github.com/securego/gosec/blob/master/RULES.md#g301-g302-g306-g307
        # Указывает максимально допустимые разрешения при записи файла
        # Срабатывает при вызове функций os.WriteFile с разрешением выше 600
        # 6 - для владельца возможны только Чтение(4) + Запись(2)
        # 0 - для группы недопустимы никакие действия
        # 0 - для прочих пользователей недопустимы никакие действия
        # Допустимое разрешение настраивается
        # Файл который мы записали нашей программой не должен быть исполняемым и доступ к нему должен быть только у нас
        # Дефолтное разрешение изменено на 0o666, файл который мы создали программой может быть доступен для всех
        # Связано с дефолным ограничением следующего правила
        - G306 # Poor file permissions used when writing to a new file

        # https://github.com/securego/gosec/blob/master/RULES.md#g301-g302-g306-g307
        # Указывает максимально допустимые разрешения при записи файла
        # Срабатывает при вызове функций os.Create с разрешением выше 666
        # 6 - для владельца возможны только Чтение(4) + Запись(2)
        # 6 - для группы возможны только Чтение(4) + Запись(2)
        # 6 - для прочих возможны только Чтение(4) + Запись(2)
        # Допустимое разрешение настраивается
        # Файл который мы создали нашей программой не должен быть исполняемым и доступ к нему должен быть только у нас
        - G307 # Poor file permissions used when creating a file with os.Create

        # Алгоритмы md5 или sha1 являются небезопасными
        # Выключен по причине добавления этих пакетов в черный лист
        # Данный подход позволит избежать смысловых дублей при использовании линтера
        # Выключаем
        # - G401 # Detect the usage of MD5 or SHA1

        # в tls.Config разрешает использовать только допустимый список CipherSuites
        # запрещает проставлять InsecureSkipVerify: true (легко обмануть если присвоить значение после создания конфига)
        # запрещает использовать устаревшие версии TLS, доступны только tls.VersionTLS12, tls.VersionTLS13
        - G402 # Look for bad TLS connection settings

        # Запрещает вызов функции crypto/rsa.GenerateKey(rand.Reader, bits) где bits < 2048
        - G403 # Ensure minimum RSA key length of 2048 bits

        # Запрещает использование функций math/rand и math/rand/v2
        # Данные пакеты являются криптографически небезопасными
        # Проще запретить импорт подобных пакетов и делегировать настройку данного правила depguard
        # Выключаем
        # - G404 # Insecure random number source (rand)

        # Алгоритмы des или rc4 являются небезопасными
        # Выключен по причине добавления этих пакетов в черный лист
        # Данный подход позволит избежать смысловых дублей при использовании линтера
        # Выключаем
        # - G405 # Detect the usage of DES or RC4

        # Алгоритмы md4 или ripemd160 являются небезопасными
        # Выключен по причине добавления этих пакетов в черный лист
        # Данный подход позволит избежать смысловых дублей при использовании линтера
        # Выключаем
        # - G406 # Detect the usage of MD4 or RIPEMD160

        # Управление import blocklist делегировано depguard
        # Выключаем
        # - G501 # Import blocklist: crypto/md5
        # - G502 # Import blocklist: crypto/des
        # - G503 # Import blocklist: crypto/rc4

        # данный пакет считается устаревшив
        # - G504 # Import blocklist: net/http/cgi

        # - G505 # Import blocklist: crypto/sha1
        # - G506 # Import blocklist: golang.org/x/crypto/md4
        # - G507 # Import blocklist: golang.org/x/crypto/ripemd160

        # проверка на указатель от переменной в for range slice
        # исправлено в go 1.22
        # - G601 # Implicit memory aliasing of items from a range statement

        # в доке это правило есть
        # однако в исходном коде актуального на данный момент gosec (github.com/securego/gosec/v2 v2.22.10) не указано
        # Выключаем
        # - G602 # Slice access out of bounds
    govet:
      # Disable all analyzers.
      # Default: false
      disable-all: true
      # Enable analyzers by name.
      # (In addition to default:
      #   appends, asmdecl, assign, atomic, bools, buildtag, cgocall, composites, copylocks, defers, directive, errorsas,
      #   framepointer, httpresponse, ifaceassert, loopclosure, lostcancel, nilfunc, printf, shift, sigchanyzer, slog,
      #   stdmethods, stringintconv, structtag, testinggoroutine, tests, timeformat, unmarshal, unreachable, unsafeptr,
      #   unusedresult
      # ).
      # Run `GL_DEBUG=govet golangci-lint run --enable=govet` to see default, all available analyzers, and enabled analyzers.
      # Default: []
      enable:
        # Check for missing values after append.
        # Сообщает об append в который передан всего один аргумент
        # a := append(a)
        # gocritic.badCall выполняет ту же функцию
        # Выключаем
        # - appends

        # Report mismatches between assembly files and Go declarations.
        # У меня не получилось вопсроизвести предложенный пример от DeepSeek
        # Если приходится работать с интеграцией assembly и go то определенно ваш выбор
        # Валидирует assembly код
        # ассемблер
        - asmdecl

        # Check for useless assignments.
        # Проверяет результаты переменных которые присваиваются сами себе
        #
        # a := 1
        # a = a // поругается на такое
        #
        # ineffassign выполняет ту же самую функцию
        #
        # Выключаем
        # - assign

        # Check for common mistakes using the sync/atomic package.
        # Проверяет работу с atomic структурами
        # Нельзя допускать копирования по значению
        # Аналогов нет
        - atomic

        # Check for non-64-bits-aligned arguments to sync/atomic functions.
        # Если вы работаете на 64 битной архитектуре линтер не будет работать
        #
        # В интернет ресурсах удалось найти примеры где на невыравненных структурах
        # при использовании atomic.AddInt32(ptr, value) могли возникать проблемы
        # Выключаем
        # - atomicalign

        # Check for common mistakes involving boolean operators.
        # Сообщает об ошибках с булевыми операторами
        # if (a && b) || (a && b) { // Дублирование
        - bools

        # Check //go:build and // +build directives.
        # Проверяет правила build tags (go:build linux)
        # Сообщает о случаях если комментарий // +build идёт раньше //go:build
        #
        # Интересно получается воспроизвести при запуске
        # golangci-lint run ./main.go
        #
        # При запуске golangci-lint run сообщений нет
        #
        - buildtag

        # Detect some violations of the cgo pointer passing rules.
        # Проверяет передачу ссылочных типов в cgo как указателей через unsafe.Pointer(&v)
        # h := make(chan int)
        # C.foo(unsafe.Pointer(&ch))
        - cgocall

        # Check for unkeyed composite literals.
        # type MyStruct {Integer int}
        # _ = MyStruct{1} // сообщит об нарушении если структура импортирована из внешнего пакета
        # _ = MyStruct{Integer: 1}
        # правильно, в случае если у структуры одно поле
        # мы может просто передать тип в структуру, что может привести к нежелательному поведению
        # в случае изменения полей структуры, данный линтер принуждает всегда использовать синтаксис
        # присвоения полей по ключу
        - composites

        # Check for locks erroneously passed by value.
        # Запрещает копирование различных структур связанные с блокировками
        # самый простой пример это передача sync.Mutex по значению
        # что приводит к копированию и все действия с mutex не имеют смысла
        # и могут привести к panic при работе приложения
        - copylocks

        # Check for calls of reflect.DeepEqual on error values.
        # Запрещает передачу двух ошибок в reflect.DeepEqual
        # Сообщает лишь о случаях когда оба аргумента имеют тип error
        # reflect.DeepEqual(error, int) считается валидным в рамках этого линтера
        - deepequalerrors

        # Report common mistakes in defer statements.
        # Сообщает о возможных ошибках в использовании defer
        # В исходниках golangci-lint обрабатывается только случай с time.Since
        # defer func(time.Duration) {}(time.Since(time.Now()))
        # Дело в том что при вызове defer аргументы вычисляются в момент появления defer функции
        # таким образом time.Since(time.Now()) будет вызвано немедленно не дожидаясь конца функции
        - defers

        # Check Go toolchain directives such as //go:debug.
        # Проверяет go:debug директиву
        # Например что коментарий //go:debug должен идти до объявления package <package name>
        - directive

        # Report passing non-pointer or non-error values to errors.As.
        # Проверяет что при вызове errors.As, второй аргумент является
        # указателем на тип имплементирующий error
        # errors.As(error(nil), error(nil)) // второй аргумент является типом error
        # errors.As(error(nil), (*error)(nil)) // нельзя чтобы второй аргумент был *error
        # errors.As(error(nil), any(nil)) // тип any разрешен
        #
        # err := errorType{} // func(errorType) Error() string
        # errors.As(error(nil), err)  // запрещено так как errorType имплементирует error, нужен указатель на него
        # errors.As(error(nil), &err) // разрешено так как errorType сам по себе имплементирует тип error
        - errorsas

        # Find structs that would use less memory if their fields were sorted.
        # Проверяет наличие структур размер которых можно оптимизировать поменяв поля местами
        # type notAligned struct {
        # 	b  bool
        # 	b1 bool
        # 	i  int64
        # 	j  int32
        # } размер равен 24, выравнено по 8 байт, b и b1 занимают 8 байт, i занимает 8 байт, j занимает 8 байт
        #
        # type notAligned struct {
        # 	i  int64
        # 	j  int32
        # 	b  bool
        # 	b1 bool
        # } размер равен 16, выравнено по 8 байт но теперь j, b и b1 вместе взятые занимают 8 байт + i которая всё ещё занимает 8 байт
        #
        #
        # Есть следующая структура
        # type User struct {
        # 	Name    string
        # 	Surname *string
        # }
        #
        # fieldalignment сообщит следующее
        # fieldalignment: struct with 24 pointer bytes could be 16
        #
        # Хотя при этом размер структуры невозможно сократить перестановкой параметров Name и Surname
        #
        # https://github.com/golang/go/issues/44877#issuecomment-794565908 - тут разбирался подобный случай
        #
        # fieldalignment делает две проверки
        #
        # 1. Оптимизирует размер структур
        # 2. Анализирует количество байт, которое сборщику мусора необходимо пройти для того чтобы добраться до указателя
        #
        # В нашем случае fieldalignment желает видеть следующую структуру
        #
        # type User struct {
        # 	Surname *string
        # 	Name    string
        # }
        #
        # Последнее может генерировать кучу false positive
        #
        # От линтера больше вреда чем пользы
        #
        # Если вашему проекту необходимы микрооптимизации в виде выравнивания структур
        # то вам следует включить его
        #
        # Выключаем
        # - fieldalignment

        # Find calls to a particular function.
        # Всё что он делает это находит вызовы отдельных функций
        # Бесполезен
        # Выключаем
        # - findcall

        # Report assembly that clobbers the frame pointer before saving it.
        # Валидирует assembly код
        # ассемблер
        - framepointer

        # Check format of addresses passed to net.Dial.
        #
        # _, _ = net.Dial("tcp", fmt.Sprintf("%s:%d", "host", 1)) // неправильно
        # _, _ = net.Dial("tcp", net.JoinHostPort("host", "1")) // правильно
        - hostport

        # Report using Go 1.22 enhanced ServeMux patterns in older Go versions.
        # В go 1.22 был добавлен роутинг по методам http.Handle
        # http.Handle("GET /my/method", nil)
        # работает только для версий go 1.21 и ниже
        # проверяет на наличие подобных паттернов, поддержка которых на данных версиях отсутствует
        # для go 1.22+ отключен
        - httpmux

        # Check for mistakes using HTTP responses.
        # resp, err := http.Get("aboba")
        # defer resp.Body.Close() // вызов defer до проверки на ошибку
        # приведет к panic в случае если запрос завершился с ошибкой
        # staticcheck.SA5001 выполняет ту же самую функцию
        # SA5001 помимо покрытия основного кейса так же проверяет все подобные
        # Выключаем
        # - httpresponse

        # Detect impossible interface-to-interface type assertions.
        # Обнаруживает type assertionы которые невозможны
        # если у интерфейса в его методах есть метод Read()
        # то такой интерфейс никак не может имплементировать io.Reader
        # потому что конфликт имет
        # io.Reader Read([]byte) (int, error)
        # myInterface Read()
        # _, _ = myInterface(nil).(io.Reader)
        # staticcheck.SA5010 выполняет ту же функцию, но его (staticcheck) сообщение выглядит более информатино
        # Выключаем
        # - ifaceassert

        # Check references to loop variables from within nested functions.
        # Ранее под переменную в цикле выделялось одно значение
        # указатель на такую переменную мог привести к нежелательному поведению
        # Для go 1.22+ отключен
        - loopclosure

        # Check cancel func returned by context.WithCancel is called.
        # Проверяет вызов cancel() для ctx, cance := context.WithCancel(parentCtx)
        # ctx, _ := context.WithCancel(context.Background()) // значение cancel проигнорировано
        # ctx, cancel := context.WithCancel(context.Background())
        # defer cancel() // по выходу из функции cancel гарантированно будет вызван, одобрено
        - lostcancel

        # Check for useless comparisons between functions and nil.
        # Проверка на то что статичная функция == nil всегда false
        # staticcheck.SA4031 выполняет ту же функцию
        # func foo() {}
        # if foo == nil // всегда false
        # Выключаем
        # - nilfunc

        # Check for redundant or impossible nil comparisons.
        # Распространенные ошибки при работе с nil
        # if x == nil && x.y == 1 {} // x уже nil, дальнейшие обращения могут привести к ошибке
        # достаточно много различных кейсов в том числе известные на этапе компиляции
        # например обращение к пустой мапе до инициализации
        # var storage map[int]int
        # storage[0] = 0
        # Полезно
        - nilness

        # Check consistency of Printf format strings and arguments.
        # Проверяет Printf передачу переменных
        # log.Printf("%s", 1) // %s предназначена для строк, а не для чисел
        # log.Printf("%d", 1) // всё верно
        - printf

        # Check for comparing reflect.Value values with == or reflect.DeepEqual.
        # Запрещает делать != == с типом reflect.Value (отдельно с reflect.Value{} допустимо)
        # Запрещает передавать reflect.Value в reflect.DeepEqual (отдельно с reflect.Value{} допустимо)
        # reflect.DeepEqual(reflect.ValueOf(1), reflect.ValueOf(1)) // запрещено
        # reflect.DeepEqual(a, reflect.ValueOf(1))  // запрещено
        # reflect.DeepEqual(a, reflect.DeepEqual{}) // разрешено
        # Сравнивает значения внутри reflect.Value{} но не их содержимое
        # Везде указывается reflect.ValueOf(a).Interface() как безопасный способ сравнения
        # ОДНАКО
        # Здесь есть проблема сравнения 2 any
        # var a, b any = []int{}, []int{}
        # _ = a == b // вызовет панику
        # Сомнительный
        - reflectvaluecompare

        # Check for possible unintended shadowing of variables.
        # Сообщаят о случаях когда одна переменная затеняет другую
        # что может приводить к неожиданному поведению
        # n := 0
        # if true {
        # 	n := 1 // Затеняет переменную 'n' из внешнего блока
        # 	n++
        # }
        # fmt.Println(n) // Выведет 0, а не 2
        - shadow

        # Check for shifts that equal or exceed the width of the integer.
        # Проверяет распространённые ошибки при использовании сдвигов <<
        # _ = x << 31 // если x принадлежит к типу int16 и ниже сообщит о нарушении
        # staticcheck.SA9006 выполняет ту же функцию
        # однако покрывает больше случаев, например
        # _ = int16(0) << 31 // staticcheck сообщит об ошибке, а shift промолчит
        # Выключаем
        # - shift

        # Check for unbuffered channel of os.Signal.
        # Проверяет что при вызове signal.Notify в него передаётся буферизированный канал
        # Отправитель не будет дожидаться пока получатель обработает входящий сигнал
        # select {
        #   case signalCh <- signal:
        #   default: // в случае если канал будет не буферизированный сигнал не будет отправлен
        # }
        #
        # staticcheck.SA1017 выполняет ту же самую функцию
        - sigchanyzer

        # Check for invalid structured logging calls.
        # Проверяет вызовы slog и slog.Logger
        # slog.Info("msg", "value") // "value" не имеет ключа ОШИБКА
        # loggercheck выполняет ту же самую функцию, однако поддерживает несколько логгеров
        # и кастомные правила для проверки
        # - slog

        # Check the argument type of sort.Slice.
        # проверяет что первый аргумент sort.Slice является слайсом
        # staticcheck.SA1028 выполняет ту же функцию
        # выбор сделан в пользу govet так как название правила именованное
        - sortslice

        # Check signature of methods of well-known interfaces.
        # Проверяет сигнатуры методов популярных интерфейсов
        # func (myMarshaler) MarshalJSON() {} // подскажет имплементацию json.Marshaler
        # имеет некоторый пул "популярных" интерфейсов стандартной библиотеки
        - stdmethods

        # Report uses of too-new standard library symbols.
        # Сообщает о методах стандартной библиотеки которые добавлены
        # в версиях старше нежели используемая в текущем модуле
        # slices.Max() // добавлен в версии go 1.21
        - stdversion

        # Check for string(int) conversions.
        # Прямая конвертация из чисел в string может привести к неожиданному поведению
        # println(string(61)) // выведет '='
        - stringintconv

        # Check that struct field tags conform to reflect.StructTag.Get.
        # 	_ = struct {
        # 	Key string `json:` // ОШИБКА, невалидный синтаксис для тега
        # }{}
        # tagalign выполняет ту же самую функцию, но имеет опции для дополнительной настройки
        # Выключаем
        # - structtag

        # Report calls to (*testing.T).Fatal from goroutines started by a test.
        # go func() {
        # 	t.Fatal() // вызов t.Fatal не из тестовой горутины
        # }()
        #
        # конкурентный/параллельный вызов t.Fatal функций может привести к нежелаемому поведению
        # По скольку t.Fatal под капотом вызывает t.FailNow
        # которая в свою очередь вызывает runtime.Goexit
        # её вызов не из тестовой горутины не приведет к остановке теста
        - testinggoroutine

        # Check for common mistaken usages of tests and examples.
        # нестрогие правила наименования Test, Example, Bench
        # Testhello(*testing.T) // после слова Test не должен идти lowercase символ
        # Test_hello(*testing.T) // OK
        # TestHello(*testing.T) //  OK
        - tests

        # Check for calls of (time.Time).Format or time.Parse with 2006-02-01.
        # Проверяет функции (time.Time).Format или time.Parse на наличие в ней строки 2006-02-01
        # В таком случае при выводе подобной строки месяц поменяется местами с днем
        # В оригинальных константах указан следующий формат: 2006-01-02
        # today 2001-09-11 // верный формат
        # today 2001-11-09 // измененные между собой месяц и день
        - timeformat

        # Report passing non-pointer or non-interface values to unmarshal.
        # _ = json.Unmarshal([]byte{'1'}, 0) // вторым аргументом ожидаем указатель
        # staticcheck.SA1014 выполняет ту же самую функцию
        # выбор сделан в сторону govet из-за именованого названия линтера
        - unmarshal

        # Check for unreachable code.
        # Помечает недосягаемый код
        # return
        # _ = 0 // код недосягаем
        # panic("error")
        # _ = 0 // код недосягаем
        - unreachable

        # Check for invalid conversions of uintptr to unsafe.Pointer.
        # Проверяет возможные случаи некорректной конвертации uintptr в unsafe.Pointer (и не только)
        # _ = unsafe.Pointer(uintptr(0)) // возможная некорректная конвертация
        # _ = unsafe.Pointer(&reflect.SliceHeader{}) // возможна некорректная конвертация
        # дело в том что unsafe.Pointer должен указывать на конкретные места в памяти
        # некорректная конвертация и получения экземпляра unsafe.Pointer
        # могут привести к ошибкам при работе с памятью
        - unsafeptr

        # Check for unused results of calls to some functions.
        #
        # Сообщает об неиспользуемом результате ряда функций стандартной библиотеки
        # вызов таких функций не приводит к изменениям и их вызов может быть убран
        # в случае если значение не используется
        #
        # fmt.Sprint(1) // значение не используется
        # _ = fmt.Sprint(1) // OK, мы присваиваем значение (используем)
        #
        # staticcheck.SA4017 выполняет ту же фукцию
        # Однако в некоторых случаях SA4017 может работать и не только на функции стандартной библиотеки
        #
        # Выключаем
        # - unusedresult

        # Checks for unused writes.
        # Проверяет ряд случаев когда операция записи значения не используется
        # на удивление не конфликтует с wastedassign и ineffassign
        # t := struct{ x, y int }{}
        # t.x = 0 // unusedwrite, далее это значение нигде не используется, присвоение бессмыслено
        - unusedwrite

        # Check for misuses of sync.WaitGroup.
        # Проверяет вызовы (*sync.WaitGroup).Add из новой горутины
        # wg := sync.WaitGroup{}
        # go func() {
        # 	wg.Add(10)
        # }()
        # Не учитывает новое api введённое в go 1.25 (*sync.WaitGroup).Go(func(){})
        # Может привести к неожиданному поведению, создать гонку данных
        # staticcheck.SA2000 выполняет ту же функцию
        # выбор сделан в сторону govet из-за именованого названия линтера
        - waitgroup

    # Для каждого блока есть два правила
    # 1. Разрешает использовать глобальные декларации import, var, const, type только со скобками
    # 2. Запрещаем иметь подобную декларацию больше чем одну на весь файл
    grouper:
      # Require the use of a single global 'const' declaration only.
      # Default: false
      const-require-single-const: true
      # Require the use of grouped global 'const' declarations.
      # Default: false
      const-require-grouping: true

      # Require the use of a single 'import' declaration only.
      # Default: false
      import-require-single-import: true
      # Require the use of grouped 'import' declarations.
      # Default: false
      import-require-grouping: true

      # Require the use of a single global 'type' declaration only.
      # Default: false
      type-require-single-type: true
      # Require the use of grouped global 'type' declarations.
      # Default: false
      type-require-grouping: true

      # Require the use of a single global 'var' declaration only.
      # Default: false
      var-require-single-var: true
      # Require the use of grouped global 'var' declarations.
      # Default: false
      var-require-grouping: true

    iface:
      # List of analyzers.
      # Default: ["identical"]
      enable:
        # Включено по умолчанию, проверяем идентичные сингнатуры методов и набор этих методов
        # среди интерфейсов одного пакета
        - identical # Identifies interfaces in the same package that have identical method sets.

        # сообщает о том что интерфейс нигде не используется
        # unused выполняет ту же самую фукнцию
        # Выключаем
        # - unused # Identifies interfaces that are not used anywhere in the same package where the interface is defined.

        # Обнаруживает функции которые возвращают интерфейс
        # при этом фактически они возвращают одну и ту же имплементацию
        # Много false positive
        # Выключаем
        # - opaque # Identifies functions that return interfaces, but the actual returned value is always a single concrete implementation.

        # Запрещает выставлять наружу неэкспортируемые интерфейсы
        # func NewInterface() myInterface // myInterface приватен, однако выставляется наружу публичной функцией
        - unexported # Identifies interfaces that are not exported but are used in exported functions or methods.

      # settings:
      #   unused:
      #     exclude: []

    importas:
      # Do not allow unaliased imports of aliased packages.
      # Default: false
      no-unaliased: false
      # Do not allow non-required aliases.
      # Default: false
      no-extra-aliases: false
      # List of aliases
      # Default: []
      alias: []
        # # Using `servingv1` alias for `knative.dev/serving/pkg/apis/serving/v1` package.
        # - pkg: knative.dev/serving/pkg/apis/serving/v1
        #   alias: servingv1
        # # Using `autoscalingv1alpha1` alias for `knative.dev/serving/pkg/apis/autoscaling/v1alpha1` package.
        # - pkg: knative.dev/serving/pkg/apis/autoscaling/v1alpha1
        #   alias: autoscalingv1alpha1
        # # You can specify the package path by regular expression,
        # # and alias by regular expression expansion syntax like below.
        # # See https://github.com/julz/importas#use-regular-expression for details.
        # - pkg: knative.dev/serving/pkg/apis/(\w+)/(v[\w\d]+)
        #   alias: $1$2
        # # An explicit empty alias can be used to ensure no aliases are used for a package.
        # # This can be useful if `no-extra-aliases: true` doesn't fit your need.
        # # Multiple packages can use an empty alias.
        # - pkg: errors
        #   alias: ""

    ireturn:
      # List of interfaces to allow.
      # Lists of the keywords and regular expressions matched to interface or package names can be used.
      # `allow` and `reject` settings cannot be used at the same time.
      #
      # Keywords:
      # - `empty` for `interface{}`
      # - `error` for errors
      # - `stdlib` for standard library
      # - `anon` for anonymous interfaces
      # - `generic` for generic interfaces added in go 1.18
      #
      # Default: [anon, error, empty, stdlib]
      allow:
        # func NewAnon() interface{ Anon() } { return nil }
        - anon

        # func NewError() error              { return nil }
        - error

        # func NewInterface() interface{}    { return nil }
        # func NewAny() any                  { return nil }
        - empty

        # func NewReader() io.Reader         { return nil }
        - stdlib

        # все интерфейсы которые заканчиваются на Service допустимы
        - Service$

        # Допустимо возвращать спаны
        - Span$

        # You can specify idiomatic endings for interface
        # - (or|er)$

      # List of interfaces to reject.
      # Lists of the keywords and regular expressions matched to interface or package names can be used.
      # `allow` and `reject` settings cannot be used at the same time.
      #
      # Keywords:
      # - `empty` for `interface{}`
      # - `error` for errors
      # - `stdlib` for standard library
      # - `anon` for anonymous interfaces
      # - `generic` for generic interfaces added in go 1.18
      #
      # Default: []
      # reject:
      # - github.com\/user\/package\/v4\.Type

    lll:
      # Max line length, lines longer will be reported.
      # '\t' is counted as 1 character by default, and can be changed with the tab-width option.
      # Default: 120.
      line-length: 100
      # Tab width in spaces.
      # Default: 1
      # Табы считаются от начала строки включительно
      tab-width: 4

    loggercheck:
      # Allow check for the github.com/go-kit/log library.
      # Default: true
      kitlog: true
      # Allow check for the k8s.io/klog/v2 library.
      # Default: true
      klog: true
      # Allow check for the github.com/go-logr/logr library.
      # Default: true
      logr: true
      # Allow check for the log/slog library.
      # Default: true
      slog: true
      # Allow check for the "sugar logger" from go.uber.org/zap library.
      # Default: true
      zap: true
      # Require all logging keys to be inlined constant strings.
      # Default: false
      # Обязывает использовать строку как ключ
      require-string-key: true
      # Require printf-like format specifier (%s, %d for example) not present.
      # Default: false
      # Запрещает использовать printf pattern в функциях логирования
      no-printf-like: true

      # List of custom rules to check against, where each rule is a single logger pattern, useful for wrapped loggers.
      # For example: https://github.com/timonwong/loggercheck/blob/7395ab86595781e33f7afba27ad7b55e6956ebcd/testdata/custom-rules.txt
      # Default: empty
      rules:
        - k8s.io/klog/v2.InfoS # package level exported functions
        - (github.com/go-logr/logr.Logger).Error # "Methods"
        - (*go.uber.org/zap.SugaredLogger).With # Also "Methods", but with a pointer receiver

    misspell:
      # Correct spellings using locale preferences for US or UK.
      # Setting locale to US will correct the British spelling of 'colour' to 'color'.
      # Default is to use a neutral variety of English.
      locale: US

      # Typos to ignore.
      # Should be in lower case.
      # Default: []
      ignore-rules: []

      # Extra word corrections.
      # `typo` and `correction` should only contain letters.
      # The words are case-insensitive.
      # Default: []
      extra-words:
        - typo: "iff"
          correction: "if"
        - typo: "cancelation"
          correction: "cancellation"

      # Mode of the analysis:
      # - default: checks all the file content.
      # - restricted: checks only comments.
      # Default: ""
      mode: default

    mnd:
      # List of enabled checks, see https://github.com/tommy-muehle/go-mnd/#checks for description.
      # Default: ["argument", "case", "condition", "operation", "return", "assign"]
      checks:
        # Аргументы фукнций
        # t := http.StatusText(200)
        - argument

        # Присвоения переменных
        # c := &http.Client{
        #     Timeout: 5 * time.Second,
        # }
        - assign

        # switch case
        # switch x {
        #     case 3:
        # }
        - case

        # Условия
        # if x > 7 {}
        - condition

        # Базовые математические операции
        # var x, y int
        # y = 10 * x
        - operation

        # Возвращения значений из функций
        # return 3
        - return

      # List of numbers to exclude from analysis.
      # The numbers should be written as string.
      # Values always ignored: "1", "1.0", "0" and "0.0".
      # Default: []
      ignored-numbers: []
        # Разрешения файлов
        # - "0o600"
        # смысл всего не может быть левым числом
        # - "42"
      # List of file patterns to exclude from analysis.
      # Values always ignored: `.+_test.go`.
      # Default: []
      ignored-files:
        - 'magic1_.+\.go$'
      # List of function patterns to exclude from analysis.
      # Following functions are always ignored: `time.Date`,
      # `strconv.FormatInt`, `strconv.FormatUint`, `strconv.FormatFloat`,
      # `strconv.ParseInt`, `strconv.ParseUint`, `strconv.ParseFloat`.
      # Default: []
      ignored-functions:
        - '^math\.'
        - '^http\.StatusText$'

    modernize:
      # List of analyzers to disable.
      # By default, all analyzers are enabled.
      disable:
        # Replace interface{} with any.
        # Банит interface{} в вашем проекте
        # - any

        # Replace for-range over b.N with b.Loop.
        # Если находится вне функции Benchmark(b *testing.B) не будет срабатывать
        # Что очень странно, встроенных gopls отрабатывает штатно на все случаи
        # - bloop

        # Replace []byte(fmt.Sprintf) with fmt.Appendf.
        # До
        # _ = []byte(fmt.Sprintf("My digit: %d", 1))
        # После
        # _ = fmt.Appendf(make([]byte, 0), "My digit: %d", 1)
        # - fmtappendf

        # Remove redundant re-declaration of loop variables.
        # for i := range 100 {
        #    i := i // после 1.22 не имеет смысла
        # }
        # Начиная с go 1.22 под каждую i перменную выделяется место на стеке
        # - forvar

        # Replace explicit loops over maps with calls to maps package.
        # Содержит ряд случаев которые должны быть заменены на функции пакета maps
        # for key, value := range storage {
        # 	dest[key] = value // должно быть заменено на maps.Copy(dest, storage)
        # }
        # for i, v := range newIter() {
        # 	storage[i] = v // должно быть заменено на storage := maps.Collect(slices.Backward(digits))
        # }
        # - mapsloop

        # Replace if/else statements with calls to min or max.
        # Отслеживает случаи if else которые можно заменить на встроенные функции min max
        # Если вы напишите свою реализацию min, max ругаться не будет, а должен
        # if a < b { можно заменить на x := min(a, b)
        #   x = a
        # } else {
        # 	x = b
        # }
        #
        #
        # if x < y { // не поругается
        # 	return x
        # }
        #
        # return y
        # - minmax

        # Simplify code by using go1.26's new(expr).
        # Начиная с go 1.26 мы можем получать указатель
        # на переменную в одну строчку передавая её как аргумент встроенной
        # функции new() в которую ранее можно было лишь передать тип (как generic)
        # До 1.26 нам приходилось писать свои функции
        # func varOf(x int) *int { return &x }
        # Теперь мы просто используем new
        # ptrToInt := new(x)
        # - newexpr

        # Suggest replacing omitempty with omitzero for struct fields.
        # До
        # Me Me `json:"me,omitempty"`
        # После
        # Me Me `json:"me,omitzero"`
        # omitzero опустит поле при нулевом значении поля, omitempty работает с указателями
        # - omitzero

        # Replace 3-clause for loops with for-range over integers.
        # for i := 0; i < 1100; i++ {} // старый синтаксис, неправильно
        # for i := range 1100 // новой синтаксис, идиоматично
        # - rangeint

        # Replace reflect.TypeOf(x) with TypeFor[T]().
        # До
        # Необходимо добавлять переменную которая нам не нужна
        # intType := reflect.TypeOf(int(0))
        # После
        # Избавляет нас от заботы создавать переменные для получения типа
        # intType := reflect.TypeFor[int]()
        # - reflecttypefor

        # Replace loops with slices.Contains or slices.ContainsFunc.
        # До
        #
        # for _, digit := range digits {
        # 	if digit == i {
        # 		return true
        # 	}
        # }
        #
        # return false
        #
        # После
        # return slices.Contains(digits, i)
        # - slicescontains

        # Replace sort.Slice with slices.Sort for basic types.
        # words := make([]string, 0)
        # До
        # sort.Slice(words, func(i, j int) bool { return words[i] < words[j] })
        # После
        # slices.Sort(words)
        #
        # На следующий пример не реагирует
        # sort.Slice(words, cmp.Less) // НЕ БУДЕТ сообщения перейти на slices.Sort
        # - slicessort

        # Use iterators instead of Len/At-style APIs.
        # В пакете types есть ряд структур у которых
        # после обновления go 1.23 появились методы
        # возвращающие итераторы, и теперь это более идиометичный
        # способ итерации по ним
        # x := types.TypeList{}
        #
        # До
        # for i := 0; i < x.Len(); i++ {
        # 	_ = x.At(i)
        # }
        #
        # После
        #
        # x.Types() возвращает итератор
        # что позволяет избежать дополнительного вызова At(index)
        # for elem := range x.Types() {
        # 	_ = elem
        # }
        # - stditerators

        # Replace HasPrefix/TrimPrefix with CutPrefix.
        # До
        # if strings.HasPrefix(name, "2004 ") {
        # 	name = strings.TrimPrefix(name, "2004 ")
        # }
        #
        # После
        # if after, ok := strings.CutPrefix(s, prefix); ok {
        #   name = after
        # }
        # - stringscutprefix

        # Replace ranging over Split/Fields with SplitSeq/FieldsSeq.
        #
        # До
        # for range strings.Split(name, " ")
        # После
        # for range strings.SplitSeq(name, " ")
        #
        # Тоже самое и для Fields и FieldsSeq
        #
        # Так мы не аллоцируем новый список, а итерируемся по исходной строке
        # - stringsseq

        # Replace += with strings.Builder.
        # В случае повторяющихся конкатенаций предлагает заменить
        # строку на strings.Builder
        # Работает только на циклы
        #
        # До
        #	for _, ch := range stringslice {
        # 	name += "char"
        # }
        #
        # После
        # for _, ch := range stringslice {
        #   name.WriteString(ch)
        # }
        #
        # perfsprint.concat-loop выполняет ту же самую фукнцию
        # Однако функционал гораздо шире и работает на любые циклы и даже операции
        #
        - stringsbuilder

        # Replace context.WithCancel with t.Context in tests.
        # Начиная с версии go 1.24 у нас появился метод t.Context()
        #
        # До
        #	ctx, cancel := context.WithCancel(context.Background())
        # После
        # ctx := t.Context()
        #
        # Не работает если функция cancel() используется хоть как-то
        # кроме defer cancel()
        # даже _ = cancel отключит проверку
        # t.Cleanup(cancel) вместо defer тоже не будет отловлено
        # - testingcontext

        # Replace wg.Add(1)/go/wg.Done() with wg.Go.
        # Меняет устаревший шаблон работы с sync.WaitGroup
        # на более лаконичный и безопасный
        # под капотом wg.Go() делает то же самое что
        # и wg.Add(1) go func() { defer wg.Done() }
        # До
        #
        #	for range 100 {
        # 	wg.Add(1)
        #
        # 	go func() {
        # 		defer wg.Done()
        #
        # 	}()
        # }
        #
        # После
        #
        #	for range 100 {
        # 	wg.Go(func() {})
        # }
        # - waitgroup

    musttag:
      # A set of custom functions to check in addition to the builtin ones.
      # Default: json, xml, gopkg.in/yaml.v3, BurntSushi/toml, mitchellh/mapstructure, jmoiron/sqlx
      functions:
        # The full name of the function, including the package.
        - name: github.com/hashicorp/hcl/v2/hclsimple.DecodeFile
          # The struct tag whose presence should be ensured.
          tag: hcl
          # The position of the argument to check.
          arg-pos: 2

    nilnil:
      # To check functions with only two return values (`return nil, nil`).
      # If disabled then returns like `return nil, nil, ..., nil` are supported.
      # Default: true
      # Для работы с несколькими аргументами
      # Если включено то в случае если хотя бы один аргумент nil
      only-two: false

      # In addition, detect opposite situation (simultaneous return of non-nil error and valid value).
      # E.g, `return clone, fh.indexer.Update(clone)` will be considered as invalid.
      # Default: false
      # Обнаруживает обратные ситуации, когда мы возвращает not nil значение с ошибкой
      detect-opposite: true
      # List of return types to check.
      # Default: ["chan", "func", "iface", "map", "ptr", "uintptr", "unsafeptr"]

      checked-types:
        - chan
        - func
        - iface
        - map
        - ptr
        - uintptr
        - unsafeptr

    nolintlint:
      # Disable to ensure that all nolint directives actually have an effect.
      # Если линтер и так не срабатывает то выключаем его
      # Default: false
      allow-unused: false
      # Exclude following linters from requiring an explanation.
      # Позволяет опускать объяснение для некоторых линтеров
      # Default: []
      allow-no-explanation: []

      # Enable to require an explanation of nonzero length after each nolint directive.
      # Обязывает объяснять рядом в комментарии почему этот линтер выключен
      #
      # //nolint // Пусть будет
      # func myUnusedFunc() {}
      #
      # Default: false
      require-explanation: true

      # Enable to require nolint directives to mention the specific linter being suppressed.
      # Обязывает указывать линтеры которые необходимо выключить в nolint директиве
      # //nolint // Вызовет ошибку по причине отсутствия конкретных линтеров
      # func myUnusedFunc() {}
      # Default: false
      require-specific: true

    perfsprint:
      # Enable/disable optimization of integer formatting.
      # До
      # _ = fmt.Sprint(1)
      # После
      # _ = strconv.Itoa(1)
      # Default: true
      integer-format: true

      # Optimizes even if it requires an int or uint type cast.
      # Расширяет предыдущий базовыми числовыми типами (u)int8, (u)int16, (u)int32
      # Именно расширяет, если предыдущий выключен то этот линтер не будет работать
      # Default: true
      int-conversion: true

      # Enable/disable optimization of error formatting.
      # Является переключателем для линтеров err-error и errorf
      # Без него линтеры работать не будут
      # Default: true
      error-format: true

      # Optimizes into `err.Error()` even if it is only equivalent for non-nil errors.
      #
      # Сообщает о возможных упрощениях fmt.Sprint(io.ErrUnexpectedEOF) до io.ErrUnexpectedEOF.Error()
      #
      # Default: false
      err-error: true

      # Optimizes `fmt.Errorf`.
      # Default: true
      # Указывает на замену fmt.Errorf("error message") на errors.New("error message")
      #
      # revive.use-errors-new и unnecessary-format выполняют ту же самую фукнцию
      #
      # Выключаем
      errorf: false

      # Enable/disable optimization of string formatting.
      #
      # Является переключателем для линтеров sprint1 и strconcat
      # Без него линтеры работать не будут
      #
      # До
      # _ = fmt.Sprint("format")
      # После
      # _ = "format"
      #
      # gocritic.redundantSprint выполняет ту же самую фукнцию
      #
      # Однако распространяется и на fmt.Stringer
      #
      # Выключаем так как ни один из линтеров (perfsprint.string-format, perfsprint.sprintf, perfsprint.strconcat) строк нам не нужен
      #
      # И функционал данных линтеров может быть замещен более
      # фукнциональными альтернативами
      #
      # Default: true
      string-format: false

      # Optimizes `fmt.Sprintf` with only one argument.
      # До
      # _ = fmt.Sprintf("format") // один аргумент в качестве формата
      # После
      # _ = "format"
      #
      # revive.unnecessary-format выполняет ту же самую функцию
      #
      # Выключаем
      # Default: true
      sprintf1: false

      # Optimizes into strings concatenation.
      # Оптимизирует случаи когда строка формат заканчивается на  %s
      # До
      # _ = fmt.Sprintf("format %s", name)
      # После
      # _ = "format " + name
      #
      # Работает только если аргумент является строкой
      # На error, fmt.Striger не распространяется
      # Отчасти он полезен, однако
      # Я вынужден оставить включенным string-format
      # Хотя он дублирует функционал некоторых уже существующих линтеров
      # И этот линтер вынуждает нас конкатенировать строки
      # Хотя в дальнейшем нам опять может понадобится fmt.Sprintf
      # И нам опять придётся переписывать с конкатенации на форматирование
      #
      # Default: true
      strconcat: false

      # Enable/disable optimization of bool formatting.
      # До
      # _ = fmt.Sprintf("%v", true)
      # _ = fmt.Sprintf("%t", true)
      # _ = fmt.Sprint(true)
      # После
      # _ = strconv.FormatBool(true)
      # Default: true
      bool-format: true

      # Enable/disable optimization of hex formatting.
      # До
      # _ = fmt.Sprintf("%x", make([]byte, 0))
      # После
      # _ = hex.EncodeToString(make([]byte, 0))
      # Default: true
      hex-format: true

      # Enable/disable optimization of concat loop.
      # До
      #	result := "string"
      # for range 100 {
      # 	result += "string"
      # }
      # После
      # result := new(strings.Builder)
      # result.WriteString("string")
      # for range 100 {
      #   result.WriteString("string")
      # }
      # Есть такое ощущение будто линтер специально создан
      # неполноценным чтобы добавить опций
      # как будто это платное DLC
      # ВСЕГДА если используете включайте loop-other-ops
      # Default: true
      concat-loop: true

      # Optimization of `concat-loop` even with other operations.
      # Улучшает линтер concat-loop расширяя набор обнаруживаемых случаев
      # s := "string"
      # for range 10 {
      # 	s += "y" // concat-loop это не обнаружит без данной опции
      # 	if len(s)%3 == 1 {
      # 		s += "," // concat-loop это не обнаружит без данной опции
      # 	}
      # }
      # Default: false
      loop-other-ops: true

    prealloc:
      # IMPORTANT: we don't recommend using this linter before doing performance profiling.
      # For most programs usage of prealloc will be a premature optimization.
      # Report pre-allocation suggestions only on simple loops that have no returns/breaks/continues/gotos in them.
      # Default: true
      simple: true

      # Report pre-allocation suggestions on range loops.
      # Default: true
      range-loops: true

      # Report pre-allocation suggestions on for loops.
      # Default: false
      for-loops: true

    predeclared:
      # List of predeclared identifiers to not report on.
      # Default: []
      ignore: []
      # Include method names and field names in checks.
      # Default: false
      qualified-name: true

    promlinter:
      # Promlinter cannot infer all metrics name in static analysis.
      # Enable strict mode will also include the errors caused by failing to parse the args.
      # Default: false
      strict: true

      # Please refer to https://github.com/yeya24/promlinter#usage for detailed usage.
      # Default: []
      disabled-linters: []
        # Help detects issues related to the help text for a metric.
        # Сообщает о случаях когда поле Help пропущено в ряде структур
        # До
        # _ = prometheus.NewCounterVec(
        #   prometheus.CounterOpts{
        #   	Name: "test_metric_name",
        #   },
        #   []string(nil),
        # )
        #
        # После
        # _ = prometheus.NewCounterVec(
        # 	prometheus.CounterOpts{
        # 		Name: "test_metric_name",
        # 		Help: "test metric help text",
        # 	},
        # 	[]string(nil),
        # )
        # - Help

        # MetricUnits detects issues with metric unit names.
        # Указывает на смысловые ошибки в именовании метрик
        # Работает c
        # milliseconds -> seconds
        # kilobytes -> bytes
        # И так далее
        # Если вы допустите орфографическую ошибку линтер не сработает
        # До
        # _ = prometheus.NewGauge(
        # 	prometheus.GaugeOpts{
        # 		Name: "http_request_duration_milliseconds", // указано в миллисекундах
        # 		Help: "http request duration in milliseconds",
        # 	},
        # )
        # После
        # _ = prometheus.NewGauge(
        # 	prometheus.GaugeOpts{
        # 		Name: "http_request_duration_seconds", // теперь все верно, должно быть указано в секундах
        # 		Help: "http request duration in seconds",
        # 	},
        # )
        # - MetricUnits

        # Counter detects issues specific to counters, as well as patterns that should only be used with counters.
        # Сообщает о типичных ошибках связанных с метриками-счетчиками
        # // ❌ Отсутствует суффикс _total
        # _ = prometheus.NewCounter(prometheus.CounterOpts{
        # 	Name: "http_requests",
        # 	Help: "Total number of HTTP requests",
        # })
        # // ❌ Неправильный тип для счетчика
        # _ = prometheus.NewGauge(prometheus.GaugeOpts{
        # 	Name: "login_attempts_total", // Имя подходит для счетчика, но тип - gauge
        # 	Help: "Total login attempts",
        # })
        # // ✅ Правильный вариант
        # _ = prometheus.NewCounter(prometheus.CounterOpts{
        # 	Name: "http_requests_total",
        # 	Help: "Total number of HTTP requests",
        # })
        # - Counter

        # HistogramSummaryReserved detects when other types of metrics use names or labels reserved for use by histograms and/or summaries.
        # Обнаруживает использование зарезервированных имен не-гистограммами/не-суммариями
        # // ❌ Гистограмма использует метку 'le' в не-гистограмме
        # _ = prometheus.NewCounterVec(prometheus.CounterOpts{
        # 	Name: "http_request_duration_seconds_total",
        # 	Help: "HTTP request duration",
        # }, []string{"le"}) // 'le' зарезервирована для гистограмм
        #
        # // ❌ Суммари использует метку 'quantile' в не-суммари
        # _ = prometheus.NewGaugeVec(prometheus.GaugeOpts{
        # 	Name: "response_time_seconds",
        # 	Help: "Response time",
        # }, []string{"quantile"}) // 'quantile' зарезервирована для суммарий
        #
        # // ✅ Правильный вариант
        # _ = prometheus.NewHistogramVec(prometheus.HistogramOpts{
        # 	Name: "http_request_duration_seconds",
        # 	Help: "HTTP request duration",
        # }, []string{"le"})
        #
        # _ = prometheus.NewGaugeVec(prometheus.GaugeOpts{
        # 	Name: "response_time_seconds",
        # 	Help: "Response time",
        # }, []string{"status"})
        # - HistogramSummaryReserved

        # MetricTypeInName detects when metric types are included in the metric name.
        # Сообщает о случаях когда тип метрики (counter, gauge) включено в название метрики
        # В случае допуска орфографических ошибок couner, gage не будет работать
        # // ❌ Тип метрики (counter) в имени
        # prometheus.NewCounter(prometheus.CounterOpts{
        # 	Name: "http_requests_counter_total",
        # 	Help: "HTTP requests",
        # })
        # // ❌ Тип метрики (gauge) в имени
        # prometheus.NewGauge(prometheus.GaugeOpts{
        # 	Name: "temperature_gauge_celsius",
        # 	Help: "Temperature",
        # })
        # // ✅ Правильный вариант
        # prometheus.NewCounter(prometheus.CounterOpts{
        # 	Name: "http_requests_total",
        # 	Help: "HTTP requests",
        # })
        #
        # prometheus.NewGauge(prometheus.GaugeOpts{
        # 	Name: "temperature_celsius",
        # 	Help: "Temperature",
        # })
        # - MetricTypeInName

        # ReservedChars detects colons in metric names.
        # Сообщает о двоеточии в имени метрик
        # // ❌ Двоеточие в имени
        # prometheus.NewCounter(prometheus.CounterOpts{
        # 	Name: "app:http_requests_total",
        # 	Help: "HTTP requests",
        # })
        #
        # // ✅ Правильный вариант
        # prometheus.NewCounter(prometheus.CounterOpts{
        # 	Name: "app_http_requests_total",
        # 	Help: "HTTP requests",
        # })
        # - ReservedChars

        # CamelCase detects metric names and label names written in camelCase.
        # Обнаруживает название метрик которое записано в формате camelCase
        #
        # // ❌ CamelCase в имени метрики
        # prometheus.NewCounter(prometheus.CounterOpts{
        # 	Name: "httpRequestsTotal_total",
        # 	Help: "HTTP requests",
        # })
        #
        # // ❌ CamelCase в метках
        # prometheus.NewCounterVec(prometheus.CounterOpts{
        # 	Name: "http_requests_total",
        # 	Help: "HTTP requests",
        # }, []string{"statusCode", "userAgent"})
        #
        # // ✅ Правильный вариант
        # prometheus.NewCounter(prometheus.CounterOpts{
        # 	Name: "http_requests_total",
        # 	Help: "HTTP requests",
        # })
        #
        # prometheus.NewCounterVec(prometheus.CounterOpts{
        # 	Name: "http_requests_total",
        # 	Help: "HTTP requests",
        # }, []string{"status_code", "user_agent"})
        # - CamelCase

        # UnitAbbreviations detects abbreviated units in the metric name.
        # Запрещает наличие аббревиатур в названиях метрик
        # Если у вас включено MetricUnits то это правило включено по умолчанию
        # Сильно пересекается с MetricUnits
        # // ❌ Сокращенные единицы
        # prometheus.NewGauge(prometheus.GaugeOpts{
        # 	Name: "response_time_ms",
        # 	Help: "Response time in milliseconds",
        # })
        #
        # // ❌ Нестандартные сокращения
        # prometheus.NewCounter(prometheus.CounterOpts{
        # 	Name: "data_transferred_mb_total",
        # 	Help: "Data transferred",
        # })
        #
        # // ✅ Правильный вариант
        # prometheus.NewGauge(prometheus.GaugeOpts{
        # 	Name: "response_time_seconds",
        # 	Help: "Response time in seconds",
        # })
        #
        # prometheus.NewCounter(prometheus.CounterOpts{
        # 	Name: "data_transferred_bytes_total",
        # 	Help: "Data transferred in bytes",
        # })
        # - UnitAbbreviations

    protogetter:
      # Skip files generated by specified generators from the checking.
      # Checks only the file's initial comment, which must follow the format: "// Code generated by <generator-name>".
      # Files generated by protoc-gen-go, protoc-gen-go-grpc, and protoc-gen-grpc-gateway are always excluded automatically.
      # Default: []
      skip-generated-by: []
      # Skip files matching the specified glob pattern from the checking.
      # Default: []
      skip-files:
        - "*.pb.go"
      # Skip any generated files from the checking.
      # Default: false
      skip-any-generated: true
      # Skip first argument of append function.
      # Default: false
      replace-first-arg-in-append: false

    recvcheck:
      # Disables the built-in method exclusions:
      # - `MarshalText`
      # - `MarshalJSON`
      # - `MarshalYAML`
      # - `MarshalXML`
      # - `MarshalBinary`
      # - `GobEncode`
      # Default: false
      #
      # Методы стандартной библиотеки которые исключаются из проверок
      #
      # type Human struct{}
      #
      # func (Human) Hello()                        {}
      # func (Human) Bye()                          {}
      #
      # по скольку метод MarshalJSON является исключением он не учитывается
      # и линтер не будет реагировать на подобный код
      # func (*Human) MarshalJSON() ([]byte, error) { return []byte{}, nil }
      disable-builtin: false

      # User-defined method exclusions.
      # The format is `struct_name.method_name` (ex: `Foo.MethodName`).
      # A wildcard `*` can use as a struct name (ex: `*.MethodName`).
      # Default: []
      # func (Human) Hello()                          {}
      # func (Human) Bye()                            {}
      # func (*Human) MarshalJSON() ([]byte, error)   { return []byte{}, nil }
      # func (*Human) UnmarshalJSON([]byte) error     { return nil }
      # func (*Human) UnmarshalYAML() ([]byte, error) { return []byte{}, nil }
      # func (*Human) UnmarshalText([]byte) error     { return nil }
      # func (*Human) Scan(any) error                 { return nil }
      exclusions:
        - "*.Scan"
        - "*.UnmarshalJSON"
        - "*.UnmarshalText"
        - "*.UnmarshalYAML"

    revive:
      # Maximum number of open files at the same time.
      # See https://github.com/mgechev/revive#command-line-flags
      # Defaults to unlimited.
      # Для golangci-lint бесполезно
      # max-open-files: 2048

      # Sets the default severity.
      # Позволяет настроить какие линтеры считаются достаточным основанием для ошибки
      # Выглядит как нестрогий запрет
      # А любой нестрогий запрет равносилен отсуствию это запрета
      #
      # Очень странно работает в сочетании с golangci-lint, на отдельные линтеры может не работать
      # Не получилось проверить с add-constant
      #
      # Отключаем
      # See https://github.com/mgechev/revive#configuration
      # Default: warning
      # severity: error

      # Enable all available rules.
      # Default: false
      # enable-all-rules: true
      # Enable validation of comment directives.
      # See https://github.com/mgechev/revive#comment-directives
      # directives:
      #   - name: specify-disable-reason
      #     severity: error
      #
      # Sets the default failure confidence.
      # This means that linting errors with less than 0.8 confidence will be ignored.
      # Default: 0.8
      # Не ставьте на 0 иначе посчитает как отсутствие значения
      confidence: 0.01
      #
      # Revive handles the default rules in a way that can be unexpected:
      # - If there are no explicit rules, the default rules are used.
      # - If there is at least one explicit rule, the default rules are not used.
      # Run `GL_DEBUG=revive golangci-lint run --enable-only=revive` to see default, all available rules, and enabled rules.
      #
      rules:
        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#add-constant
        # Проверяет "магические" значения строк и чисел которые необходимо заменить на константы
        - name: add-constant
          disabled: false
          exclude: ["TEST"]
          arguments:
            # max-lit-count - максимальное количество раз которое строка может встречаться в коде,
            # после превышения которого линтер сообщит и необходимости создания константы под эту строку
            # 1 - означает что одинаковая статичная строка может использоваться только один раз
            # если она встречается 2 и более раз, линтер сообщит об этом
            - max-lit-count: "1"
              # whitelist для предыдущего линтера
              allow-strs: '""'

              # Разрешенные значения для чисел
              allow-ints: "0,1"
              allow-floats: "0.0,1.0"
              # список функций разделенных запятой, для которых следует игнорировать правила линтера
              ignore-funcs: WriteHeader,
                http.NewRequest,
                http.NewRequestWithContext,
                http.Error,
                http.StatusText,
                http.Redirect,
                http.RedirectHandler,
                httptest.NewRequest,
                syslog.New,
                syslog.Dial,
                syslog.NewLogger,
                time.Date,
                slog.*,
                log.*,
                logger.*,
                fmt\.(?:Printf|Sprintf|Fprintf|Scanf|Fscanf|Sscanf)$

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#argument-limit
        # Устанавливает максимально допустимое количество аргументов в функции
        # Интересно то что на неименованые аргументы не работает
        # func bar(_ int, _ string, _ rune, _ byte, _ uint8) {} // линтер укажет на проблему
        # func bar(int, string, rune, byte, uint8) {} // линтер промолчит
        - name: argument-limit
          disabled: false
          exclude: [""]
          arguments: [4]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#atomic
        # Проверяет типичные ошибки при работе с atomic
        # var counter int32
        # counter = atomic.AddInt32(&counter, 1) // присваиваем новое значение той же переменной
        #
        # govet.atomic выполняет ту же самую функцию
        # Выключаем
        - name: atomic
          disabled: true
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#banned-characters
        # Позволяет указать набор символов запрещенный в названиях переменных, функций, деклараций типов
        # revive.asciicheck запрещает любые non-ascii символы в коде, этого более чем достаточно
        # revive.asciicheck выполняет ту же самую фукнцию
        # Выключаем
        - name: banned-characters
          disabled: true
          exclude: [""]
          arguments: [] # Запрещенные символы

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#bare-return
        # Запрещает использование "пустых" return в случае именованных возвращаемых переменных
        #
        # func bare() (age int, err error) {
        # 	return // return здесь "молчаливо" возвращает значения age и err
        # }
        #
        # Добавляет ясности и читаемости к коду
        - name: bare-return
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#blank-imports
        # Регулирует использование blank импортов (import _ "embed")
        # Пустой импорт может находится в main пакетах
        # Пустой импорт может находится в test пакетах (файлы _test.go или _test пакет)
        # Иначе необходимо написать комментарий почему данный импорт необходим в коде
        - name: blank-imports
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#bool-literal-in-expr
        # Обнаруживает участки кода где условие сравнивается с true или false
        #
        # До
        # if condition == true {
        # 	log.Println("Hello World!")
        # }
        #
        # После
        # if condition {
        #   log.Println("Hello World!")
        # }
        - name: bool-literal-in-expr
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#call-to-gc
        # Запрещает прямое обращение к сборщику мусора
        # runtime.GC() // ЗАПРЕЩЕНО
        - name: call-to-gc
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#cognitive-complexity
        # Считает когнитивную сложность функций
        # После дополнительного аудита был сделан выбор в пользу gocognit
        # gocognit выполняет ту же самую фукнцию
        # Аудит в конце файла
        # Выключаем
        - name: cognitive-complexity
          disabled: true
          exclude: [""]
          arguments: [10]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#comment-spacings
        # Обнаруживает комментарии без пробела после //
        # Исправляется go fmt
        - name: comment-spacings
          disabled: false
          exclude: [""]
          arguments: []

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#comments-density
        # Cчитает концентрацию комментариев на строку кода
        # Агументом является желаемый процент комментариев относительно количества строк кода
        #
        # 10 строк комментариев на 100 строк кода = 10%
        #
        # Чем больше объем комментариев тем тяжелее будет поддерживать истинность комментариев
        # Может привести к появлению достаточно большого количества ложных (обманчивых) комментариев
        #
        # Выключаем
        - name: comments-density
          disabled: true
          exclude: [""]
          arguments: [110]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#confusing-naming
        # Обнаруживает поля структур с названиями отличающимися только заглавностью букв
        #
        # type Confusing struct {
        # 	Field string // существует точно такое же поле field которое отличается лишь заглавность первой буквы
        # 	field int
        # }
        #
        - name: confusing-naming
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#confusing-results
        #
        # В случае если мы возвращаем два агумента среди которых нет последней error мы обязаны их назвать
        # func manyResults() (int, int) { return 0, 0 } // в таком случае обязаны назвать результаты функции
        # func manyResults() (x, y int) { return 0, 0 } // Всё верно
        #
        # gocritic.unnamedResult выполняет ту же самую функцию
        #
        - name: confusing-results
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#constant-logical-expr
        #
        # Сообщает о bool значениях известных в на этапе компиляции
        #
        # if 1 == 1 { do() }
        #
        # gocritic.dupSubExpr выполняет ту же самую функцию
        # staticcheck.SA4000  выполняет ту же самую фукнцию
        #
        - name: constant-logical-expr
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#context-as-argument
        # Проверяет что контекст является первым аргументом функции
        # func doContext(i int, ctx context.Context) {} // ПЛОХО сtx является вторым аргументов после i int
        # func doContext(ctx context.Context, i int) {} // ХОРОШО ctx является первым аргументом
        #
        # Позволяет добавить настройку для аргументов которым разрешено идти перед context.Context
        # func doContext(t *testing.T, ctx context.Context) {} // ХОРОШО
        - name: context-as-argument
          disabled: false
          exclude: [""]
          arguments:
            - allow-types-before: "*testing.T"

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#context-keys-type
        #
        # Запрещает использовать обычные значения как ключи в context.WithValue
        # ctx = context.WithValue(ctx, "key", "value") // неверно
        #
        # type valueKey struct{}
        # ctx = context.WithValue(ctx, valueKey{}, "value") // верно
        #
        # Это обусловлено тем что для отдельного типа пустой структуры
        # мы сравниваем лишь данные рефлексии для типа
        # а для строк нам необходимо будет сравнить ещё и саму строку
        # context.Context.Value() имеет сложность O(n)
        # Поэтому необходимо по возможности оптимизировать время на отдельную операцию поиска/сравнения
        #
        - name: context-keys-type
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#cyclomatic
        #
        # gocognit выполняет ту же самую фукнцию
        # revive.cognitive-complexity выполняет ту же самую функцию
        #
        # Был отключен в пользу линтеров оценивающих когнитивную сложность функций
        # По скольку помимо оценки вложенности (которую эти линтеры так же оценивают)
        # Необходимо оценивать общую сложность функций
        #
        # Выключаем
        - name: cyclomatic
          disabled: true
          exclude: [""]
          arguments: [5]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#datarace
        #
        # Запрещает захватывать именованные возвратные перменные в go func() {}()
        #
        # func captureDatarace() (age int) {
        # 	go func() { age++ }()
        #
        # 	return age
        # }
        - name: datarace
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#deep-exit
        #
        # func captureDatarace() { log.Fatal("unexpected") }
        #
        # Запрещает вызывать функции приводящие к os.Exit вне main() или init() функций
        - name: deep-exit
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#defer
        # Позволяет настроить правила касательно использования defer
        #
        # Существует 6 правил, все они по умолчанию включены в линтере
        # Есть возможность оставить только необходимые
        #
        # 1. call-chain
        # call-chain - запрещает цепочки вызовов в defer
        # цепочкa вызовов
        # getLogger будет запущен немедленно в момент постановки
        # очереди в defer а функция которую он возвращает будет запущена
        # по обычным правилам defer
        #
        # Данная программа выведет следующее
        #
        # called getLogger
        # exit
        # called getLogger result
        #
        # func main() {
        # 	getLogger := func() func() {
        # 		fmt.Println("called getLogger")
        #
        # 		return func() {
        # 			fmt.Println("called getLogger result")
        # 		}
        # 	}
        #
        # 	defer getLogger()()
        #
        # 	fmt.Println("exit")
        # }
        #
        # 2. loop
        # loop - запрещает defer в циклах
        #
        # func ProcessFiles(filenames []string) {
        # 	for _, name := range filenames {
        # 		file, err := os.Open(name)
        # 		if err != nil {
        # 			return
        # 		}
        #
        # 		defer func() { _ = file.Close() }() // Все файлы закроются только при выходе из функции!
        #
        # 		// работа с file...
        # 	}
        # }
        #
        # 3. method-call
        # method-call - очень странный линтер, если ты словил это правило не специально ты тот ещё крендель
        #
        # Приведу пример срабатывания
        # type Human struct{}
        #
        # func (Human) Hello() {}
        #
        # func main() {
        # 	defer Human.Hello(Human{})
        # }
        #
        # Срабатывает только если:
        #
        # 1. Метод обращается по значению
        # 2. Вызван именно через конструкцию Type.Method(TypeValue)
        #
        # 4. recover
        # recover - вызов функции recover() должен быть в блоке defer
        #
        # func main() {
        # 	_ = recover() // Неправильно
        # }
        #
        # func main() {
        # 	defer func() { _ = recover() }() // Правильно
        # }
        #
        # 5. immediate-recover
        # immediate-recover - если мы передаём recover() как аргумент
        # функции которую помещаем в defer, функция recover() вызывается незамедлительно
        #
        # helper := func(any) {}
        # defer helper(recover()) // recover выполнится немедленно
        #
        # 6. return
        # return - возвращать значения из defer функции бесполезно
        #
        # func main() {
        # 	defer func() error {
        # 		return io.ErrUnexpectedEOF
        # 	}()
        # }
        #
        - name: defer
          disabled: false
          exclude: [""]
          arguments:
            [
              [
                loop,
                call-chain,
                method-call,
                recover,
                immediate-recover,
                return,
              ],
            ]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#dot-imports
        # Запрещает использование dot-import
        #
        # import (
        #   . "fmt" // добавляет все методы в зону видимости без явного обращения к названию пакета
        # )
        #
        - name: dot-imports
          disabled: false
          exclude: [""]
          arguments:
            - allowed-packages: []

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#duplicated-imports
        # Обнаруживает дубликаты импортов
        #
        # До
        # import (
        # 	"fmt"
        # 	format "fmt"
        # )
        # После
        #
        # import (
        #   "fmt"
        # )
        #
        # staticcheck.ST1019 выполняет ту же самую функцию
        # gocritic.dupImport выполняет ту же самую функцию
        #
        # Выбор сделан в пользу gocritic.dupImport из-за более детального сообщения
        # В нем подсвечены строки дублирующих линтеров
        - name: duplicated-imports
          disabled: true
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#early-return
        #
        # Проверяет блоки if else на возможность замены с сокращением блока else
        #
        # Базовые случаи
        #
        # До
        # func earlyReturn() {
        # 	condition := 10%2 == 0
        #
        # 	if condition {
        # 		log.Println("Hello World!")
        # 	} else {
        # 		return
        # 	}
        # }
        #
        # После
        # func earlyReturn() {
        # 	condition := 10%2 == 0
        #
        # 	if !condition {
        # 		return
        # 	}
        #
        # 	log.Println("Hello World!")
        # }
        #
        # До
        # user := ""
        #
        # if user == "" {
        # 	// пустой блок
        # } else {
        # 	return
        # }
        #
        # После
        #
        # user := ""
        #
        # if user != "" {
        # 	return
        # }
        #
        # Есть две возможных опции
        #
        # 1. allow-jump
        # allow-jump добавляет к if else так же возможность заменять код с помощью continue, break
        #
        # bools := []bool{true, true, true, false}
        #
        # До
        # for _, flag := range bools {
        # 	if flag {
        # 		if !flag {
        # 			fmt.Println("Hello World")
        # 		}
        # 	}
        # }
        #
        # После
        # bools := []bool{true, true, true, false}
        #
        # for _, flag := range bools {
        # 	if !flag {
        # 		continue
        # 	}
        #
        # 	if !flag {
        # 		fmt.Println("Hello World")
        # 	}
        # }
        #
        # 2. preserve-scope
        # preserve-scope позволяет отключить issue для случаев когда в случае исправления будет увеличено
        # количество переменных в зоне видимости
        #
        # Без данной опции на следующий код будет выдано предупреждение
        #
        # func fn3() {
        # 	// Don't want to move the declaration of x here since it stays in scope afterward
        # 	if x := slog.Default(); x != nil {
        # 		log.Println("Hello World")
        # 	} else {
        # 		return
        # 	}
        #
        # 	x := 1
        # 	_ = x
        # }
        - name: early-return
          disabled: false
          exclude: [""]
          arguments: [allow-jump, preserve-scope]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#empty-block
        # Сообщает о пустых блоках
        #
        # if 10%2 == 0 {}
        # if true {} else {}
        # for {}
        - name: empty-block
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#empty-lines
        # Сообщает о пустых линиях которые можно сократить
        # Если вы используете форматирование достаточно тяжело схлопотать
        #
        # func main() { // пустая линия после этой строчки
        #
        # 	log.Println("Hello World!")
        # }
        #
        # Выклядит как частный случай whitespace
        #
        # whitespace выполняет ту же самую функцию
        #
        # Однако настраивается и имеет более широкий функционал
        # Выключаем
        - name: empty-lines
          disabled: true
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#enforce-map-style
        # Регулирует способ инициализации map
        #
        # Предлагаемый набор опций
        #
        # any  - map можно ициализировать любым путём, по сути выключает правило
        # make - map можно инициализовать только с помощью make(map[keyType]valueType)
        # literal - map можно инициализовать тольк через map[keyType]valueType
        #
        # Если вы инициализируете через make(map[keyType]valueType, size) линтер не будет обращать на это внимания
        # независимо от выбранных опций
        - name: enforce-map-style
          disabled: false
          exclude: [""]
          arguments:
            - "make"

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#enforce-repeated-arg-type-style
        #
        # Отвечает за обеспечение единообразия в объявлении повторяющихся типов аргументов и возвращаемых значений в функциях
        #
        # func(a, b int) (x, y int) // short style
        # func(a int, b int) (x int, y int) // full style
        - name: enforce-repeated-arg-type-style
          disabled: false
          exclude: [""]
          arguments:
            - func-arg-style: "short"
              func-ret-val-style: "short"

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#enforce-slice-style
        # Регламентирует стиль создания списков
        # make([]type, 0, capacity) - разрешен для любых случаев
        # []type(nil) - разрешен для любых случаев
        # Возможные опции
        # any - slice можно инициализировать как угодно (по сути выключает линтер)
        # literal - slice можно создать только через []type{}
        # make - slice можно создать только с помощью make([]type, 0)
        # nil - slice можно инициализовать тольк с nil значением
        - name: enforce-slice-style
          disabled: false
          exclude: [""]
          arguments: ["any"]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#enforce-switch-style
        #
        # Регулирует default в switch выражениях а именно его порядок и наличие
        #
        # switch x {
        #   default: // default идёт не последним, выключается allowDefaultNotLast
        #   case 1:
        # }
        #
        # switch x {
        #   case 1:
        #   case 2:
        # } // default отсутствует, отключается allowNoDefault
        #
        # даже если в default мы ничего не собираемся делать он должен быть
        # прочие линтеры на это не ругаются
        - name: enforce-switch-style
          disabled: false
          exclude: [""]
          arguments: []

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#error-naming
        # Все глобальные переменные типа error должны начинаться с (e|E)rr
        #
        # errname выполняет ту же самую функцию
        # Однако распространяется и на типы имплементирующие error
        #
        # Выключаем
        - name: error-naming
          disabled: true
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#error-return
        # В возвращаемых значениях переменная с типом error
        # должна быть последней
        #
        # func do() (error, int)  // НЕВЕРНО error является первым аргументом
        # func do() (int, error)  // ВЕРНО error является последним аргументом
        #
        # staticcheck.ST1008 выполняет ту же самую фукнцию
        #
        # Однако staticcheck.ST1008 обрабатывает следующий случай
        #
        # func fn1() (error, bool) { return nil, true }
        #
        # Это может быть полезно для случаев когда мы используем ok pattern
        #
        # err, ok := fn1()
        #
        # Выключаем
        - name: error-return
          disabled: true
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#error-strings
        #
        #
        # Строки в errors.New и fmt.Errorf не должны начинаться с большой буквы
        # или заканчиваться на знаки пунктуации
        #
        # _ = fmt.Errorf("not found.") // НЕВЕРНО // заканчивается на '.'
        #
        # Аналогично для errors.New
        #
        # _ = errors.New("not found.") // НЕВЕРНО // заканчивается на '.'
        #
        # staticcheck.ST1005 выполняет ту же самую функцию
        # Однако он реагирует на заглавные буквы
        #
        # Выключаем
        - name: error-strings
          disabled: true
          exclude: [""]
          arguments: []

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#errorf
        #
        # Предлагает заменить
        # _ = errors.New(fmt.Sprintf("my %d format", 0))
        # На
        # _ = fmt.Errorf("my %d format", 0)
        #
        # staticcheck.S1028 выполняет ту же самую функцию
        - name: errorf
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#exported
        # заставляет тебя комментить всё что экспортируется
        # Выключаем
        - name: exported
          disabled: true
          exclude: [""]
          arguments:
            - "check-private-receivers"
            - "disable-stuttering-check"
            - "say-repetitive-instead-of-stutters"
            - "check-public-interface"
            - "disable-checks-on-constants"
            - "disable-checks-on-functions"
            - "disable-checks-on-methods"
            - "disable-checks-on-types"
            - "disable-checks-on-variables"

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#file-header
        #
        # Проверяет что файл начинатся с определенного формата
        # Удобно при введении лицензии когда вам необходимо чтобы каждый файл начинался с определенного текста
        #
        # goheader выполняет ту же самую функцию
        #
        # Выключаем
        - name: file-header
          disabled: true
          exclude: [""]
          arguments:
            - This is the text that must appear at the top of source files.

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#file-length-limit
        # Устанавливает максимально допустимую длину файла
        - name: file-length-limit
          disabled: false
          exclude: ["TEST"]
          arguments:
            - max: 750
              skip-comments: true
              skip-blank-lines: true

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#filename-format
        # Даёт возможность настроить формат для .go файлов
        # Не несет какой-то критичной полезность
        # Выключаем
        - name: filename-format
          disabled: true
          exclude: [""]
          arguments:
            - "^[_a-z][_a-z0-9]*\\.go$"

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#flag-parameter
        # Отслеживает начилие bool переменных в фукнциях которые могут быть флагами
        #
        # func checkOrderOptimize(flag bool) {
        # 	if flag {
        # 		log.Println("Hello World!")
        # 	}
        # }
        #
        # На примеры ниже линтер не реагирует
        #
        # func checkOrderOptimize(flag bool) {
        # 	_ = flag
        # }
        #
        # type User struct {
        # 	Flag bool
        # }
        #
        # func checkOrderOptimize(flag bool) User {
        # 	return User{Flag: flag}
        # }
        - name: flag-parameter
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#function-length
        #
        # funlen выполняет ту же самую функцию
        # Однако имеет опции для настроки
        #
        # Выключаем
        - name: function-length
          disabled: true
          exclude: [""]
          arguments: [40, 0]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#function-result-limit
        #
        # Ограничивает количество выходных параметров функции
        #
        # Функция ниже имеет три возвращаемых аргумента
        # при максимально допустимом 2
        #
        # func returnValues() (a, b, c int) { return 0, 0, 0 }
        #
        - name: function-result-limit
          disabled: false
          exclude: [""]
          arguments: [2]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#get-return
        #
        # Если функцию начинается с get она должна иметь возвращаемое значение
        #
        # func getNothing() {} // НЕПРАВИЛЬНО функция ничего не возвращает
        # func getInt() int { return 0 } // ПРАВИЛЬНО
        # func getError() error { return io.ErrUnexpectedEOF } // ПРАВИЛЬНО
        #
        - name: get-return
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#identical-branches
        #
        # Обнаруживает if {} else {} блоки с одинаковым кодов в if и else
        #
        # if 10%2 == 0 {
        # 		log.Println("Hello World!") // Одно и тоже условие в обеих ветках
        # } else {
        # 		log.Println("Hello World!") // Одно и тоже условие в обеих ветках
        # }
        - name: identical-branches
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#identical-ifelseif-branches
        #
        # Обнаруживает if {} else if {} блоки с одинаковым кодов в if и else if
        #
        # if 10%2 == 0 {
        # 	log.Println("Hello World!") // Одно и тоже условие в обеих ветках
        # } else if 10%5 == 0 {
        # 	log.Println("Hello World!") // Одно и тоже условие в обеих ветках
        # }
        - name: identical-ifelseif-branches
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#identical-ifelseif-conditions
        # Обнаруживает идентичные условие в ветка if {} else if {}
        #
        # if 10%2 == 0 { // Идентичное условие
        # 	log.Println("Hello World!")
        # } else if 10%2 == 0 { // Идентичное услове
        # 	log.Println("Hello World!")
        # }
        - name: identical-ifelseif-conditions
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#identical-switch-branches
        #
        # Должен сообщать об одинаковых ветках switch
        #
        # Однако на код ниже он не реагирует, что является явной недоработкой
        #
        # switch {
        # case 10%2 == 0:
        # 	log.Println("Hello World!")
        # case 10%5 == 0:
        # 	log.Println("Hello World!")
        # default:
        # 	log.Println("Hello World!")
        # }
        #
        # value := 0
        #
        # switch {
        # case value == 1:
        # 	log.Println("Hello World!")
        # case value == 2:
        # 	log.Println("Hello World!")
        # default:
        # 	log.Println("Hello World!")
        # }
        #
        # На следующие примеры кода он создаст issue
        #
        # switch 10%2 == 0 {
        # case true:
        # 	log.Println("Hello World!") // Одно и тоже условие во всех ветках
        # case false:
        # 	log.Println("Hello World!") // Одно и тоже условие во всех ветках
        # default:
        # 	log.Println("Hello World!") // Одно и тоже условие во всех ветках
        # }
        #
        # value := 0
        #
        # switch value {
        # case 1:
        # 	log.Println("Hello World!") // Одно и тоже условие во всех ветках
        # case 2:
        # 	log.Println("Hello World!") // Одно и тоже условие во всех ветках
        # default:
        # 	log.Println("Hello World!") // Одно и тоже условие во всех ветках
        # }
        #
        - name: identical-switch-branches
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#identical-switch-conditions
        #
        # Сообщает об идентичных ветках в switch case
        # value := 0
        #
        # switch {
        # case value == 1: // идентичные ветки
        # 	log.Println("Hello World!")
        # case value == 1: // идентичные ветки
        # 	log.Println("Hello World!")
        # default:
        # 	log.Println("Hello World!")
        # }
        #
        - name: identical-switch-conditions
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#if-return
        #
        # Обнаруживает избыточные проверки вида if err != nil { return err }; return nil
        #
        # Пример 1: Избыточная проверка - сработает линтер
        #
        # До
        # func processDataRedundant() error {
        # 	if err := riskyOperation(true); err != nil {
        # 		return err
        # 	}
        #
        # 	return nil
        # }
        #
        # После
        # func processDataRedundant() error {
        # 	return riskyOperation(true)
        # }
        #
        # Пример 2: В цепочке вызовов - сработает линтер
        #
        # До
        # func processChain() error {
        # 	if err := alwaysSucceeds(); err != nil {
        # 		return err
        # 	}
        #
        # 	if err := riskyOperation(true); err != nil {
        # 		return err
        # 	}
        #
        # 	return nil
        # }
        #
        # После
        # func processChain() error {
        # 	if err := alwaysSucceeds(); err != nil {
        # 		return err
        # 	}
        #
        # 	return riskyOperation(true)
        # }
        #
        - name: if-return
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#import-alias-naming
        # Позволяет настроить паттрены для названий alias импортов
        # По умолчанию запрещены символы верхнего регистра
        #
        # import Os "os" // alias в верхнем регистре
        #
        # Позволяет настроить запрещенные и разрешенные паттерны
        - name: import-alias-naming
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#import-shadowing
        #
        # Определяет, когда импортированные имена пакетов затенены в назначениях.
        #
        # func main() {
        # 	fmt.Println("Hello World!")
        #
        # 	fmt := "Hello World"
        # 	_ = fmt
        # }
        - name: import-shadowing
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#imports-blocklist
        #
        # Позволяет указать список импортов которые запрещены к использованию
        #
        # depguard выполняет ту же самую функцию
        #
        # Однако является полноценным линтеров и имеет опции для настройки
        #
        # Выключаем
        - name: imports-blocklist
          disabled: true
          exclude: [""]
          arguments:
            - "crypto/md5"
            - "crypto/sha1"

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#increment-decrement
        #
        # Предлагает заменить += 1 на ++ и -= 1 на -- в операциях с числам
        #
        # var counter int
        #
        #
        # До
        # counter += 1
        # counter -= 1
        #
        # После
        # counter++
        # counter--
        - name: increment-decrement
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#indent-error-flow
        #
        # Позволяет находить места в коде где есть возможность сократить вложенность кода
        #
        # До
        # func process(value int) error {
        # 	if value > 0 {
        # 		return doSomething(value)
        # 	} else {
        # 		return errors.New("invalid value")
        # 	}
        # }
        #
        # После
        # func process(value int) error {
        # 	if value > 0 {
        # 		return doSomething(value)
        # 	}
        #
        # 	return errors.New("invalid value")
        # }
        #
        #
        # Есть возможность указать опцию preserveScope
        #
        # Линтер не будет предлагать исправлений если это увеличит количество переменных в скоупе
        #
        # Без данной опции для слующего кода будет выдано предупреждение
        #
        # func preserveScope() ([]byte, error) {
        # 	if data, err := os.ReadFile("myfile"); err != nil {
        # 		return nil, fmt.Errorf("os.ReadFile: %w", err)
        # 	} else {
        # 		return data, nil
        # 	}
        #
        # 	panic("unreachable")
        #
        # 	return nil, nil
        # }
        - name: indent-error-flow
          disabled: false
          exclude: [""]
          arguments: [preserve-scope]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#inefficient-map-lookup
        # Правило пока не добавлено golangci-lint: 2.6.0
        # - name: inefficient-map-lookup
        #   disabled: false
        #   exclude: [""]
        #   arguments: []

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#line-length-limit
        # Сигнализирует о слишком длинных линиях
        # lll выполняет ту же самую функцию
        # Однако настраивается и сам по себе является отдельным линтеров
        # предназначенным под эту задачу
        #
        # Выключаем
        - name: line-length-limit
          disabled: true
          exclude: [""]
          arguments: [120]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#max-control-nesting
        # Устанавливает максимально допустимый уровень вложенности
        - name: max-control-nesting
          disabled: false
          exclude: [""]
          arguments: [3]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#max-public-structs
        # Устанавливает максимально возможное количество экспортируемых функций в пакете
        #
        # Выключаем
        - name: max-public-structs
          disabled: true
          exclude: [""]
          arguments: [3]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#modifies-parameter
        #
        # Срабатывает в случае модификации параметра до его первого использования
        #
        # Пример false-positive
        #
        # До
        # func do(value any) {
        # 	switch value := value.(type) { // value необходимо переименовать
        # 	case int:
        # 		_ = value
        # 	case string:
        # 		_ = value
        # 	}
        # }
        #
        # После
        # func do(value any) {
        # 	switch typedValue := value.(type) {
        # 	case int:
        # 		_ = typedValue
        # 	case string:
        # 		_ = typedValue
        # 	}
        # }
        #
        - name: modifies-parameter
          disabled: false
          exclude: [""]
          arguments: []

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#modifies-value-receiver
        #
        # Сообщает о случаях модификации полей структуры в методах расширения
        # где структура передаётся по значению
        #
        # type User struct {
        # 	Name string
        # }
        #
        # До
        # func (u User) SetName(name string) { // нет эффекта
        # 	u.Name = name
        # }
        #
        # После
        # func (u *User) SetName(name string) {
        #   u.Name = name
        # }
        #
        - name: modifies-value-receiver
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#nested-structs
        # Запрещает вложенные анонимные структуры
        #
        # type Nested struct {
        # 	Nested struct {
        # 		Name string
        # 	}
        # }
        - name: nested-structs
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#optimize-operands-order
        #
        # Находит код где возможно оптимизировать порядок логических операндов
        #
        # Сначала должны идти условия bool операторы
        # так как на их подсчет не нужно много усилий
        # и только в случае если оно выполняется - переходить к вычислениям bool в функциях
        #
        # До
        # func optimizeOperandOrder() {
        #   condition := 10%2 == 0
        # 	if getBool() && condition {
        # 		log.Println("Hello World")
        # 	}
        # }
        # После
        # func optimizeOperandOrder() {
        #   condition := 10%2 == 0
        # 	if condition && getBool() { // поменяли порядок следования condition и getBool
        # 		log.Println("Hello World")
        # 	}
        # }
        - name: optimize-operands-order
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#package-comments
        # Связан с коментами TODO разобрать позже
        #
        # Обязывает нас писать комментарии перед каждым пакетом
        # Хотя бы один на весь пакет
        #
        # Комментарий должен следовать определённому формату
        # // Package <package name> ...
        #
        # // Package linter need for testing linter issues
        # package linter
        #
        # Выключаем
        - name: package-comments
          disabled: true
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#package-directory-mismatch
        # Имя пакета должно совпадать с названием его директории
        #
        # Мне не нравится
        #
        # Иногда я хочу чтобы моя директория не содержала лишних слов
        # однако при импорте я не хочу передирать миллион вариантов с таким же названием
        # поэтому диреторию я назову service а название пакета servicecounter
        #
        # Выключаем
        - name: package-directory-mismatch
          disabled: true
          exclude: [""]
          arguments:
            - ignore-directories: ["testcases", "testinfo"]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#range
        #
        # Обнаруживает случаи когда в range с двумя переменными вторая переменная не используется
        #
        # nums := []int{1, 2, 3}
        #
        #	for i, _ := range nums {
        #		_ = i
        #	}
        #
        #
        # gofumpt устраняет это автоматически
        - name: range
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#range-val-address
        #
        # До go 1.22 у каждой переменной в цикле был один и тот же адрес
        #
        # nums := []int{1, 2, 3}
        #
        # numsRef := []*int{}
        # for _, i := range nums {
        # 	numsRef = append(numsRef, &i)
        # }
        #
        # numsRef будет содержать один и тот же идентификатор
        #
        # В go 1.22+ не актуален
        - name: range-val-address
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#range-val-in-closure
        #
        # До go 1.22 у каждой переменной в цикле был один и тот же адрес
        #
        # nums := []int{1, 2, 3}
        #
        # mu := sync.Mutex{}
        #
        # numsRef := []int{}
        #
        # for _, i := range nums {
        # 	go func() {
        # 		mu.Lock()
        # 		defer mu.Unlock()
        #
        # 		numsRef = append(numsRef, i)
        # 	}()
        # }
        #
        # Поведение непресказуемо
        #
        # В go 1.22+ не актуален
        - name: range-val-in-closure
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#receiver-naming
        #
        # Указывает максимально допустимую длину переменной обозначающей структуру в методах расширениях
        #
        # type Receiver struct{}
        #
        # func (receiver Receiver) Hello() { _ = receiver }
        #
        # Максимально допустимая длина настраивается
        #
        # Мне не нравится что меня ограничивают в фантазии
        #
        # Выключаем
        - name: receiver-naming
          disabled: true
          exclude: [""]
          arguments:
            - max-length: 2

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#redefines-builtin-id
        # Обнаруживает имена переменных, функций перекрывающих ключевые имена стандартной библиотеки
        # predeclared выполняет ту же самую фукнцию
        # но настраивается и имеет возможность проверять поля
        # Выключаем
        - name: redefines-builtin-id
          disabled: true
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#redundant-build-tag
        #
        # Сообщает о случаях если комментарий // +build идёт раньше //go:build
        #
        # govet.buildtag выполняют ту же самую фукнцию
        #
        # Интересно получается воспроизвести при запуске
        # golangci-lint run ./main.go
        #
        # При запуске golangci-lint run сообщений нет
        #
        # Выключаем
        - name: redundant-build-tag
          disabled: true
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#redundant-import-alias
        #
        # Сообщает о случаях когда alias пакета полностью совпадает с его именем
        #
        # import fmt "fmt"
        #
        - name: redundant-import-alias
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#redundant-test-main-exit
        #
        # До go 1.15 требовалось явно вызывать os.Exit в функции TestMain по завершению тестов
        #
        # Сейчас же этого не требуется
        #
        # До
        # func TestMain(m *testing.M) {
        # 	result := m.Run()
        # 	os.Exit(result) // ← избыточно в Go 1.15+
        # }
        #
        # После
        # func TestMain(m *testing.M) {
        # 	m.Run()
        # }
        - name: redundant-test-main-exit
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#string-format
        #
        # Полноценный инструмент позволяющий настраивать compilation-time проверки
        # статичных строк для отдельных полей и функций
        #
        #
        - name: string-format
          disabled: false
          exclude: [""]
          arguments: []

            # Рассмотрим правило ниже
            #
            # [
            #   [
            #     "NewUserInfo[0]",
            #     "/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/",
            #     "invalid user email",
            #   ],
            # ]
            #
            # Оно означает следующее
            #
            # Первый аргумент функции NewUserInfo должен соответствовать определённому regexp
            #
            # _ = NewUserInfo("invalid email") // данный код вызовет ошибку
            #	_ = NewUserInfo("mcdvaran@gmail.com") // всё хорошо, строка прошла проверку
            #
            # # - - "core.WriteError[1].Message"
            #   - "/^([^A-Z]|$)/"
            #   - must not start with a capital letter
            # - - "fmt.Errorf[0]"
            #   - '/(^|[^\.!?])$/'
            #   - must not end in punctuation
            # - - panic
            #   - '/^[^\n]*$/'
            #   - must not contain line breaks

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#string-of-int
        #
        # Запрещает конвертировать числа до строки напрямую
        #
        # _ = string(10) // неверно
        # _ = strconv.Itoa(10) // верно
        #
        # govet.stringintconv выполняет ту же самую функцию
        #
        # Выключаем
        - name: string-of-int
          disabled: true
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#struct-tag
        # Сообщает об ошибках связанных с тегированием полей функции
        #
        # Проверяет большинство популярных тегов (bson, yaml, toml, validate и тд)
        #
        # type User struct {
        # 	Name string `json:name`
        # 	age  string `json:"age"`
        # }
        #
        # staticcheck.SA5008 выполняет ту же функцию
        # Однако покрывает больше случаев
        #
        # Выключаем
        - name: struct-tag
          disabled: true
          exclude: [""]
          arguments: []

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#superfluous-else
        #
        # Сообщает об "излишних" блоках else
        #
        # items := []int{}
        #
        # // ❌ До
        # for i := range items {
        # 	if i == 0 {
        # 		break
        # 	} else {
        # 		process(items[i])
        # 	}
        # }
        #
        # // ✅ После
        # for i := range items {
        # 	if i == 0 {
        # 		break
        # 	}
        #
        # 	process(items[i])
        # }
        #
        #
        # preserve-scope
        # Данная опция будет исключать случаи где исправление может привести
        # к увеличению количества переменных в зоне видимости
        #
        # func fn3() {
        # 	for {
        # 		// Don't want to move the declaration of x here since it stays in scope afterward
        # 		if x := fn1(); x != nil {
        # 			continue
        # 		} else {
        # 			fn1()
        # 		}
        #
        # 		x := fn1()
        # 		_ = x
        # 	}
        # }
        #
        # func fn1() any { return nil }
        - name: superfluous-else
          disabled: false
          exclude: [""]
          arguments: [preserve-scope]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#time-date
        #
        # Проверяет аргументы функции time.Date
        #
        # например час не может быть больше 23
        #
        # time.Date hour argument should be between 0 and 23: 30
        #	_ = time.Date(year, month, day, 30, minute, second, 0, time.UTC)
        - name: time-date
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#time-equal
        #
        # Обязывает сравнивать time.Time с помощью метода time.Time.Equal
        #
        # До
        #	_ = time.Now() == time.Now()
        # После
        # _ = time.Now().Equal(time.Now())
        #
        - name: time-equal
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#time-naming
        #
        # В именах переменных типа time.Duration не следует использовать суффиксы
        # обозначающие период времени
        #
        # const sixMin = 6 * time.Minute
        #
        #
        - name: time-naming
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#unchecked-type-assertion
        #
        # Запрещает использование непроверенных type assertion
        #
        # i := any(nil).(int) // НЕВЕРНО
        # i, ok := any(nil).(int) // ВЕРНО
        #
        # accept-ignored-assertion-result: false - запрещает игнорировать (опускать) значения bool при проверке
        #
        # i, _ = any(nil).(int) // НЕВЕРНО ok (bool) значение опущено
        - name: unchecked-type-assertion
          disabled: false
          exclude: ["TEST"]
          arguments:
            - accept-ignored-assertion-result: false

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#unconditional-recursion
        #
        # Обнаруживает бесконечную рекурсию
        #
        # func infinity() {
        # 	infinity()
        # }
        - name: unconditional-recursion
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#unexported-naming
        #
        # Неэкспортируемые символы должны начинаться с буквы нижнего регистра
        #
        # func unexportedNaming() {
        # 	const Unexported = 0 // НЕВЕРНО // должно начинаться с маленькой буквы
        # }
        #
        # func unexportedNaming() {
        # 	const unexported = 0 // ПОРЯДОК
        # }
        #
        - name: unexported-naming
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#unexported-return
        #
        # Сообщает о публичных функциях которые возвращают неэкспортируемые символы
        #
        # type unexported struct{} // не экспортируется
        #
        # func UnexportedNaming() unexported { // возвращаем неэскортируемый тип
        # 	return unexported{}
        # }
        - name: unexported-return
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#unhandled-error
        # Проверяет обработку ошибок
        # errcheck выполняет ту же самую функцию
        # errcheck позволяет нам игнорировать ошибку в ряде случаев когда её невозможно получить
        # например Write в bytes.Buffer или strings.Builder
        # И много прочих случаев
        # Выключаем
        - name: unhandled-error
          disabled: true
          exclude: [""]
          arguments:
            - "^fmt.Printf"
            - "myFunction"

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#unnecessary-format
        #
        # Сообщает о вызове функций-форматтеров где не используется форматирование
        # Предлагает заменить такие функции на аналог без форматирования
        #
        #	log.Printf("Hello World\n")
        - name: unnecessary-format
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#unnecessary-stmt
        #
        # Сообщает о break в конце switch case который вполне можно опустить
        # Сообщает о return в конце функции который вполне можено опустить
        #
        # func bar() {
        # 	switch {
        # 	case 10%2 == 0:
        # 		log.Println("YES YES YES")
        #
        # 		break // можно опустить
        # 	case 15%5 == 0:
        # 		log.Println("NO NO NO")
        #
        # 		break // можно опустить
        # 	default:
        # 	}
        #
        # 	return // можно опустить
        # }
        #
        - name: unnecessary-stmt
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#unreachable-code
        #
        # Сообщает о коде до которого не может дойти выполнение
        #
        # func foo() int {
        # 	log.Println("About to fail")
        #
        # 	return 0 // MATCH /unreachable code after this statement/
        # 	return 1 // недостижимый код
        # }
        #
        #
        # govet.unreachable выполняет ту же самую функцию
        #
        # Выключаем
        - name: unreachable-code
          disabled: true
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#unsecure-url-scheme
        #
        # Сообщает об использовании небезопасных url схем (http, ws)
        #
        # req, err := http.NewRequestWithContext(
        # 	ctx,
        # 	http.MethodGet,
        # 	"http://github.com/amidgo", // использование http небезопасно
        # 	http.NoBody,
        # )
        # if err != nil {
        # 	panic(err)
        # }
        - name: unsecure-url-scheme
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#unused-parameter
        #
        # Сообщает о неиспользуемых параметрах
        #
        # func unusedParam(param any) {} // параметр param не используется
        # func unusedParam(any) {} // название неиспользуемого параметра опущено, ДОПУСТИМО
        # func unusedParam(_ any) {} // названием неиспользуемого параметра является _, ДОПУСТИМО
        #
        - name: unused-parameter
          disabled: false
          exclude: [""]
          arguments:
            - allow-regex: "^_"

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#unused-receiver
        #
        # Сообщает об неиспользумой структуре в методах расширениях
        #
        # type Receiver struct{ value int }
        #
        # func (r Receiver) Hello() {} // не используется, линтер сообщит о ПРОБЛЕМЕ
        # func (Receiver) Hello() {} // навзание опущено, ДОПУСТИМО
        #
        # Замена на _ здесь не допускается
        # по причине конфликта с staticcheck.ST1006
        #
        - name: unused-receiver
          disabled: false
          exclude: [""]
          arguments: []

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#use-any
        #
        # Предлагает заменить interface{} на any
        #
        # modernize.any выполняет ту же самую фукнцию
        #
        # Выключаем
        - name: use-any
          disabled: true
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#use-errors-new
        #
        # Предлагает заменить fmt.Errorf("error text") на errros.New("error text")
        #
        # Выглядит как частный случай revive.unnecessary-format
        #
        # revive.unnecessary-format выполняет ту же самую функцию
        # Однако его функционал гораздо шире
        #
        # Выключаем
        - name: use-errors-new
          disabled: true
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#use-fmt-print
        #
        # Запрещает использовать println и print
        # по причине что авторы языка не гарантируют их наличие в последующих версиях языка
        #
        # С подобным запретом прекрасно справляется forbidigo
        #
        # forbidigo выполняет ту же самую функцию
        # Однако его функционал гораздо шире
        #
        # Выключаем
        - name: use-fmt-print
          disabled: true
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#use-waitgroup-go
        # modernize.waitgroup выполняет ту же самую функцию
        #
        # Выключаем
        - name: use-waitgroup-go
          disabled: true
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#useless-break
        #
        # Сообщает о бесполезных break
        #
        # ctx := context.Background()
        #
        # select {
        # case <-ctx.Done():
        # 	break
        # default:
        # }
        #
        # В отличие от похожих линтеров
        # revive.unnecessary-stmt
        # staticcheck.S1023
        #
        # Проверяет select
        #
        # По этой причине я его оставил, не смотря на дубли
        #
        - name: useless-break
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#useless-fallthrough
        #
        # Сообщает о switch case использующим fallthrough который можно сократить
        #
        # До
        # func uselessFallthrough(category string) bool {
        # 	switch category {
        # 	case "Lu":
        # 		fallthrough
        # 	case "Ll":
        # 		fallthrough
        # 	case "Lt":
        # 		fallthrough
        # 	case "Lm":
        # 		fallthrough
        # 	case "Lo":
        # 		return true
        # 	default:
        # 		return false
        # 	}
        # }
        #
        # После
        # func uselessFallthrough(category string) bool {
        # 	switch category {
        # 	case "Lu", "Ll", "Lt", "Lm", "Lo":
        # 		return true
        # 	default:
        # 		return false
        # 	}
        # }
        - name: useless-fallthrough
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#var-declaration
        #
        # Предлагает опускать названия типов при создании переменной через var
        # var data []byte = []byte{} // НЕВЕРНО
        # var data = []byte{} // ВЕРНО
        #
        - name: var-declaration
          disabled: false
          exclude: [""]

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#var-naming
        #
        #
        # Устанавливает ряд правил для именования пакетов, переменных, типов, методов и функций
        #
        # staticcheck.ST1003 выполняет ту же самую функцию из коробки
        # без необходимости настроки (кроме initializm что явно плюс)
        #
        # Выключаем
        - name: var-naming
          disabled: true
          exclude: [""]
          arguments:
            - [] # AllowList
            - [] # DenyList


              # type marshalerJson struct{} НЕВЕРНО
              # type marshalerJSON struct{} ВЕРНО
              # staticcheck.ST1003 выполняет ту же самую функцию
              # Выключаем проверку аббревиатур в данном линтере
            - - skip-initialism-name-checks: true

                # если опция включена правило будет допускать подобный синтаксис
                # const UPPER_CASE = true
                upper-case-const: false

                # валидация имен пакетов
                # имена пакетов должны содержать только латинские буквы нижнего регистра
                # package Main
                #
                # Позволяет выключить настроку
                skip-package-name-checks: true

        # https://github.com/mgechev/revive/blob/HEAD/RULES_DESCRIPTIONS.md#waitgroup-by-value
        #
        # Запрещает передавать sync.WaitGroup по значению а не по ссылке
        #
        # func add(wg sync.WaitGroup) { wg.Add(1) }
        #
        # govet.copylocks выполняет ту же самую функцию
        #
        # Выключаем
        - name: waitgroup-by-value
          disabled: true
          exclude: [""]

    rowserrcheck:
      # Дополнительно проверяем и sqlx
      packages:
        - "github.com/jmoiron/sqlx"

    sloglint:
      # Enforce not mixing key-value pairs and attributes.
      # https://github.com/go-simpler/sloglint?tab=readme-ov-file#no-mixed-arguments
      # До
      # log.InfoContext(ctx, "my message",
      # 	"key", 100,           // здесь замикшированны ключ-значение с slog.Attr
      # 	slog.Int("num", 100),
      # )
      #
      # После
      # log.InfoContext(ctx, "my message",
      # 	"key", 100,
      # 	"num", 100,
      # )
      # или
      # log.InfoContext(ctx, "my message",
      # 	slog.Int("key", 100),
      # 	slog.Int("num", 100),
      # )
      #
      # Default: true
      no-mixed-args: true

      # Enforce using key-value pairs only (overrides no-mixed-args, incompatible with attr-only).
      # https://github.com/go-simpler/sloglint?tab=readme-ov-file#key-value-pairs-only
      #
      # Обязывает использовать только key value паттерн при логировании
      # Перекрывает no-mixed-args
      #
      # из примеров выше будет доступен только вариант где все параметры
      # прописаны в стиле ключ-значение
      #
      # log.InfoContext(ctx, "my message",
      # 	"key", 100,
      # 	"num", 100,
      # )
      #
      # Не может быть включена вместе с attr-only
      #
      # Default: false
      kv-only: false

      # Enforce using attributes only (overrides no-mixed-args, incompatible with kv-only).
      # https://github.com/go-simpler/sloglint?tab=readme-ov-file#attributes-only
      #
      # Обязывает использовать только slog.Attr при логировании
      # Перекрывает no-mixed-args
      #
      # из примером выше будет доступен только вариант где все параметры
      # прописаны в стиле slog.Attr
      #
      # log.InfoContext(ctx, "my message",
      # 	slog.Int("key", 100),
      # 	slog.Int("num", 100),
      # )
      #
      # Не может быть включена вместе с kv-only
      #
      # Default: false
      attr-only: false

      # Enforce not using global loggers.
      # Values:
      # - "": disabled
      # - "all": report all global loggers
      # - "default": report only the default slog logger
      # https://github.com/go-simpler/sloglint?tab=readme-ov-file#no-global
      #
      # Запрещает использовать глобальные slog.Logger
      #
      # Пример использование глобального логгера
      #
      # slog.InfoContext(ctx, "my message",
      # 	slog.Int("key", 100),
      # 	slog.Int("num", 100),
      # )
      #
      # Default: ""
      no-global: "all"

      # Enforce using methods that accept a context.
      # Values:
      # - "": disabled
      # - "all": report all contextless calls
      # - "scope": report only if a context exists in the scope of the outermost function
      # https://github.com/go-simpler/sloglint?tab=readme-ov-file#context-only
      # Default: ""
      #
      # Обязывает использовать только те методы логгера
      # которые принимают в себя context.Context
      # До
      # slog.Info(ctx, "my message",
      # 	slog.Int("key", 100),
      # 	slog.Int("num", 100),
      # )
      #
      # После
      # slog.InfoContext(ctx, "my message",
      # 	slog.Int("key", 100),
      # 	slog.Int("num", 100),
      # )
      context: "all"

      # Enforce using static values for log messages.
      # https://github.com/go-simpler/sloglint?tab=readme-ov-file#static-messages
      #
      # Обязывает использовать в качесте msg аргумента статичную строку
      #
      # Позволяет использовать константы (const myMessage)
      #
      # До
      # myMessage := "my message"
      #
      # log.InfoContext(ctx, myMessage,
      # 	slog.Int("key", 0),
      # 	slog.Int("num", 1),
      # )
      #
      # После
      # const myMessage = "my message"
      #
      # log.InfoContext(ctx, myMessage,
      # 	slog.Int("key", 0),
      # 	slog.Int("num", 1),
      # )
      # или
      # log.InfoContext(ctx, "my message",
      # 	slog.Int("key", 0),
      # 	slog.Int("num", 1),
      # )
      #
      # Default: false
      static-msg: true

      # Enforce message style.
      # Values: lowercased, capitalized
      #
      # https://github.com/go-simpler/sloglint?tab=readme-ov-file#message-style
      #
      # Указывает формат сообщения (строчные или заглавные буквы)
      #
      # log.InfoContext(ctx, "My message",
      # 	slog.Int("key", 0),
      # 	slog.Int("num", 1),
      # )
      #
      # Default: ""
      msg-style: lowercased

      # Enforce using constants instead of raw keys.
      # https://github.com/go-simpler/sloglint?tab=readme-ov-file#no-raw-keys
      #
      # Запрещает к использованию ключи которые не являются константами
      #
      # До
      # log.InfoContext(ctx, "my message",
      # 	slog.Int("key", 0), // необходимо создать константу со значением "key"
      # 	slog.Int("num", 1), // необходимо создать константу со значением "num"
      # )
      #
      # log.InfoContext(ctx, "my message",
      # 	"key", 0, // необходимо создать константу со значением "key"
      # 	"num", 1, // необходимо создать константу со значением "num"
      # )
      #
      # После
      # const (
      # 	key = "key"
      # 	num = "num"
      # )
      #
      # log.InfoContext(ctx, "my message",
      # 	key, 0,
      # 	num, 1,
      # )
      #
      #
      # log.InfoContext(ctx, "my message",
      # 	slog.Int(key, 0),
      # 	slog.Int(num, 1),
      # )
      #
      # Default: false
      #
      # Оставлю false с тем условием
      # что правило revive.add-constant укажет на использование одного и того же ключа более 1 раза
      no-raw-keys: false

      # Enforce key naming convention.
      # Values: snake, kebab, camel, pascal
      # https://github.com/go-simpler/sloglint?tab=readme-ov-file#key-naming-convention
      #
      # Регламентирует стиль написания ключей
      #
      # До
      # const key = "myKey" // ключ написан в camelCase, а требуется snake_case
      #
      # После
      # const key = "my_key" // Порядок, стиль написания ключа соответствует выбранному
      #
      # log.InfoContext(ctx, "my message",
      # 	slog.Int(key, 0),
      # )
      #
      # Default: ""
      key-naming-case: snake

      # Enforce not using specific keys.
      # https://github.com/go-simpler/sloglint?tab=readme-ov-file#forbidden-keys
      #
      # Позволяет настроить перечень ключей запрещённых к использованию
      #
      # const key = "time" // ключ time запрещен к использованию
      #
      # log.InfoContext(ctx, "my message",
      # 	slog.Int(key, 0),
      # )
      #
      # log.InfoContext(ctx, "my message",
      # 	key, 0,
      # )
      #
      #
      # Default: []
      #
      # Указанные здесь ключи запрещены по причине их наличия в логах по умолчанию
      forbidden-keys:
        - time
        - level
        - msg
        - source

      # Enforce putting arguments on separate lines.
      # https://github.com/go-simpler/sloglint?tab=readme-ov-file#arguments-on-separate-lines
      #
      # Каджый следующий аргумент должен идти на следующей сточке
      #
      # До
      # log.InfoContext(ctx, "my message", slog.Int("count", 1), slog.Int("num", 1))
      # После
      # log.InfoContext(ctx, "my message",
      # 	slog.Int("count", 1),
      # 	slog.Int("num", 1),
      # )
      #
      # Default: false
      args-on-sep-lines: true

    spancheck:
      # Checks to enable.
      # Options include:
      # - `end`: check that `span.End()` is called
      # - `record-error`: check that `span.RecordError(err)` is called when an error is returned
      # - `set-status`: check that `span.SetStatus(codes.Error, msg)` is called when an error is returned
      # Default: ["end"]
      checks:
        # Проверяет вызов span.End
        #
        # До
        # ctx := context.Background()
        #
        # tracer := otel.Tracer("service")
        #
        # ctx, span := tracer.Start(ctx, "op")
        # // вызов span.End отсутсвует
        # _ = ctx
        # _ = span
        #
        # После
        # ctx := context.Background()
        #
        # tracer := otel.Tracer("service")
        #
        # ctx, span := tracer.Start(ctx, "op")
        # defer span.End() // вызов span.End в defer
        #
        # _ = ctx
        - end

        # следующие два линтера будут рассмотрены вместе
        #
        # record-error - проверяет вызов span.RecordError(err) в случае ошибки
        # set-status   - проверяет вызов span.SetStatus(codes.Error, "error message") в случае ошибки
        #
        #
        # До
        # ctx := context.Background()
        #
        # tracer := otel.Tracer("service")
        #
        # ctx, span := tracer.Start(ctx, "op")
        # defer span.End()
        #
        # _, err := http.NewRequestWithContext(ctx, http.MethodGet, "https://github.com", http.NoBody)
        # if err != nil {
        #   // в данном блоке при обработке ненулевой ошибки
        #   // мы должны были вызвать
        #   // 1. если включена опция record-error - span.RecordError(err)
        #   // 2. если включана опция set-status   - span.SetStatus(codes.Error, err.Error())
        # 	return fmt.Errorf("http.NewRequestWithContext: %w", err)
        # }
        #
        # return nil
        #
        # После
        # ctx := context.Background()
        #
        # tracer := otel.Tracer("service")
        #
        # ctx, span := tracer.Start(ctx, "op")
        # defer span.End()
        #
        # _, err := http.NewRequestWithContext(ctx, http.MethodGet, "https://github.com", http.NoBody)
        # if err != nil {
        # 	span.RecordError(err)
        # 	span.SetStatus(codes.Error, err.Error())
        #
        # 	return fmt.Errorf("http.NewRequestWithContext: %w", err)
        # }
        #
        # return nil
        #
        # Записывать ошибку в спан может быть не всегда необходимо
        # возможно вы желаете записывать ошибку лишь один раз на самом верхнем уровне
        # Выключаем
        #
        # - record-error
        # - set-status

      # A list of regexes for function signatures that silence `record-error` and `set-status` reports
      # if found in the call path to a returned error.
      # https://github.com/jjti/go-spancheck#ignore-check-signatures
      #
      # Предположим у нас есть функция-помощник annotateError
      #
      # func annotateError(span trace.Span, err error) {
      # 	span.RecordError(err)
      # 	span.SetStatus(codes.Error, err.Error())
      # }
      #
      # И мы хотим использовать её для того чтобы помечать ошибку на наших спанах
      # Однако линтер не знает про эту замечательную фукнцию
      # и пишет нам что бы забыли вызвать RecordError и SetStatus на нашем спане
      # данная настрока призвана решить нашу проблему
      #
      # если мы укажем нашу функцию annotateError в списке то следующий код будет проходить
      # без лишних замечаний:
      #
      # ctx := context.Background()
      #
      # tracer := otel.Tracer("service")
      #
      # ctx, span := tracer.Start(ctx, "op")
      # defer span.End()
      #
      # _, err := http.NewRequestWithContext(ctx, http.MethodGet, "https://github.com", http.NoBody)
      # if err != nil {
      # 	annotateError(span, err)
      #
      # 	return fmt.Errorf("http.NewRequestWithContext: %w", err)
      # }
      #
      # return nil
      #
      # Default: []
      ignore-check-signatures:
        - annotateError
        # - "telemetry.RecordError"

      # A list of regexes for additional function signatures that create spans.
      # This is useful if you have a utility method to create spans.
      # Each entry should be of the form `<regex>:<telemetry-type>`, where `telemetry-type` can be `opentelemetry` or `opencensus`.
      # https://github.com/jjti/go-spancheck#extra-start-span-signatures
      #
      # По умолчанию есть три функции создающих спаны
      # Спаны возвращаемые этими функциями будут проверены всегда
      #
      # - go.opentelemetry.io/otel/trace.Tracer.Start:opentelemetry
      # - go.opencensus.io/trace.StartSpan:opencensus
      # - go.opencensus.io/trace.StartSpanWithRemoteParent:opencensus
      #
      # Данная настрока позволяет добавить собственные функции
      #
      # 1. В этих функциях не будут проверяться правила end, set-status, record-error
      #    по причине того что они возвращают спан
      #
      # 2. Спаны возвращаемые ими в месте использования будут подвергнуты проверке на соблюдение
      #    указанных правил
      #
      # ctx := context.Background()
      #
      # ctx, span := observability.StartSpan(ctx, "op") // кастомный стартер
      #
      # // если этот стартер не будет добавлен в настроки то линтер не сообщит об
      # // отсутствии span.End, span.SetStatus и span.RecordError
      # // также непосредственно в самой функции которая возвращает спан
      # // будет issue связанное с отсутствием span.End
      #
      # _, err := http.NewRequestWithContext(ctx, http.MethodGet, "https://github.com", http.NoBody)
      # if err != nil {
      # 	return fmt.Errorf("http.NewRequestWithContext: %w", err)
      # }
      #
      # _ = span
      #
      # return nil

      # Default: []
      extra-start-span-signatures: []
        # - "github.com/amidgo/linter/observability.StartSpan:opentelemetry"
        # - "github.com/user/repo/telemetry/trace.Start:opentelemetry"

    staticcheck:
      # список кодов которые будут исключены из проверки ST1013
      http-status-code-whitelist: []

      # Расширяем дефолтный список аббревиатур
      initialisms:
        [
          "ACL",
          "API",
          "ASCII",
          "ASM",
          "ASN",
          "CPU",
          "CSS",
          "DNS",
          "EOF",
          "GUID",
          "HTML",
          "HTTP",
          "HTTPS",
          "ID",
          "IP",
          "JSON",
          "QPS",
          "RAM",
          "RPC",
          "SLA",
          "SIM",
          "SMTP",
          "SQL",
          "SSH",
          "TCP",
          "TLS",
          "TTL",
          "UDP",
          "UI",
          "GID",
          "UID",
          "UUID",
          "URI",
          "URL",
          "UTF8",
          "VM",
          "XML",
          "XMPP",
          "XSRF",
          "XSS",
          "SIP",
          "RTP",
          "AMQP",
          "DB",
          "TS",
          "YAML",
        ]

      checks:
        # Invalid regular expression.
        # https://staticcheck.dev/docs/checks/#SA1000
        #
        # Проверяет регулярные выражения
        #
        # var invalidRe = regexp.MustCompile("[") // скобка не закрыта, произойдёт паника
        #
        - SA1000

        # Invalid template.
        # https://staticcheck.dev/docs/checks/#SA1001
        #
        # Проверяет некоторые ошибки при работе с template/text template/html
        #
        # tmpl, err := template.New("check").Parse("{{abc-}}")
        # if err != nil {
        # 	panic(err)
        # }
        #
        # _ = tmpl
        - SA1001

        # Invalid format in 'time.Parse'.
        # https://staticcheck.dev/docs/checks/#SA1002
        #
        # Сообщает о невалидных форматах в time.Parse
        #
        # _, _ = time.Parse("123456", "2002-01-01")
        - SA1002

        # Unsupported argument to functions in 'encoding/binary'.
        # https://staticcheck.dev/docs/checks/#SA1003
        #
        # Проверяет тип последнего аргумента функции encoding/binary.Write
        #
        # _ = binary.Write(io.Discard, binary.LittleEndian, chan int(nil))
        - SA1003

        # Suspiciously small untyped constant in 'time.Sleep'.
        # https://staticcheck.dev/docs/checks/#SA1004
        #
        # Проверяет подозрительно малые константы в time.Sleep
        #
        # time.Sleep(1) // пауза в 1 наносекунду несущестенна и выглядит как ошибка
        #
        # Не работает если в time.Sleep передана константа
        #
        # const minSleepTime = 1
        #
        # time.Sleep(minSleepTime)
        #
        - SA1004

        # Invalid first argument to 'exec.Command'.
        # https://staticcheck.dev/docs/checks/#SA1005
        #
        # Сообщает об ошибках при использовании exec.Command
        #
        # НЕ РАБОТАЕТ на exec.CommandContext который является рекомендуемой альтернативой
        #
        # До
        #	_ = exec.Command("ls arg1 arg2") // аргумента переданы в строке через пробел, ошибка
        # После
        #	_ = exec.Command("ls", "arg1", "arg2")
        #
        # Почти бесполезен...
        - SA1005

        # 'Printf' with dynamic first argument and no further arguments.
        # https://staticcheck.dev/docs/checks/#SA1006
        #
        # Обнаруживает вызовы fmt.Printf с динамическим содержимым без дополнительных параметров
        #
        # dynamic := "dynamic text"
        #
        # fmt.Printf(dynamic)
        #
        # govet.printf выполняет ту же самую фукнцию
        # Выключаем
        # - SA1006

        # Invalid URL in 'net/url.Parse'.
        # https://staticcheck.dev/docs/checks/#SA1007
        #
        # Обнаруживает ряд невалидных значений в net/url.Parse
        #
        #	_, _ = url.Parse(":") // невалидное значение
        #
        - SA1007

        # Non-canonical key in 'http.Header' map.
        # https://staticcheck.dev/docs/checks/#SA1008
        #
        # Сообщает о невалидных ключах http.Header
        #
        #	header := make(http.Header)
        # _ = header["foo"] // сырое получение по неканоничному ключу, может промахнутся
        # _ = header.Get("foo") // получение через метод, ключ будет обработан функцией textproto.CanonicalMIMEHeaderKey
        #
        - SA1008

        # '(*regexp.Regexp).FindAll' called with 'n == 0', which will always return zero results.
        # https://staticcheck.dev/docs/checks/#SA1010
        #
        # Вызов (*regexp.Regexp).FindAll в вторым аргументом равным 0 является бессмысленным
        # и всегда будет возвращать 0 результатов
        - SA1010

        # Various methods in the "strings" package expect valid UTF-8, but invalid input is provided.
        # https://staticcheck.dev/docs/checks/#SA1011
        #
        # Сообщает о невалидных аргументах в функциях пакета strings
        #
        # _ = strings.Trim("\x80test\xff", "\xff") // "\xff" не является валидным utf-8
        # если вывести рехультат такого выражения то мы получим test, "\xff" - неизвестным символ
        - SA1011

        # A nil 'context.Context' is being passed to a function, consider using 'context.TODO' instead.
        # https://staticcheck.dev/docs/checks/#SA1012
        #
        # Сообщает об использовании nil значения контекста как аргумента функции
        #
        # Используйте context.Background() или context.TODO()
        #
        # func passContext(context.Context) {}
        #
        # До
        # passContext(nil)
        #
        # После
        # passContext(context.Background())
        # passContext(context.TODO())
        #
        # К сожалению линтер не обрабатывает
        # passContext(context.Context(nil))
        #
        - SA1012

        # 'io.Seeker.Seek' is being called with the whence constant as the first argument, but it should be the second.
        # https://staticcheck.dev/docs/checks/#SA1013
        #
        # Сообщает об ошибке в порядке следования аргументов в методе io.Seeker.Seek
        #
        # До
        #	file.Seek(io.SeekEnd, 0) // сначала должен следовать 0 (offset) и только потом метка (whence)
        # После
        # file.Seek(0, io.SeekEnd)
        #
        - SA1013

        # Non-pointer value passed to 'Unmarshal' or 'Decode'.
        # https://staticcheck.dev/docs/checks/#SA1014
        #
        # Сообщает когда последним аргументов функции не является ссылка
        #
        # data := []byte{}
        #
        # dest := make(map[string]any)
        #
        # До
        # _ = json.Unmarshal(data, dest)
        # После
        # _ = json.Unmarshal(data, &dest) // указатель на map[string]any
        #
        # govet.unmarshal выполняет ту же самую функцию
        #
        # Выключаем
        # - SA1014

        # Using 'time.Tick' in a way that will leak. Consider using 'time.NewTicker', and only use 'time.Tick' in tests, commands and endless functions.
        # https://staticcheck.dev/docs/checks/#SA1015
        #
        # До go 1.23 time.Tick не собирался garbage collector, что могло привести к утечке памяти
        # До
        # select {
        # case <-time.Tick(time.Second):
        # default:
        # }
        #
        # После
        # ticker := time.NewTicker(time.Second)
        #
        # select {
        # case <-ticker.C:
        # default:
        # }
        #
        # Для go 1.23+ не актуален
        #
        - SA1015

        # Trapping a signal that cannot be trapped.
        # https://staticcheck.dev/docs/checks/#SA1016
        #
        # Сообщает о сигналах которые не могут быть отловлены
        #
        # signal.Notify(
        # 	make(chan<- os.Signal, 1),
        #   // данные сигналы никогда не поступают в процесс а обрабатываются ядром ОС напрямую
        # 	syscall.SIGKILL,
        # 	syscall.SIGSTOP,
        #   os.Kill,
        # )
        #
        # Не работает на signal.NotifyContext
        #
        - SA1016

        # Channels used with 'os/signal.Notify' should be buffered.
        # https://staticcheck.dev/docs/checks/#SA1017
        #
        # signal.Notify должен принимать в себя буферизированный канал
        #
        # ch := make(chan os.Signal)
        #
        # signal.Notify(ch, os.Interrupt)
        #
        # govet.sigchanyzer выполняет ту же самую функцию
        #
        # Выключаем
        #
        # - SA1017

        # 'strings.Replace' called with 'n == 0', which does nothing.
        # https://staticcheck.dev/docs/checks/#SA1018
        #
        # Вызов strings.Replace с 0 быссмысленнен
        #
        # _ = strings.Replace("hel lo", " ", "", 0)
        #
        # gocritic.badCall выполняет ту же самую функцию
        #
        # Выключаем
        # - SA1018

        # Using a deprecated function, variable, constant or field.
        # https://staticcheck.dev/docs/checks/#SA1019
        #
        # Обнаруживает использование deprecated функций, констант, пакетом, полей и тд
        #
        # Неправильно
        # import _ "io/ioutil"
        #
        # Правильно
        # import _ "io"
        # import _ "os"
        #
        - SA1019

        # Using an invalid host:port pair with a 'net.Listen'-related function.
        # https://staticcheck.dev/docs/checks/#SA1020
        #
        # Сообщает об ошибках при работе с http.ListenAndServe и http.ListenAndServeTLS
        #
        # http.ListenAndServe("localhost", nil) // невалидный host:port
        #
        - SA1020

        # Using 'bytes.Equal' to compare two 'net.IP'.
        # https://staticcheck.dev/docs/checks/#SA1021
        #
        # Сообщает о сранении net.IP через bytes.Equal
        # userIP := net.ParseIP("192.0.0.1")
        # hostIP := net.ParseIP("192.0.1.1")
        #
        # bytes.Equal(userIP, hostIP)
        #
        # Необходимо использовать метод net.IP.Equal
        # userIP.Equal(hostIP)
        #
        # метод net.IP.Equal содержит код для сравнения ipv4 и ipv6
        # если их сравнивать через bytes.Equal мы получим false по причине разности длин
        #
        - SA1021

        # Modifying the buffer in an 'io.Writer' implementation.
        # https://staticcheck.dev/docs/checks/#SA1023
        #
        # Реализации интерфейса io.Writer не должны модифицировать
        # входящий []byte
        #
        # type WrongWriter struct{}
        #
        # func (WrongWriter) Write(buf []byte) (int, error) {
        # 	buf[0] = 1 // модифицирует входящие данные
        #
        # 	return 0, nil
        # }
        #
        - SA1023

        # A string cutset contains duplicate characters.
        # https://staticcheck.dev/docs/checks/#SA1024
        #
        # Функции strings.Trim(|Left|Right) принимают в себя аргумент cutset
        # он уберёт из результата все символы которые содержаться в этом cutset
        # независимо от их порядка следования
        #
        # соответственно бессмыслено дублировать символы в подобных функциях
        #
        # До
        # _ = strings.Trim("111112345", "11111") // результат: 2345
        # После
        # _ = strings.Trim("111112345", "1") // результат: 2345
        #
        - SA1024

        # It is not possible to use '(*time.Timer).Reset''s return value correctly.
        # https://staticcheck.dev/docs/checks/#SA1025
        #
        # Reset() возвращает true, если таймер был активен, но это не гарантирует, что вы успеете прочитать из канала до его срабатывания.
        #
        # timer := time.NewTimer(time.Hour)
        #
        # if timer.Reset(time.Second) {
        # 	<-timer.C
        # }
        #
        - SA1025

        # Cannot marshal channels or functions.
        # https://staticcheck.dev/docs/checks/#SA1026
        #
        # Невозможно вызвать Marshal на каналах или функциях
        #
        # _, _ = json.Marshal(chan int(nil)) // приведет к ошибке
        #
        # errchkjson выполняет ту же самую фукнцию
        # Только его фукнционал гораздо шире и может проверять так же структур
        #
        # Выключаем
        # - SA1026

        # Atomic access to 64-bit variable must be 64-bit aligned.
        # https://staticcheck.dev/docs/checks/#SA1027
        #
        # Связано с выравниваем чисел на 32 битных платформах
        #
        # govet.atomicalign выполняет ту же самую фукнцию
        #
        # // +build 386 arm armbe mips mipsle ppc s390 sparc riscv
        #
        # package pkg
        #
        # import "sync/atomic"
        #
        # type T struct {
        # 	A int64
        # 	B int32
        # 	C int64
        # }
        #
        # func fn() {
        # 	var v T
        # 	atomic.AddInt64(&v.A, 0)
        # 	atomic.AddInt64(&v.C, 0) //@ diag(`address of non 64-bit aligned field C passed to sync/atomic.AddInt64`)
        # 	atomic.LoadInt64(&v.C)   //@ diag(`address of non 64-bit aligned field C passed to sync/atomic.LoadInt64`)
        # }
        #
        # func fn2(t *T) {
        # 	addr := &t.C
        # 	if true {
        # 		atomic.LoadInt64(addr) //@ diag(`address of non 64-bit`)
        # 	} else {
        # 		_ = addr
        # 	}
        # }
        #
        # Выключаем
        #
        # - SA1027

        # 'sort.Slice' can only be used on slices.
        # https://staticcheck.dev/docs/checks/#SA1028
        #
        # sort.Slice может быть вызвана только для списков
        #
        #
        # notSlice := 1
        # sort.Slice(notSlice, func(i, j int) bool { return true })
        #
        # govet.sortslice выполняет ту же самую фукнцию
        #
        # Выключаем
        # - SA1028

        # Inappropriate key in call to 'context.WithValue'.
        # https://staticcheck.dev/docs/checks/#SA1029
        #
        # Запрещает использовать обычные значения как ключи в context.WithValue
        # ctx = context.WithValue(ctx, "key", "value") // неверно
        #
        # type valueKey struct{}
        # ctx = context.WithValue(ctx, valueKey{}, "value") // верно
        #
        # Это обусловлено тем что для отдельного типа пустой структуры
        # мы сравниваем лишь данные рефлексии для типа
        # а для строк нам необходимо будет сравнить ещё и саму строку
        # context.Context.Value() имеет сложность O(n)
        # Поэтому необходимо по возможности оптимизировать время на отдельную операцию поиска/сравнения
        #
        # revive.context-keys-type выполняет ту же самую фукнцию
        #
        # Выключаем
        # - SA1029

        # Invalid argument in call to a 'strconv' function.
        # Валидирует входные значения в функции strconv
        #
        # strconv.ParseInt("100", 100, 100)
        #
        # Второй аргумент функции - base должен быть 0, 2 <= base <= 36
        # Третий аргумент функциюю - bitSize должен быть 0 <= bitSize <= 64
        #
        # https://staticcheck.dev/docs/checks/#SA1030
        - SA1030

        # Overlapping byte slices passed to an encoder.
        # https://staticcheck.dev/docs/checks/#SA1031
        #
        # Сообщает о ситуации когда в методы encode параметры dst, src указывают на один и тот же фрагмент памяти
        # Это может приводить к нежелательным последствиям в случае если в кодировке
        # один байт может быть кодирован как два
        #
        # src := []byte{}
        # dst := src
        #
        # hex.Encode(dst, src)
        #
        - SA1031

        # Wrong order of arguments to 'errors.Is'.
        # https://staticcheck.dev/docs/checks/#SA1032
        #
        # Обнаруживает неверный порядок аргументов в errors.Is
        #
        # первым аргументом должна идти динамическая переменная
        # а вторым глобальная переменная
        #
        # _, err := os.Open("check")
        # if errors.Is(io.ErrUnexpectedEOF, err) {
        # 	panic(err)
        # }
        #
        - SA1032

        # 'sync.WaitGroup.Add' called inside the goroutine, leading to a race condition.
        # https://staticcheck.dev/docs/checks/#SA2000
        #
        # Вызов sync.WaitGroup.Add в горутинах может приводить к гонкам данных
        # и неопределённому поведению из-за того что мы можем просто не дожаться
        # выполнения такой горутины, ведь вызов wg.Add может попросту не произойти
        # из-за вызова внутри горутины
        #
        # wg := sync.WaitGroup{}
        #
        # go func() {
        # 	wg.Add(1)
        # 	wg.Done()
        # }()
        #
        # wg.Wait()
        #
        # govet.waitgroup выполняет ту же самую функцию
        #
        # Выключаем
        # - SA2000

        # Empty critical section, did you mean to defer the unlock?.
        # https://staticcheck.dev/docs/checks/#SA2001
        # Сообщает об отсутствии кода межджу mu.Lock и mu.Unlock
        # что может свидетельтсвовать о том что мы просто забыли defer
        #
        # До
        # mu := sync.Mutex{}
        #
        # mu.Lock()
        # mu.Unlock() // бессмысленная блокировка ряди блокировки
        #
        # После
        #
        # mu := sync.Mutex{}
        #
        # mu.Lock()
        # defer mu.Unlock() // разблокировка будет выполнена в конце функции
        #
        # gocritic.badCall выполняет ту же самую фукнцию
        #
        # Выключаем
        # - SA2001

        # Called 'testing.T.FailNow' or 'SkipNow' in a goroutine, which isn't allowed.
        # https://staticcheck.dev/docs/checks/#SA2002
        #
        # Вызов t.FailNow, t.SkipNow из не тестовой горутины может привести к нежелательному поведению
        #
        # Дело в том что они вызывают runtime.Goexit который завершает работу текущей горутины
        #
        # Её вызов не из тестовой горутины приведет к завершению теста, но не самой горутины
        #
        # Что может привести к нежелательному поведению
        #
        # govet.testinggoroutine выполняет ту же самую фукнцию
        #
        # Выключаем
        # - SA2002

        # Deferred 'Lock' right after locking, likely meant to defer 'Unlock' instead.
        # https://staticcheck.dev/docs/checks/#SA2003
        #
        # Сообщает о defer mu.Lock после захвата блокировки
        # что зачастую является опечаткой, однако приводит к нежелательному поведению
        #
        #	mu := sync.Mutex{}
        #
        # До
        # mu.Lock()
        # defer mu.Lock() // ошибка, мы не разблокировали мьютекс для повторной блокировки
        #
        # После
        # mu.Lock()
        # defer mu.Unlock() // верно
        #
        # gocritic.badCall выполняет ту же самую фукнцию
        #
        # Выключаем
        # - SA2003

        # 'TestMain' doesn't call 'os.Exit', hiding test failures.
        # https://staticcheck.dev/docs/checks/#SA3000
        #
        # До go 1.15 требовалось явно вызывать os.Exit в функции TestMain по завершению тестов
        #
        # Сейчас же этого не требуется
        #
        # func TestMain(m *testing.M) {
        # 	exitCode := m.Run()
        #   _ = exitCode
        # }
        #
        - SA3000

        # Assigning to 'b.N' in benchmarks distorts the results.
        # https://staticcheck.dev/docs/checks/#SA3001
        #
        # Переопределение b.N недопустимо по причине искажения результатов бенчмарка
        #
        # func Benchmark_Staticcheck(b *testing.B) {
        # 	b.N = 0
        # }
        - SA3001

        # Binary operator has identical expressions on both sides.
        #
        # https://staticcheck.dev/docs/checks/#SA4000
        #         # Обнаруживает подозрительные дублирующиеся выражения
        #        sort.Slice(xs, func(i, j int) bool {
        #             return xs[i].v < xs[i].v // Duplicated index
        #        })
        #
        # gocritic.dupSubExpr выполняет ту же самую функцию
        # revive.constant-logical-expr выполняет ту же самую функцию
        #
        # Выключаем в пользу revive.constant-logical-expr
        # - SA4000

        # '&*x' gets simplified to 'x', it does not copy 'x'.
        # https://staticcheck.dev/docs/checks/#SA4001
        #
        # Конструкции вида &*x могут быть опущены до x так как не дают никакого эффекта
        #
        # До
        # newPtr := &*oldPtr
        #
        # После
        # newPtr := oldPtr
        #
        - SA4001

        # Comparing unsigned values against negative values is pointless.
        # https://staticcheck.dev/docs/checks/#SA4003
        #
        # У числовых типов есть минимальные и максимальные значения
        # Бессмысленно сравнивать int8(digit) > 127 потому что 127 максимальное значение
        # для int8 и нет ничего больше этого значения в рамках типа int8
        #
        # Точно так же быссмысленно сравнивать int8(digt) < -128 так как -128 минимальное значение
        # для типа int8 и никакое другое значение не может быть меньше
        #
        # Работает и на другие числовые типы
        #
        # digit := int8(1)
        #
        # if digit > 127 { // всегда false
        # 	panic("impossible")
        # }
        #
        # if digit < -128 { // всегда false
        # 	panic("impossible")
        # }
        #
        - SA4003

        # The loop exits unconditionally after one iteration.
        # https://staticcheck.dev/docs/checks/#SA4004
        #
        # Сообщает о циклах которые всегда будут завершаться после первой итерации
        #
        # const iterationsCount = 1
        #
        # for range iterationsCount {
        # 	if false {
        # 		panic("impossible")
        # 	}
        #
        # 	break
        # }
        - SA4004

        # Field assignment that will never be observed. Did you mean to use a pointer receiver?.
        # https://staticcheck.dev/docs/checks/#SA4005
        #
        # Сообщает о случаях модификации полей структуры в методах расширения
        # где структура передаётся по значению
        #
        # type User struct {
        # 	Name string
        # }
        #
        # До
        # func (u User) SetName(name string) { // нет эффекта
        # 	u.Name = name
        # }
        #
        # После
        # func (u *User) SetName(name string) {
        #   u.Name = name
        # }
        #
        # revive.modifies-value-receiver Выполняет ту же самую функцию
        #
        # Выключаем
        #
        # - SA4005

        # A value assigned to a variable is never read before being overwritten. Forgotten error check or dead code?.
        # https://staticcheck.dev/docs/checks/#SA4006
        #
        # Сообщает о переменных чьё значение не используется до следующего присваивания
        #
        # _, err := os.ReadFile("myfile") // значение err не используется
        #
        # _, err = os.ReadFile("newfile") // здесь переменная переопределяется так и не будучи использованной с момента инициализации
        # if err != nil {
        # 	panic(err)
        # }
        #
        # ineffassign выполняет ту же самую фукнцию
        # Однако его пул проверок гораздо шире
        #
        # Выключаем
        # - SA4006

        # The variable in the loop condition never changes, are you incrementing the wrong variable?.
        # https://staticcheck.dev/docs/checks/#SA4008
        #
        # Обнаруживает ошибки в цикле-счётчике
        #
        # var j int
        #
        # for i := 0; i < 10; j++ { // инкрементирует не 'i' а 'j'
        # 	panic("check")
        # }
        #
        - SA4008

        # A function argument is overwritten before its first use.
        # https://staticcheck.dev/docs/checks/#SA4009
        #
        # Сообщает об изменении параметра функции до первого использования
        #
        # В этом параметре нет смысла так как его всегда переопределяют
        #
        # До
        # func modifyParam(a int) int {
        # 	a = 100
        #
        # 	return a
        # }
        #
        # После
        # func modifyParam() int { return 100 }
        #
        - SA4009

        # The result of 'append' will never be observed anywhere.
        # https://staticcheck.dev/docs/checks/#SA4010
        #
        # Результат append нигде не используется
        #
        #	orig := make([]byte, 0)
        #
        # orig = append(orig, 1)
        #
        # // ... Далее в коде не используется
        #
        # ineffassign выполняет ту же самую фукнцию
        # Однако его пул проверок гораздо шире
        #
        # Выключаем
        # - SA4010

        # Break statement with no effect. Did you mean to break out of an outer loop?.
        # https://staticcheck.dev/docs/checks/#SA4011
        #
        # Подмечает бесполезные break внутри switch и select внутри циклов
        #
        #
        # for {
        # 	switch {
        # 	case true:
        # 		break // бесполезный break, имеет эффект только на switch
        # 	default:
        # 	}
        #
        # 	select {
        # 	case <-time.After(time.Microsecond):
        # 		break // бесполезный break, имеет эффект только на select
        # 	case <-time.After(time.Hour):
        # 	}
        # }
        #
        #
        # revive.useless-break выполняет ту же самую фукнцию
        # revive.unnecessary-stmt выполняет ту же самую фукнцию
        #
        # Выключаем
        # - SA4011

        # Comparing a value against NaN even though no value is equal to NaN.
        # https://staticcheck.dev/docs/checks/#SA4012
        #
        # Нет смысла сравнивать какое-либо число с NaN
        # результат всегда будет false
        #
        # nanCompared := 100.0
        #
        # if nanCompared == math.NaN() {
        # 	panic("impossible")
        # }
        - SA4012

        # Negating a boolean twice ('!!b') is the same as writing 'b'. This is either redundant, or a typo.
        # https://staticcheck.dev/docs/checks/#SA4013
        #
        #
        # После двойного отрицания любой bool самому себе, поэтому его можно опустить
        #
        # boolean := false
        #
        # if !!boolean {
        # 	panic("useless")
        # }
        - SA4013

        # An if/else if chain has repeated conditions and no side-effects; if the condition didn't match the first time, it won't match the second time, either.
        # https://staticcheck.dev/docs/checks/#SA4014
        #
        # Обнаруживает идентичные условие в ветка if {} else if {}
        #
        # if 10%2 == 0 { // Идентичное условие
        # 	log.Println("Hello World!")
        # } else if 10%2 == 0 { // Идентичное услове
        # 	log.Println("Hello World!")
        # }
        #
        # revive.identical-ifelseif-conditions выполняет ту же самую функцию
        #
        # Выключаем
        # - SA4014

        # Calling functions like 'math.Ceil' on floats converted from integers doesn't do anything useful.
        # https://staticcheck.dev/docs/checks/#SA4015
        #
        # Бесполезно вызывать math.Ceil, math.Floor методы с float которые были получены
        # путём конвертации из int
        #
        # func fn(x int) {
        # 	math.Ceil(float64(x))      //@ diag(`on a converted integer is pointless`)
        # 	math.Floor(float64(x * 2)) //@ diag(`on a converted integer is pointless`)
        # }
        - SA4015

        # Certain bitwise operations, such as 'x ^ 0', do not do anything useful.
        # https://staticcheck.dev/docs/checks/#SA4016
        #
        # Сообщает о бесполезных битовых операциях
        #
        # func fn(x int) {
        # 	println(x | 0)        //@ diag(`x | 0 always equals x`)
        # 	println(x & 0)        //@ diag(`x & 0 always equals 0`)
        # 	println(x ^ 0)        //@ diag(`x ^ 0 always equals x`)
        # 	println((x << 5) | 0) //@ diag(`(x << 5) | 0 always equals (x << 5)`)}
        # }
        #
        #
        - SA4016

        # Discarding the return values of a function without side effects, making the call pointless.
        # https://staticcheck.dev/docs/checks/#SA4017
        #
        # Сообщает об неиспользуемом результате ряда функций стандартной библиотеки
        # вызов таких функций не приводит к изменениям и их вызов может быть убран
        # в случае если значение не используется
        #
        # fmt.Sprint(1) // значение не используется
        # _ = fmt.Sprint(1) // OK, мы присваиваем значение (используем)
        #
        # foo(1, 1) // значение не используется
        # _ = foo(1, 1) // OK, мы присваиваем значение (используем)
        #
        # Линтер работает только на самые простые случаи
        # например сложение двух чисел
        # func foo(a, b int) int { return a + b }
        #
        - SA4017

        # Self-assignment of variables.
        # https://staticcheck.dev/docs/checks/#SA4018
        #
        # Самоприсваивание переменных
        #
        # a := 0
        # a = a // бесполезная операция
        #
        # ineffassign выполняет ту же самую фукнцию
        # Однако он работает на весь спектр проблем
        # с неэффективным присвоением
        #
        # Выключаем
        # - SA4018

        # Multiple, identical build constraints in the same file.
        # https://staticcheck.dev/docs/checks/#SA4019
        #
        #
        # Сообщает о дублях в build декларациях в рамках одного файла
        #
        # //go:build (one || two || three || go1.1) && (three || one || two || go1.1)
        # // +build one two three go1.1
        # // +build three one two go1.1
        #
        #
        - SA4019

        # Unreachable case clause in a type switch.
        # https://staticcheck.dev/docs/checks/#SA4020
        #
        # Сообщает о недостижимых case в type switch
        #
        # type MyReader struct{}
        #
        # func (MyReader) Read(b []byte) (int, error) { return 0, nil }
        #
        # var v any = MyReader{}
        #
        # func main() {
        # 	switch v.(type) {
        # 	case io.Reader:
        #   // Так как v имплементирует io.Reader, а эта
        #   // ветка идёт позже, то она никогда не выполнится
        # 	case MyReader:
        # 	}
        # }
        #
        - SA4020

        # "x = append(y)" is equivalent to "x = y".
        # https://staticcheck.dev/docs/checks/#SA4021
        #
        # x := append(y) безполезен, данныя запись
        # эквивалентна x := y
        #
        # gocritic.badCall выполняет ту же самую фукнцию
        # Однако спектр его работы гораздо шире
        #
        # Выключаем
        # - SA4021

        # Comparing the address of a variable against nil.
        # https://staticcheck.dev/docs/checks/#SA4022
        #
        # Сравнивать указатель от значения с nil бесполезно так как он не может быть равен nil
        #
        # empty := struct{}{}
        #
        # if &empty == nil {
        # 	panic("impossible")
        # }
        #
        # govet.nilness выполняет ту же самую фукнцию
        # Однако спектр его работы гораздо шире
        #
        # Выключаем
        # - SA4022

        # Impossible comparison of interface value with untyped nil.
        # https://staticcheck.dev/docs/checks/#SA4023
        #
        # nil указатель на структуру не равен nil интерфейсам
        # var nilStruct *struct{}
        #
        # if nilStruct == any(nil) {
        # 	panic("impossible")
        # }
        #
        # govet.nilness выполняет ту же самую функцию
        # Однако его функционал гораздо шире
        #
        # Выключаем
        #
        # - SA4023

        # Checking for impossible return value from a builtin function.
        # https://staticcheck.dev/docs/checks/#SA4024
        #
        # cap и len всегда возвращают не отрицательный результат
        #
        # slice := []int{}
        #
        # if cap(slice) < 0 {
        # 	panic("impossible")
        # }
        #
        # if len(slice) < 0 {
        # 	panic("impossible")
        # }
        - SA4024

        # Integer division of literals that results in zero.
        # https://staticcheck.dev/docs/checks/#SA4025
        #
        # Сообщает о статичных численных выражениях которые всегда равны 0
        #
        #	const check = 2 / 3 // по скольку check это int а 2/3 = 0.66 check всегда равна нулю
        - SA4025

        # Go constants cannot express negative zero.
        # https://staticcheck.dev/docs/checks/#SA4026
        #
        # Запрещает присвоение переменным и константам -0.0
        #
        # Особый кейс math.Copysign
        #
        # До
        # negativeZero := -0.0
        #
        # После
        # negativeZero := math.Copysign(0, -1)
        #
        - SA4026

        # '(*net/url.URL).Query' returns a copy, modifying it doesn't change the URL.
        # https://staticcheck.dev/docs/checks/#SA4027
        #
        # Модификация значения (*net/url.URL).Query бесполезна
        #
        # baseURL.Query().Add("key", "value") // не имеет смысла
        #
        # На сырую модификацию не реагирует
        # baseURL.Query()["key"] = []string{}
        #
        - SA4027

        # 'x % 1' is always zero.
        # https://staticcheck.dev/docs/checks/#SA4028
        #
        # Остаток от деления на 1 всегда 0
        #
        # const some = 100
        # _ = some % 1
        #
        - SA4028

        # Ineffective attempt at sorting slice.
        # https://staticcheck.dev/docs/checks/#SA4029
        #
        # sort.IntSlice, sort.StringSlice и так далее
        # это всего лишь типы, они не выполняют полезной работы
        #
        #
        #
        # nums := []int{}
        #
        # До
        # nums = sort.IntSlice(nums)
        # После
        # sort.Sort(sort.IntSlice(nums))
        #
        - SA4029

        # Ineffective attempt at generating random number.
        # https://staticcheck.dev/docs/checks/#SA4030
        #
        # Неэффективная попытка сгенерировать рандомное число
        #
        # _ = rand.Intn(1)
        #
        # rand.Intn возвращает значение не меньшее нуля и не большее входящего числа
        # rand.Intn(1) всегда равен нулю
        - SA4030

        # Checking never-nil value against nil.
        # https://staticcheck.dev/docs/checks/#SA4031
        #
        # Сравнение ненулевого указателя с nil всегда false
        # num := new(int)
        #
        # if num == nil { // бесполезное сравнение
        # 	panic("impossible")
        # }
        #
        # - SA4031

        # Comparing 'runtime.GOOS' or 'runtime.GOARCH' against impossible value.
        # https://staticcheck.dev/docs/checks/#SA4032
        #
        # Сообщает о случаях когда сравнение runtime.GOOS и runtime.GOARCH бесполезно
        #
        #
        # //go:build linux // код будет включен только при сборке под линукс
        #
        # package linter
        #
        # import "runtime"
        #
        # func main() {
        # 	if runtime.GOOS == "darwin" { // всегда false
        # 		panic("impossible")
        # 	}
        # }
        #
        - SA4032

        # Assignment to nil map.
        # https://staticcheck.dev/docs/checks/#SA5000
        #
        # Взаимодействие с заведомо nil map
        #
        # var nilMap map[int]int
        #
        # nilMap[0] = 0
        #
        #
        # govet.nilness выполняет ту же самую функцию, только его функционал гораздо шире
        #
        # Выключаем
        # - SA5000

        # Deferring 'Close' before checking for a possible error.
        # https://staticcheck.dev/docs/checks/#SA5001
        #
        # Обнаруживает defer closer.Close() до обработки ошибки
        # что может повлечь к nil pointer panic
        #
        # До
        # file, err := os.Open("myfile")
        # defer file.Close()
        #
        # if err != nil {
        # 	panic("unexpected error")
        # }
        #
        # После
        # file, err := os.Open("myfile")
        # if err != nil {
        # 	panic("unexpected error")
        # }
        #
        # defer func() { _ = file.Close() }()
        #
        #
        # Не отрабатывает на ананонимные фукнци
        #
        # file, err := os.Open("myfile")
        # defer func() { _ = file.Close() }() // никаких предупреждений
        #
        # if err != nil {
        # 	panic("unexpected error")
        # }
        #
        - SA5001

        # The empty for loop ("for {}") spins and can block the scheduler.
        # https://staticcheck.dev/docs/checks/#SA5002
        #
        # Пустой for {} просто прокручивает цикл
        #
        # revive.empty-block запрещает любой пустой блок
        #
        # Выключаем
        # - SA5002

        # Defers in infinite loops will never execute.
        # https://staticcheck.dev/docs/checks/#SA5003
        #
        # defer в бесконечном цикле никогда не будет выполнен
        #
        # defer panic("unexpected")
        #
        # revive.defer выполняет ту же самую функцию
        # Однако его фукнционал гораздо шире
        #
        # Выключаем
        # - SA5003

        # "for { select { ..." with an empty default branch spins.
        # https://staticcheck.dev/docs/checks/#SA5004
        #
        # select с путой default веткой в бесконечном цикле может его прокручивать
        #
        # for {
        # 	select {
        # 	case <-time.After(time.Second):
        # 	default: бесполезен и только прокручивает цикл
        # 	}
        # }
        - SA5004

        # The finalizer references the finalized object, preventing garbage collection.
        # https://staticcheck.dev/docs/checks/#SA5005
        #
        # Сообщает о случаях когда замыкание переданное в finalizer захватывает переменную
        # для которой предназначен финализатор, что может приводить к утечкам памяти
        # ведь финализатор никогда не выполнится по скольку
        #
        # До тех пор пока доступен foo будет и доступен x
        # по скольку foo доступен до тех пор пока доступен x (из-за Finalier)
        # создаётся замкнутый круг
        #
        #
        # var x *int
        # foo := func(*int) { fmt.Println(x) }
        # runtime.SetFinalizer(x, foo)
        - SA5005

        # Infinite recursive call.
        # https://staticcheck.dev/docs/checks/#SA5007
        #
        # Обнаруживает бесконечную рекурсию
        #
        # func infinity() {
        # 	infinity()
        # }
        #
        # revive.unconditional-recursion выполняет ту же самую функцию
        #
        # Выключаем
        # - SA5007

        # Invalid struct tag.
        # https://staticcheck.dev/docs/checks/#SA5008
        #
        # Валидирует теги структур
        #
        #
        # type T1 struct {
        # 	B int        `foo:""` // @ diag(`duplicate struct tag`)
        # 	C int        `foo:"" bar:""`
        # 	D int        `              json:"-"`
        # 	E int        `              json:"\"`                    // @ diag(`invalid JSON field name`)
        # 	F int        `              json:",omitempty,omitempty"` // @ diag(`duplicate JSON option "omitempty"`)
        # 	G int        `              json:",omitempty,string"`
        # 	H int        `              json:",string,omitempty,string"` // @ diag(`duplicate JSON option "string"`)
        # 	I int        `              json:",foreign"`                 // @ diag(`unknown JSON option "foreign"`)
        # 	J int        `              json:",string"`
        # 	K *int       `              json:",string"`
        # 	L **int      `              json:",string"` // @ diag(`the JSON string option`)
        # 	M complex128 `              json:",string"` // @ diag(`the JSON string option`)
        # 	N int        `              json:"some-name"`
        # 	O int        `              json:"some-name,omitzero,omitempty,nocase,inline,unknown,format:'something,with,commas'"`
        # }
        #
        - SA5008

        # Invalid Printf call.
        # https://staticcheck.dev/docs/checks/#SA5009
        #
        # Реагирует на неверное использование функций форматирования
        #
        # fmt.Sprintf("invalid: %f", "Hello") // %f предназначена для float значений
        #
        # govet.printf выполняет ту же самую функцию
        #
        # Выключаем
        # - SA5009

        # Impossible type assertion.
        # https://staticcheck.dev/docs/checks/#SA5010
        #
        # Сообщает о невозможных приведениях типов
        #
        #
        # type InvalidReader interface {
        # 	Read()
        # }
        #
        # ir := InvalidReader(nil)
        #
        # _, ok := ir.(io.Reader)
        # _ = ok
        #
        # По скольку тип имплементирующий InvalidReader имеет метод Read
        # он никогда не сможет имплементировать io.Reader потому что у io.Reader другая
        # сигнатура метода Read
        #
        - SA5010

        # Possible nil pointer dereference.
        # https://staticcheck.dev/docs/checks/#SA5011
        #
        # В случае если в функции есть разыменование указателя до его проверки на nil
        # и при этом проверка на nil присутствует, сообщает о нарушении
        #
        # func process(x *int) {
        # 	_ = *x
        #
        # 	if x != nil {
        # 		panic("nil")
        # 	}
        # }
        - SA5011

        # Passing odd-sized slice to function expecting even size.
        # https://staticcheck.dev/docs/checks/#SA5012
        #
        # Передача списков с нечетным количеством аргументов в функции
        # где ожидается четное количество аргументов
        #
        #	replaceArgs := []string{"odd"}
        # strings.NewReplacer(replaceArgs...)
        - SA5012

        # Using 'regexp.Match' or related in a loop, should use 'regexp.Compile'.
        # https://staticcheck.dev/docs/checks/#SA6000
        #
        # Использование regexp.Match многократно в цикле неэффективно
        # следует до начала цикла скомпилировать значение с помощью regexp.Compile
        # и далее использовать *regexp.Regexp в цикле
        #
        #
        # const iterationsCount = 100
        #
        # data := make([]byte, 0)
        #
        #
        # До
        # for range iterationsCount {
        # 	_, _ = regexp.Match("pattern", data)
        # }
        #
        # После
        # patternRe, err := regexp.Compile("pattern")
        # if err != nil {
        # 	panic(err)
        # }
        #
        # for range iterationsCount {
        # 	_ = patternRe.Match(data)
        # }
        #
        #
        # Если нам необходимо компилировать паттерн каждый раз заново
        # например если мы итерируемся по массиву строк и используем значение итерации в regexp.Match
        # линтер обработает такой случай и не будет реагировать
        #
        # data := make([]byte, 0)
        #
        # patterns := []string{"pattern1", "pattern2"}
        #
        # for _, pattern := range patterns { // всё в порядке, линтер молчит
        # 	_, _ = regexp.Match(pattern, data)
        # }
        - SA6000

        # Missing an optimization opportunity when indexing maps by byte slices.
        # https://staticcheck.dev/docs/checks/#SA6001
        #
        # В языке есть специальная оптимизация связанная с конвертацией слайса
        # байт до строки при работе с мапой по строковому ключу
        # разберем подробнее на примере
        #
        # storage := make(map[string]struct{})
        #
        # data := []byte{}
        #
        # key := string(data) // для этого ключа произойдёт конвертация и полное копирование байтов в новую строку
        #
        # _ = storage[key]
        # _ = storage[key]
        #
        #
        # _ = storage[string(data)] // в данном случае golang не делает конвертации и копирования данных
        # _ = storage[string(data)] // это специальный случай оптимизации

        - SA6001

        # Storing non-pointer values in 'sync.Pool' allocates memory.
        # https://staticcheck.dev/docs/checks/#SA6002
        #
        # Хранение в sync.Pool значений без указателя вызывает аллокацию
        # сводя на нет смысл использования sync.Pool, который призван снизить количество аллокаций
        #
        # pool := &sync.Pool{}
        # _ = pool
        #
        # // аллоцирует 1024 байта и передаёт по значению
        # pool.Put([1024]byte{})
        #
        # // передаёт по указателю, лишних аллокаций не происходит
        # pool.Put(&[1024]byte{})
        #
        - SA6002

        # Converting a string to a slice of runes before ranging over it.
        # https://staticcheck.dev/docs/checks/#SA6003
        #
        # Итерация по строке уже происходит по символам а не байтам
        # поэтому конвертация до списка рун не требуется
        # к тому же приводит к ненужному копированию
        #
        # name := "amidman"
        #
        # До
        # for _, r := range []rune(name) {
        # 	_ = r
        # }
        #
        # После
        # name := "amidman"
        #
        # for _, r := range name {
        # 	_ = r
        # }
        #
        - SA6003

        # Inefficient string comparison with 'strings.ToLower' or 'strings.ToUpper'.
        # https://staticcheck.dev/docs/checks/#SA6005
        #
        # Вместо сравнения двух строк с приведением их символов
        # к нижнему регистру можно использовать метод strings.EqualFold
        #
        # name1 := "amidman"
        # name2 := "localhost"
        #
        # До
        # if strings.ToLower(name1) == strings.ToLower(name2) {
        # 	panic("inefficient")
        # }
        #
        # После
        # if strings.EqualFold(name1, name2) {
        # 	panic("efficient")
        # }
        #
        - SA6005

        # Using io.WriteString to write '[]byte'.
        # https://staticcheck.dev/docs/checks/#SA6006
        #
        # Использование io.WriteString чтобы звписать []byte
        #
        # Конвертация из []byte в string приводит к нежелательной аллокации
        #
        #	w := new(bytes.Buffer)
        # message := []byte("Hello World!")
        #
        # До
        # _, _ = io.WriteString(w, string(message))
        # После
        # _, _ = w.Write(message)
        #
        - SA6006

        # Defers in range loops may not run when you expect them to.
        # https://staticcheck.dev/docs/checks/#SA9001
        #
        # В случае итерации по каналам defer не будет вызван пока канал не будет закрыт
        #
        # var ch chan int
        # for range ch {
        # 	defer panic("Hello World")
        # }
        #
        # Выглядит как отдельный случай revive.defer
        #
        # revive.defer выполняет ту же самую функцию
        # Однако его функционал гораздо шире
        #
        # Выключаем
        # - SA9001

        # Using a non-octal 'os.FileMode' that looks like it was meant to be in octal.
        # https://staticcheck.dev/docs/checks/#SA9002
        #
        # Для os.FileMode лучше использовать числа в восьмиричной системе счисления
        #
        # До
        # _ = os.Mkdir("testdata", 777) // 777 = 01411, что приведёт к ошибке выполнения os.Mkdir
        # После
        # _ = os.Mkdir("testdata", 0o777) // теперь верно, 0o777 = os.ModePerm
        #
        - SA9002

        # Empty body in an if or else branch.
        # https://staticcheck.dev/docs/checks/#SA9003
        #
        # Пустые блоки в if else бессмысленны
        #
        # if true {
        # } else {
        # }
        #
        # revive.empty-block выполняет ту же самую фукнцию
        #
        # Выключаем
        # - SA9003

        # Only the first constant has an explicit type.
        # https://staticcheck.dev/docs/checks/#SA9004
        #
        # Сообщает о случаях когда только первая константа в блоке имеет пометку о типе
        #
        # type Status string
        #
        # До
        # const (
        # 	StatusError   Status = "error"    // имеет тип Status
        # 	StatusSuccess        = "success"  // имеет тип string
        # )
        #
        # const (
        # 	StatusError   Status = "error"   // имеет тип Status
        # 	StatusSuccess Status = "success" // имеет тип Status
        # )
        #
        - SA9004

        # Trying to marshal a struct with no public fields nor custom marshaling.
        # https://staticcheck.dev/docs/checks/#SA9005
        #
        # Сообщает о попытках вызвать функции маршалинга
        # на структурах без кастомного Marhal - метода
        # и без публичных полей
        #
        # type Unmarshallable struct {
        # 	noPublic string
        # 	fields   string
        # }
        #
        # data, err := json.Marshal(Unmarshallable{})
        # if err != nil {
        # 	panic(err)
        # }
        #
        # println(string(data)) // выведет '{}'
        #
        # errchkjson выполняет ту же самую фукнцию
        #
        # Однако имеет более широкий фукнционал
        #
        # Выключаем
        # - SA9005

        # Dubious bit shifting of a fixed size integer value.
        # https://staticcheck.dev/docs/checks/#SA9006
        #
        # Сообщает о сомнительных битовых операциях связанных со сдвигом
        #
        # smallInt := int8(1)
        # smallInt >>= 8 // сдвиг восьмитового числа на 8 всегда даст 0
        #
        # println(smallInt) // выведет ноль, независимо от начального smallInt
        - SA9006

        # Deleting a directory that shouldn't be deleted.
        # https://staticcheck.dev/docs/checks/#SA9007
        #
        # Сообщает об удалении ряда директорий
        # Проверяет следующие директории
        #
        # os.TempDir
        # os.UserCacheDir
        # os.UserConfigDir
        # os.UserHomeDir
        #
        # Почти нет случаев где было бы корректно удалять эти директории
        # вероятно этот код является следствием ошибки и должен быть исправлен
        #
        # dir := os.TempDir()
        #
        # _ = os.RemoveAll(dir)
        #
        - SA9007

        # 'else' branch of a type assertion is probably not reading the right value.
        # https://staticcheck.dev/docs/checks/#SA9008
        #
        # В случае если мы делаем type-assertion в if else блоке
        # и наше новая переменная затеняет старую
        # то в else блоке будет переменная после type-assertion
        # и будет иметь нулевое значение типа к которому мы пытались привести значение
        #
        # var anything any
        #
        # До
        # if anything, ok := anything.(int); ok {
        # 	panic("unexpected")
        # } else {
        # 	_ = anything // anything имеет тип int, в данном случае со значением равным 0
        # }
        #
        # После
        # var anything any
        #
        # if anythingInt, ok := anything.(int); ok {
        # 	_ = anythingInt
        #
        # 	panic("unexpected")
        # } else {
        # 	_ = anything // anything имеет тип any
        # }
        #
        - SA9008

        # Ineffectual Go compiler directive.
        # https://staticcheck.dev/docs/checks/#SA9009
        #
        # Сообщает о неверно написанных директивах компилятора
        #
        # До
        # // go:embed myfile.txt - допущена ошибка в виде пробела после //
        # var fileData []byte
        #
        # После
        # //go:embed myfile.txt - всё верно, на этапе компиляции переменной будет присвоено значение на этапе компиляции
        # var fileData []byte
        #
        - SA9009

        # https://staticcheck.dev/docs/checks/#ST1000
        # Заставляет писать коменты над пакетом
        # Выключаем
        # - ST1000

        # Dot imports are discouraged.
        # https://staticcheck.dev/docs/checks/#ST1001
        # Запрещает использование dot-import
        #
        # import (
        #   . "fmt" // добавляет все методы в зону видимости без явного обращения к названию пакета
        # )
        #
        # revive.dot-imports выполняет ту же самую функцию
        # Выключаем
        # - ST1001

        # Poorly chosen identifier.
        # https://staticcheck.dev/docs/checks/#ST1003
        #
        # Проверка соблюдения принятых правил относительно названий
        #
        # package snake_case - не должен содержать заглавных букв, нижних подчеркирваний, кроме _test
        #
        # var snake_case int - должен быть snakeCase
        # var SNAKE_CASE int - должен быть snakeCase
        #
        # func fn_7() - должен быть fn7 без нижних подчеркиваний
        #
        - ST1003

        # Incorrectly formatted error string.
        # https://staticcheck.dev/docs/checks/#ST1005
        #
        # Строки в errors.New и fmt.Errorf не должны начинаться с большой буквы
        # или заканчиваться на знаки пунктуации
        #
        # _ = fmt.Errorf("Not found") // НЕВЕРНО // начинается с большой буквы
        # _ = fmt.Errorf("not found.") // НЕВЕРНО // заканчивается на '.'
        #
        # Аналогично для errors.New
        #
        # _ = errors.New("Not found") // НЕВЕРНО // начинается с большой буквы
        # _ = errors.New("not found.") // НЕВЕРНО // заканчивается на '.'
        #
        - ST1005

        # Poorly chosen receiver name.
        # https://staticcheck.dev/docs/checks/#ST1006
        #
        # Запрещает названия self, this, _ для названий структуры в методах расширениях
        #
        # type InvalidReceiver struct{}
        #
        # func (this InvalidReceiver) Hello() {}
        # func (self InvalidReceiver) Bye()   {}
        # func (_ InvalidReceiver) _()        {}
        #
        - ST1006

        # A function's error value should be its last return value.
        # https://staticcheck.dev/docs/checks/#ST1008
        #
        # Если фукнция возвращает error то этот аргумент должен идти последним
        #
        # До
        # func fn1() (error, int) { return nil, 0 }
        #
        # После
        # func fn1() (int, error) { return 0, nil }
        #
        #
        # в отличие от revive.error-return обрабатывает и не реагирует на следующий случай
        #
        # func fn1() (error, bool) { return nil, true }
        #
        # Это может быть полезно для случаев когда мы используем ok pattern
        #
        # err, ok := fn1()
        #
        - ST1008

        # Poorly chosen name for variable of type 'time.Duration'.
        # https://staticcheck.dev/docs/checks/#ST1011
        #
        # В именах переменных типа time.Duration не следует использовать суффиксы
        # обозначающие период времени
        #
        # const durationSeconds = 5 * time.Second
        #
        # revive.time-naming выполняет ту же самую фукнцию
        #
        # Однако обрабатывает больше случаев, например
        #
        # const durationMinutes = 5 * time.Second
        #
        # revive.time-naming сообщит о нарушении
        # staticcheck.ST1011 промолчит
        #
        # Выключаем
        # - ST1011

        # Poorly chosen name for error variable.
        # https://staticcheck.dev/docs/checks/#ST1012
        #
        # Названия глобальных переменных с типом error должны начинаться с err или Err
        #
        # До
        # var canceled = errors.New("canceled")
        # После
        # var errCanceled = errors.New("canceled")
        #
        # errname выполняет ту же самую функцию
        #
        # в отличие от errname распространяется и на не экспортируемые переменные
        #
        # это приводит к дублям однако дополняет недостаток errname
        - ST1012

        # Should use constants for HTTP error codes, not magic numbers.
        # https://staticcheck.dev/docs/checks/#ST1013
        #
        # http.Error(nil, "", 506)         //@ diag(`http.StatusVariantAlsoNegotiates`)
        # http.Redirect(nil, nil, "", 506) //@ diag(`http.StatusVariantAlsoNegotiates`)
        # http.StatusText(506)             //@ diag(`http.StatusVariantAlsoNegotiates`)
        # http.RedirectHandler("", 506)    //@ diag(`http.StatusVariantAlsoNegotiates`)
        #
        # usestdlibvars выполняет ту же самую функцию
        #
        # Однако лучше справляется с обнаружением случаев использования магических чисел а не констант
        #
        # Выключаем
        # - ST1013

        # A switch's default case should be the first or last case.
        # https://staticcheck.dev/docs/checks/#ST1015
        #
        # Запрещает вставлять default в switch куда либо кроме начала или конца
        #
        # Плохо
        # switch {
        # 	case true:
        # 	default:
        # 	case false:
        # }
        #
        # Хорошо
        # switch {
        # default:
        # case true:
        # case false:
        # }
        #
        # Хорошо
        # switch {
        # case true:
        # case false:
        # default:
        # }
        #
        # меня не устраивает что он позволяет делать default первой по порядку
        #
        # revive.enforce-switch-style выполняет ту же функцию
        # Однако он позволяет ставить default только последним
        # и проверяет наличие default ветки в каждом switch case
        #
        # Выключаем
        # - ST1015

        # Use consistent method receiver names.
        # https://staticcheck.dev/docs/checks/#ST1016
        #
        # Сообщает об различных именах в названии переменной структуры в методе расширения
        #
        # type Unconsistent struct{}
        #
        # До
        #
        # // Разное название
        # func (u Unconsistent) Hello() {} // название u
        # func (un Unconsistent) Bye()  {} // название un
        #
        # func (Unconsistent) Unchecked() {} // нет названия, на подобный случай проверка не распространяется
        #
        # После
        #
        # // Одинаковое название
        # func (u Unconsistent) Hello() {} // название u
        # func (u Unconsistent) Bye()  {}  // название u
        #
        # func (Unconsistent) Unchecked() {} // нет названия, на подобный случай проверка не распространяется
        - ST1016

        # Don't use Yoda conditions.
        # https://staticcheck.dev/docs/checks/#ST1017
        #
        # Обнаруживает Yoda style выражения и предлагает заменить на обычные
        # При сравнении переменной с константой сначала идёт переменная и только потом константа
        #
        # До
        # return nil != ptr
        #
        # После
        # return ptr != nil
        #
        # gocritic.yodaStyleExpr выполняет ту же самую фукнцию
        #
        # Выключаем
        # - ST1017

        # Avoid zero-width and control characters in string literals.
        # https://staticcheck.dev/docs/checks/#ST1018
        #
        # Запрещает наличие в строковых литералах невидимых символов
        #
        # Control символы (управляющие символы) - это специальные символы
        # которые не отображаются как обычный текст, а используются для
        # управления устройствами или форматированием.
        # Они происходят из стандарта ASCII и имеют коды от 0 до 31 и 127.
        #
        #
        # // Выглядит как обычная строка, но содержит zero-width space
        # username := "admin​user" // U+200B между admin и user
        #
        # // Визуально не отличимо от "adminuser"
        # fmt.Printf("Username: %s\n", username)
        #
        # // Проверка длины покажет разницу
        # normal := "adminuser"
        # fmt.Printf("Normal length: %d\n", len(normal))    // 8
        # fmt.Printf("Special length: %d\n", len(username)) // 12
        #
        # // Проблемы при сравнении
        # if username == "adminuser" {
        # 	fmt.Println("Match") // Не выполнится!
        # }
        #
        - ST1018

        # Importing the same package multiple times.
        # https://staticcheck.dev/docs/checks/#ST1019
        # Обнаруживает дубликаты импортов под разными названиями
        # import (
        # 	"fmt"
        # 	printing "fmt" // Imported the second time
        # )
        #
        # gocritic.dupImport выполняет ту же самую функцию
        # revive.duplicated-imports выполняет ту же самую функцию
        #
        # Выбор сделан в пользу duplicated-imports
        #
        # Выключаем
        # - ST1019

        # The documentation of an exported function should start with the function's name.
        # https://staticcheck.dev/docs/checks/#ST1020
        #
        # Комментарий экспортируемой фукнции должен начинаться с названия функции
        #
        # До
        # // Say Hello
        # func Hello() {}
        #
        # После
        # // Hello Say Hello
        # func Hello() {}
        #
        #
        # Обрабатывает тестовые функции
        # // Tests the Fun
        # func Test_Fun(t *testing.T) {}
        #
        - ST1020

        # The documentation of an exported type should start with type's name.
        # https://staticcheck.dev/docs/checks/#ST1021
        #
        # Комментарий экспортируемого типа должен начинаться с названия этого типа
        #
        # До
        # // For something
        # type Exported struct{}
        #
        # После
        # // Exported For something
        # type Exported struct{}
        - ST1021

        # The documentation of an exported variable or constant should start with variable's name.
        # https://staticcheck.dev/docs/checks/#ST1022
        #
        # Комментарий экспортируемой глобальной переменной или константы должен начинаться с её названия
        #
        # До
        # // is public variable
        # var Public string
        #
        # После
        # // Public is public variable
        # var Public string
        - ST1022

        # Redundant type in variable declaration.
        # https://staticcheck.dev/docs/checks/#ST1023
        #
        # Предлагает опускать названия типов при создании переменной через var
        # var data []byte = []byte{} // НЕВЕРНО
        # var data = []byte{} // ВЕРНО
        #
        # revive.var-declaration выполняет ту же самую фукнцию
        #
        # Выключаем
        # - ST1023

        # Use plain channel send or receive instead of single-case select.
        # https://staticcheck.dev/docs/checks/#S1000
        #
        # select с одним case бессмысленен
        #
        # ch := make(chan int)
        #
        # До
        # select {
        # case value := <-ch:
        # 	_ = value
        # }
        #
        # После
        # value := <-ch
        # _ = value
        #
        - S1000

        # Replace for loop with call to copy.
        # https://staticcheck.dev/docs/checks/#S1001
        #
        # Для копирования одного []Type в другой следуюет использовать copy(dst, src)
        #
        # src := make([]byte, 0)
        #
        # dst := make([]byte, len(src))
        #
        # До
        # for i := range src {
        # 	dst[i] = src[i]
        # }
        #
        # После
        # copy(dst, src)
        #
        - S1001

        # Omit comparison with boolean constant.
        # https://staticcheck.dev/docs/checks/#S1002
        #
        # Обнаруживает участки кода где условие сравнивается с true или false
        #
        # До
        # if condition == true {
        # 	log.Println("Hello World!")
        # }
        #
        # После
        # if condition {
        #   log.Println("Hello World!")
        # }
        #
        # revive.bool-literal-in-expr выполняет ту же самую фукнцию
        #
        # Выключаем
        # - S1002

        # Replace call to 'strings.Index' with 'strings.Contains'.
        # https://staticcheck.dev/docs/checks/#S1003
        #
        # Сообщает о вызове strings.Index с целью проверки на включение строки подстроки
        #
        # name := "amidman"
        #
        # До
        # if strings.Index(name, "man") == -1 {
        # 	panic("you should use strings.Contains")
        # }
        #
        # После
        # if !strings.Contains(name, "man") {
        # 	panic("you right")
        # }
        #
        - S1003

        # Replace call to 'bytes.Compare' with 'bytes.Equal'.
        # https://staticcheck.dev/docs/checks/#S1004
        #
        # Для сравнения двух []byte необходимо использовать bytes.Equal
        # а не сравнивать результат bytes.Compare с 0
        #
        # data1, data2 := make([]byte, 0), make([]byte, 0)
        #
        # До
        # if bytes.Compare(data1, data2) == 0 {
        # 	panic("should use bytes.Equal")
        # }
        #
        # После
        # if bytes.Equal(data1, data2) {
        # 	panic("good")
        # }
        #
        - S1004

        # Drop unnecessary use of the blank identifier.
        # https://staticcheck.dev/docs/checks/#S1005
        #
        # Сообщает о случаях когда пустой идентификатор _ может быть опущен
        #
        # storage := make(map[int]struct{})
        #
        # До
        # v, _ := storage[0]
        #
        # После
        # v := storage[0]
        #
        - S1005

        # Use "for { ... }" for infinite loops.
        # https://staticcheck.dev/docs/checks/#S1006
        #
        # Для бесконечных циклов следует использовать for { ... }
        #
        # for true {	} // Неправильно
        # for {}        // Правильно
        #
        - S1006

        # Simplify regular expression by using raw string literal.
        # https://staticcheck.dev/docs/checks/#S1007
        #
        # Регулярные выражения могут быть упрощены с использованием '`'
        #
        # До
        # _, _ = regexp.Compile("\\A(\\w+) profile: total \\d+\\n\\z")
        #
        # После
        # _, _ = regexp.Compile(`\A(\w+) profile: total \d+\n\z`)
        #
        - S1007

        # Simplify returning boolean expression.
        # https://staticcheck.dev/docs/checks/#S1008
        #
        # Упрощает возврат булевы выражения
        #
        # condition := 10%2 == 0
        #
        # До
        # if condition {
        # 	return true
        # }
        #
        # return false
        #
        # После
        #
        # return condition
        #
        - S1008

        # Omit redundant nil check on slices, maps, and channels.
        # https://staticcheck.dev/docs/checks/#S1009
        #
        # Сообщает о необходимости опускать проверку map, slice, chan на nil при условии проверки на длину
        # у подобных типов len(nil) == 0
        #
        #	var slice []byte
        #
        # До
        # if slice != nil && len(slice) != 0 {
        # 	panic("nil slice")
        # }
        #
        # После
        # if len(slice) != 0 {
        #   panic("empty slice")
        # }
        #
        - S1009

        # Omit default slice index.
        # https://staticcheck.dev/docs/checks/#S1010
        #
        # slice[:len(slices)] равен slice[:]
        #
        # var slice []byte
        #
        # До
        # _ = slice[0:len(slice)]
        #
        # После
        # _ = slice[0:]
        #
        - S1010

        # Use a single 'append' to concatenate two slices.
        # https://staticcheck.dev/docs/checks/#S1011
        #
        # Конкатенация двух []Type может быть заменена на один append
        #
        # src := make([]byte, 0)
        # dst := make([]byte, 0)
        #
        # До
        # for i := range src {
        # 	dst = append(dst, src[i])
        # }
        #
        # После
        # dst = append(dst, src...)
        #
        - S1011

        # Replace 'time.Now().Sub(x)' with 'time.Since(x)'.
        # https://staticcheck.dev/docs/checks/#S1012
        # time.Now().Sub(x) должно быть заменено на time.Since(x)
        #
        # hourAgo := time.Now().Add(-time.Hour)
        #
        # До
        # _ = time.Now().Sub(hourAgo)
        #
        # После
        # _ = time.Since(hourAgo)
        #
        - S1012

        # Use a type conversion instead of manually copying struct fields.
        # https://staticcheck.dev/docs/checks/#S1016
        #
        # Структуры с идентичными полями могут быть конвертированы напрямую
        #
        # type Original struct {
        # 	Name string
        # }
        #
        # type Another struct {
        # 	Name string
        # }
        #
        # var original Original
        #
        # До
        # _ = Another{
        # 	Name: original.Name,
        # }
        #
        # После
        # _ = Another(original)
        #
        - S1016

        # Replace manual trimming with 'strings.TrimPrefix'.
        # https://staticcheck.dev/docs/checks/#S1017
        #
        # Обнаруживает ручное "обрезание" строк
        #
        # name := "amidman"
        # prefix := "amid"
        #
        # До
        # if strings.HasPrefix(name, prefix) {
        # 	name = name[len(prefix):]
        # }
        #
        # После
        #
        # name = strings.TrimPrefix(name, prefix)
        #
        - S1017

        # Use "copy" for sliding elements.
        # https://staticcheck.dev/docs/checks/#S1018
        #
        # Копирование в рамках одного и того же списка можно заменить с цикла на copy
        #
        # const offset = 5
        #
        # bs := []byte("eman name")
        #
        # До
        # for i := range len("name") {
        # 	bs[i] = bs[offset+i]
        # }
        #
        # После
        # copy(bs[:len("name")], bs[offset:])
        #
        # println(string(bs)) // выведет "name naem"
        #
        - S1018

        # Simplify "make" call by omitting redundant arguments.
        # https://staticcheck.dev/docs/checks/#S1019
        #
        # Следует упрощать make вызовы где это возможно
        #
        # До
        # _ = make([]byte, 0, 0) // capacity является необязательным параметром, передавать 0 бессмысленно
        # После
        # _ = make([]byte, 0)
        #
        - S1019

        # Omit redundant nil check in type assertion.
        # https://staticcheck.dev/docs/checks/#S1020
        #
        # Если интерфейс может быть приведен к какому либо типу он не может быть равен nil
        #
        # anything := getAny()
        #
        # До
        # if _, ok := anything.(*int); ok && anything != nil {
        # 	panic("can be simplier")
        # }
        #
        # После
        #
        # anything := getAny()
        #
        # if _, ok := anything.(*int); ok {
        # 	panic("simple")
        # }
        #
        - S1020

        # Merge variable declaration and assignment.
        # https://staticcheck.dev/docs/checks/#S1021
        #
        # Сообщает о раздельных блоках объявления и немедленного присвоения значений переменных
        #
        # До
        # var x int
        # x = 1
        #
        # После
        # x := 1
        #
        - S1021

        # Omit redundant control flow.
        # https://staticcheck.dev/docs/checks/#S1023
        #
        # Сообщает о break в конце switch case который вполне можно опустить
        # Сообщает о return в конце функции который вполне можено опустить
        #
        # func bar() {
        # 	switch {
        # 	case 10%2 == 0:
        # 		log.Println("YES YES YES")
        #
        # 		break // можно опустить
        # 	case 15%5 == 0:
        # 		log.Println("NO NO NO")
        #
        # 		break // можно опустить
        # 	default:
        # 	}
        #
        # 	return // можно опустить
        # }
        #
        # revive.unnecessary-stmt выполняет ту же самую фукнцию
        #
        # Выключаем
        # - S1023

        # Replace 'x.Sub(time.Now())' with 'time.Until(x)'.
        # https://staticcheck.dev/docs/checks/#S1024
        #
        # Следует использовать time.Until вместо time.Time.Sub(time.Now())
        #
        # hourLater := time.Now().Add(time.Hour)
        #
        # До
        # _ = hourLater.Sub(time.Now())
        #
        # После
        # _ = time.Until(hourLater)
        #
        - S1024

        # Don't use 'fmt.Sprintf("%s", x)' unnecessarily.
        # https://staticcheck.dev/docs/checks/#S1025
        #
        # Является переключателем для линтеров sprint1 и strconcat
        # Без него линтеры работать не будут
        # До
        # _ = fmt.Sprint("format")
        # После
        # _ = "format"
        #
        # gocritic.redundantSprint выполняет ту же самую фукнцию
        #
        # Однако распространяется и на fmt.Stringer
        #
        # Выключаем
        # - S1025

        # Simplify error construction with 'fmt.Errorf'.
        # https://staticcheck.dev/docs/checks/#S1028
        #
        # Предлагает заменить
        # _ = errors.New(fmt.Sprintf("my %d format", 0))
        # На
        # _ = fmt.Errorf("my %d format", 0)
        #
        # revive.errorf выполняет ту же самую функцию
        #
        # Выключаем
        # - S1028

        # Range over the string directly.
        # https://staticcheck.dev/docs/checks/#S1029
        #
        # Итерация по строке уже происходит по символам а не байтам
        # поэтому конвертация до списка рун не требуется
        # к тому же приводит к ненужному копированию
        #
        # name := "amidman"
        #
        # До
        # for _, r := range []rune(name) {
        # 	_ = r
        # }
        #
        # После
        # name := "amidman"
        #
        # for _, r := range name {
        # 	_ = r
        # }
        #
        # staticcheck.SA6003 выполняет ту же самую фукнцию
        #
        # Выключаем
        # - S1029

        # Use 'bytes.Buffer.String' or 'bytes.Buffer.Bytes'.
        # https://staticcheck.dev/docs/checks/#S1030
        #
        # Сообщает об конвертации результата bytes.Buffer.String в []byte
        # Сообщает об конвертации результата bytes.Buffer.Bytes  в string
        #
        #
        # buf := new(bytes.Buffer)
        #
        # До
        # _ = []byte(buf.String())
        # _ = string(buf.Bytes())
        #
        # После
        # _ = buf.Bytes()
        # _ = buf.String()
        #
        - S1030

        # Omit redundant nil check around loop.
        # https://staticcheck.dev/docs/checks/#S1031
        #
        # Проверка на nil для итерации по map и slice бессмысленна
        # если slice или map == nil итерация даже не будет начата
        #
        # var (
        # 	nilSlice []byte
        # 	nilMap   map[int]int
        # )
        #
        # До
        # if nilSlice != nil {
        # 	for range nilSlice {
        # 		panic("redundant")
        # 	}
        # }
        #
        # if nilMap != nil {
        # 	for range nilMap {
        # 		panic("redundant")
        # 	}
        # }
        #
        # После
        # for range nilSlice {
        # 	panic("ok")
        # }
        #
        # for range nilMap {
        # 	panic("ok")
        # }
        #
        - S1031

        # Use 'sort.Ints(x)', 'sort.Float64s(x)', and 'sort.Strings(x)'.
        # https://staticcheck.dev/docs/checks/#S1032
        #
        # Используйте sort.Ints(x) вместо sort.Sort(sort.IntSlice(x))
        #
        # intSlice := []int{1, 3, 2}
        # До
        # sort.Sort(sort.IntSlice(intSlice))
        #
        # После
        # sort.Ints(intSlice)
        #
        # Распространяется на sort.Float64s, sort.Strings
        #
        - S1032

        # Unnecessary guard around call to "delete".
        # https://staticcheck.dev/docs/checks/#S1033
        #
        # Перед удалением ключа из map не нужно проверять его на наличие в map
        #
        # var nilMap map[int]int
        #
        # До
        # if _, ok := nilMap[0]; ok {
        # 	delete(nilMap, 0)
        # }
        #
        # После
        #	delete(nilMap, 0)
        #
        - S1033

        # Use result of type assertion to simplify cases.
        # https://staticcheck.dev/docs/checks/#S1034
        # Обнаруживает переключатели типа, которые могут извлечь выгоду из предложения защиты типа с переменной
        # staticcheck.S1034 выполняет ту же самую функцию
        #
        # var reader io.Reader
        #
        # До
        # switch reader.(type) {
        # case *bytes.Buffer: // reader всё ещё имеет тип io.Reader, необходимо дополнительно кастить тип
        # 	_, ok := reader.(*bytes.Buffer)
        # 	_ = ok
        # case *strings.Reader: // reader всё ещё имеет тип io.Reader, необходимо дополнительно кастить тип
        # 	_, ok := reader.(*strings.Reader)
        # 	_ = ok
        # }
        #
        # После
        # switch reader := reader.(type) {
        # case *bytes.Buffer:
        # 	var _ *bytes.Buffer = reader // reader имеет тип *bytes.Buffer
        # case *strings.Reader:
        # 	var _ *strings.Reader = reader // reader имеет тип *strings.Reader
        # }
        #
        - S1034

        # Redundant call to 'net/http.CanonicalHeaderKey' in method call on 'net/http.Header'.
        # https://staticcheck.dev/docs/checks/#S1035
        #
        # Нет никакой необходимости передавать в функции
        # http.Header.Add
        # http.Header.Get
        # http.Header.Set
        # http.Header.Del
        #
        # Значения фукнции http.CanonicalHeaderKey, метод в любом случае вызовет
        # функцию преобразования ключа внутри себя
        #
        # const (
        # 	key   = "X-Key"
        # 	value = "value"
        # )
        #
        # header := make(http.Header)
        #
        # До
        # _ = header.Get(http.CanonicalHeaderKey(key))
        #
        # header.Add(http.CanonicalHeaderKey(key), value)
        # header.Set(http.CanonicalHeaderKey(key), value)
        # header.Add(http.CanonicalHeaderKey(key), value)
        #
        # После
        # _ = header.Get(key)
        #
        # header.Add(key, value)
        # header.Set(key, value)
        # header.Add(key, value)
        - S1035

        # Unnecessary guard around map access.
        # https://staticcheck.dev/docs/checks/#S1036
        #
        # Ненужные проверки на наличие ключа в map которых можно избежать
        #
        #
        # const key = "key"
        #
        # mapOfSlices := make(map[string][]int)
        #
        # До
        # if _, ok := mapOfSlices[key]; ok {
        # 	mapOfSlices[key] = append(mapOfSlices[key], 0)
        # } else {
        # 	mapOfSlices[key] = []int{0}
        # }
        #
        # После
        # mapOfSlices[key] = append(mapOfSlices[key], 0)
        #
        # mapOfInts := make(map[string]int)
        #
        # До
        # if _, ok := mapOfInts[key]; ok {
        # 	mapOfInts[key] += 1
        # } else {
        # 	mapOfInts[key] = 1
        # }
        #
        # После
        # mapOfInts[key] += 1
        #
        - S1036

        # Elaborate way of sleeping.
        # https://staticcheck.dev/docs/checks/#S1037
        #
        # Усложненный способ уснуть
        #
        # Сообщает об одинарных select где аргументом является <-time.After
        #
        # select {
        # case <-time.After(time.Second):
        # }
        #
        # Выглядит как специфический случай S1000 только специально для <-time.After
        #
        # staticcheck.S1000 выполняет ту же самую фукнцию
        # Однако работает на любые select с одной веткой
        #
        # Выключаем
        # - S1037

        # Unnecessarily complex way of printing formatted string.
        # https://staticcheck.dev/docs/checks/#S1038
        #
        # Предлагает заменить fmt.Print(fmt.Sprintf(...)) на fmt.Printf
        #
        # До
        # fmt.Print(fmt.Sprintf("Hello %d\n", 0))
        #
        # После
        # fmt.Printf("Hello %d\n", 0)
        #
        - S1038

        # Unnecessary use of 'fmt.Sprint'.
        # https://staticcheck.dev/docs/checks/#S1039
        #
        # Использование fmt.Sprint(string) равносильно string
        #
        # До
        # _ = fmt.Sprint("format")
        # После
        # _ = "format"
        #
        # gocritic.redundantSprint выполняет ту же самую фукнцию
        #
        # Однако распространяется и на fmt.Stringer
        #
        # Выключаем
        # - S1039

        # Type assertion to current type.
        # https://staticcheck.dev/docs/checks/#S1040
        #
        #
        # Каст итерфейса к типу которым он уже является
        #
        # var r io.Reader
        #
        # _, _ = r.(io.Reader) // r уже io.Reader в этом type-assertion нет смысла
        #
        # Исключением ялвяется когда io.Reader равняется nil
        #
        # r := io.Reader(nil)
        #
        # _, ok := r.(io.Reader)
        # println(ok) // выведет false потому что r == nil
        #
        #
        # var r io.Reader = (*os.File)(nil)
        #
        # _, ok := r.(io.Reader)
        # println(ok) // выведет true, потому что под io.Reader скрывается тип *os.File пусть он и не на что не ссылается
        #
        - S1040

        # ОСТОРОЖНО!!!
        # Правила с префиксом QF вносят изменения в код если включен --fix флаг
        # ОСТОРОЖНО!!!

        # Apply De Morgan's law.
        # https://staticcheck.dev/docs/checks/#QF1001
        #
        # Упрощает булевы выражения, применяя законы де Моргана
        #
        # var a, b, c bool
        # var e, f, g int
        # var h, i float64
        #
        # До
        # _ = !(a && b && (!c || e > f) && g == f) // vможно упростить
        #
        # После
        # _ = !a || !b || c && e <= f || g != f
        #
        - QF1001

        # Convert untagged switch to tagged switch.
        # https://staticcheck.dev/docs/checks/#QF1002
        #
        # Сообщает о случаях где мы может использовать тегированный switch
        # То есть switch по значению
        #
        # До
        # switch {
        # case x == 1 || x == 2, x == 3:
        # case x == 4:
        # default:
        # }
        #
        # После
        # switch x {
        # case 1, 2, 3:
        # case 4:
        # default:
        # }
        #
        - QF1002

        # Convert if/else-if chain to tagged switch.
        # https://staticcheck.dev/docs/checks/#QF1003
        #
        # Преобразовывает if else if в switch
        #
        # x := 10
        #
        # До
        # if x == 10 {
        # } else if x == 15 {
        # }
        #
        # После
        # switch x {
        # case 10:
        # case 15:
        # }
        #
        - QF1003

        # Use 'strings.ReplaceAll' instead of 'strings.Replace' with 'n == -1'.
        # https://staticcheck.dev/docs/checks/#QF1004
        #
        # Заменяет использование strings.Replace с n == -1 на strings.ReplaceAll
        #
        # До
        # _ = strings.Replace("manman", "man", "amid", -1)
        #
        # После
        # _ = strings.ReplaceAll("manman", "man", "amid")
        #
        #
        # gocritic.wrapperFunc выполняет ту же самую функцию
        # Однако его фукнционал гораздо шире
        #
        # Выключаем
        # - QF1004

        # Expand call to 'math.Pow'.
        # https://staticcheck.dev/docs/checks/#QF1005
        #
        # Заменяет выхов math.Pow(x, 2) на x * x
        #
        # До
        #	_ = math.Pow(10, 2)
        # После
        # _ = float64(10 * 10)
        #
        - QF1005

        # Lift 'if'+'break' into loop condition.
        # https://staticcheck.dev/docs/checks/#QF1006
        #
        # Исправляет бесконечный цикл с вложенным условием на for condition {}
        #
        # До
        # for {
        # 	if 10%2 == 1 {
        # 		break
        # 	}
        # }
        #
        # После
        # for 10%2 != 1 {...}
        - QF1006

        # Merge conditional assignment into variable declaration.
        # https://staticcheck.dev/docs/checks/#QF1007
        #
        # Если значение переменной bool инициализируется по условию
        # замещает условие на прямое присвоение значения
        #
        # До
        # condition := false
        #
        # if true {
        # 	condition = true
        # }
        #
        # После
        # condition := true
        #
        - QF1007

        # Omit embedded fields from selector expression.
        # https://staticcheck.dev/docs/checks/#QF1008
        #
        # Обязывает использовать поля и методы вложенных структур напрямую
        #
        # type Child struct {
        # 	Name string
        # }
        #
        # type Parent struct{ Child }
        #
        # parent := new(Parent)
        #
        # До
        # _ = parent.Child.Name
        #
        # После
        # _ = parent.Name
        #
        - QF1008

        # Use 'time.Time.Equal' instead of '==' operator.
        # https://staticcheck.dev/docs/checks/#QF1009
        #
        # Обязывает сравнивать time.Time с помощью метода time.Time.Equal
        #
        # До
        #	_ = time.Now() == time.Now()
        # После
        # _ = time.Now().Equal(time.Now())
        #
        # revive.time-equal выполняет ту же функцию
        #
        # Выключаем
        # - QF1009

        # Convert slice of bytes to string when printing it.
        # https://staticcheck.dev/docs/checks/#QF1010
        #
        # Перед выводом в stdout []byte необходимо конвертировать его в строку
        #
        # До
        # log.Println([]byte{1, 2})
        #
        # После
        # log.Println(string([]byte{1, 2}))
        #
        # Так же работает и на fmt.Sprint
        # До
        # _ = fmt.Sprint([]byte{})
        #
        # После
        # _ = fmt.Sprint(string([]byte{}))
        #
        - QF1010

        # Omit redundant type from variable declaration.
        # https://staticcheck.dev/docs/checks/#QF1011
        #
        # Предлагает опускать названия типов при создании переменной через var
        # var data []byte = []byte{} // НЕВЕРНО
        # var data = []byte{} // ВЕРНО
        #
        # revive.var-declaration выполняет ту же самую фукнцию
        #
        # Выключаем
        # - QF1011

        # Use 'fmt.Fprintf(x, ...)' instead of 'x.Write(fmt.Sprintf(...))'.
        # https://staticcheck.dev/docs/checks/#QF1012
        #
        # Более эффективно и идиоматично использовать fmt.Fprintf(writer, ...)
        # вместо writer.Write([]byte(fmt.Sprintf(...)))
        #
        # До
        # _, _ = out.WriteString(fmt.Sprintf(format, name))
        # _, _ = out.Write([]byte(fmt.Sprintf("Hello %s", name)))
        #
        # После
        # _, _ = fmt.Fprintf(out, format, name)
        #
        #
        # Не работает на fmt.Appendf
        # такая запись действительно имеет смысл
        #
        # _, _ = out.Write(fmt.Appendf(make([]byte, 0), format, name)) // не сработает по причине того что имеет начальный буфер
        #
        # gocritic.preferFprint выполняет ту же самую фукнцию
        #
        # Выключаем
        # - QF1012

    tagalign:
      # Align and sort can be used together or separately.
      #
      # Whether enable align. If true, the struct tags will be aligned.
      # E.g.:
      # type FooBar struct {
      #     Bar    string `json:"bar" validate:"required"`
      #     FooFoo int8   `json:"foo_foo" validate:"required"`
      # }
      # will be formatted to:
      # type FooBar struct {
      #     Bar    string `json:"bar"     validate:"required"`
      #     FooFoo int8   `json:"foo_foo" validate:"required"`
      # }
      # Default: true.
      align: true

      # Whether enable tags sort.
      # If true, the tags will be sorted by name in ascending order.
      # E.g.: `xml:"bar" json:"bar" validate:"required"` -> `json:"bar" validate:"required" xml:"bar"`.
      # Default: true
      sort: true

      # Specify the order of tags, the other tags will be sorted by name.
      # This option will be ignored if `sort` is false.
      # Default: []
      order:
        - json
        - yaml
        - yml
        - toml
        - mapstructure
        - binding
        - validate

      # Whether enable strict style.
      # In this style, the tags will be sorted and aligned in the dictionary order,
      # and the tags with the same name will be aligned together.
      # Note: This option will be ignored if 'align' or 'sort' is false.
      # Default: false
      strict: false

    tagliatelle:
      # Checks the struct tag name case.
      case:
        # Defines the association between tag name and case.
        # Any struct tag name can be used.
        # Supported string cases:
        # - `camel`
        # - `pascal`
        # - `kebab`
        # - `snake`
        # - `upperSnake`
        # - `goCamel`
        # - `goPascal`
        # - `goKebab`
        # - `goSnake`
        # - `upper`
        # - `lower`
        # - `header`
        rules:
          json: snake
          yaml: snake
          xml: snake
          toml: snake
          bson: snake
          avro: snake
          mapstructure: snake

          env: upperSnake
          envconfig: upperSnake

          # позволяет настроить любой свой тег
          # my_personal_tag: snake

        # Defines the association between tag name and case.
        # Important: the `extended-rules` overrides `rules`.
        # Default: empty
        # extended-rules:
        # json:
        # Supported string cases:
        # - `camel`
        # - `pascal`
        # - `kebab`
        # - `snake`
        # - `upperSnake`
        # - `goCamel`
        # - `goPascal`
        # - `goKebab`
        # - `goSnake`
        # - `header`
        # - `lower`
        # - `header`
        #
        # Required
        # case: snake
        # Adds 'AMQP', 'DB', 'GID', 'RTP', 'SIP', 'TS' to initialisms,
        # and removes 'LHS', 'RHS' from initialisms.
        # Default: false
        # extra-initialisms: true
        # Defines initialism additions and overrides.
        # Default: empty
        # initialism-overrides:
        # DB: true # add a new initialism
        # LHS: false # disable a default initialism.
        # ...

        # Uses the struct field name to check the name of the struct tag.
        # Default: false
        #
        # Флаг использования названия поля при проверке тегов
        #
        # type Tagged struct {
        # 	Name string `json:"user_name"` // неверно, название поля Name, теги должны называться name
        # }
        #
        # type Tagged struct {
        # 	UserName string `json:"user_name"` // верно
        # }
        #
        # type Tagged struct {
        # 	Name string `json:"name"` // верно
        # }
        #
        # Выключаем
        use-field-name: false
        # The field names to ignore.
        # Default: []
        ignored-fields: []
        # Overrides the default/root configuration.
        # Default: []
        overrides: []
          # The package path (uses `/` only as a separator).
          # Required
          #
          # Переопределить правила для определённых пакетов
          # - pkg: foo/bar
          # Default: empty or the same as the default/root configuration.
          # rules:
          # json: snake
          # xml: pascal
          # Default: empty or the same as the default/root configuration.
          # extended-rules:
          # Same options as the base `extended-rules`.
          # Default: false (WARNING: it doesn't follow the default/root configuration)
          # use-field-name: true
          # The field names to ignore.
          # Default: [] or the same as the default/root configuration.
          # ignored-fields:
          # - Bar
          # - Foo
          # Ignore the package (takes precedence over all other configurations).
          # Default: false
          # Игнорировать пакет для проверки
          # ignore: true

    testifylint:
      # Enable all checkers (https://github.com/Antonboom/testifylint#checkers).
      # Default: false
      enable-all: false
      # Disable checkers by name
      # (in addition to default
      #   suite-thelper
      # ).
      disable: []
      # Disable all checkers (https://github.com/Antonboom/testifylint#checkers).
      # Default: false
      disable-all: true
      # Enable checkers by name
      # (in addition to default
      #   blank-import, bool-compare, compares, contains, empty, encoded-compare, equal-values, error-is-as, error-nil,
      #   expected-actual, go-require, float-compare, formatter, len, negative-positive, nil-compare, regexp, require-error,
      #   suite-broken-parallel, suite-dont-use-pkg, suite-extra-assert-call, suite-subtest-run, suite-method-signature,
      #   useless-assert
      # ).
      enable:
        # https://github.com/Antonboom/testifylint?tab=readme-ov-file#blank-import
        # Запрещает _ blank импорты пакетов testify
        #
        # ❌
        # import (
        #     "testing"
        #
        #     _ "github.com/stretchr/testify"
        #     _ "github.com/stretchr/testify/assert"
        #     _ "github.com/stretchr/testify/http"
        #     _ "github.com/stretchr/testify/mock"
        #     _ "github.com/stretchr/testify/require"
        #     _ "github.com/stretchr/testify/suite"
        # )
        #
        # ✅
        # import (
        #     "testing"
        # )
        #
        # Может показаться что revive.blank-imports делает то же самое
        # однако он игнорирует тестовые пакеты, что делает testifylint.blank-import крайне полезным
        #
        - blank-import

        # https://github.com/Antonboom/testifylint?tab=readme-ov-file#bool-compare
        # Валидирует сравнения boolean переменных
        #
        # ❌
        # assert.Equal(t, false, result)
        # assert.EqualValues(t, false, result)
        # assert.Exactly(t, false, result)
        # assert.NotEqual(t, true, result)
        # assert.NotEqualValues(t, true, result)
        # assert.False(t, !result)
        # assert.True(t, result == true)
        # // And other variations...
        #
        # ✅
        # assert.True(t, result)
        # assert.False(t, result)
        #
        - bool-compare

        # https://github.com/Antonboom/testifylint?tab=readme-ov-file#compares
        # Валидирует сравнения значений
        #
        # ❌
        # assert.True(t, a == b)
        # assert.True(t, a != b)
        # assert.True(t, a > b)
        # assert.True(t, a >= b)
        # assert.True(t, a < b)
        # assert.True(t, a <= b)
        # assert.False(t, a == b)
        # // And so on...
        #
        # ✅
        # assert.Equal(t, a, b)
        # assert.NotEqual(t, a, b)
        # assert.Greater(t, a, b)
        # assert.GreaterOrEqual(t, a, b)
        # assert.Less(t, a, b)
        # assert.LessOrEqual(t, a, b)
        #
        - compares

        # https://github.com/Antonboom/testifylint?tab=readme-ov-file#contains
        # Предлагает заменить .True(strings.Contains(expected, "contains")) на .Contains(expecteed, "contains")
        #
        # X
        # assert.True(t, strings.Contains(a, "abc123"))
        # assert.False(t, !strings.Contains(a, "abc123"))
        # assert.False(t, strings.Contains(a, "abc123"))
        # assert.True(t, !strings.Contains(a, "abc123"))
        # assert.Contains(t, arr, 1, 2)
        # assert.NotContains(t, arr, 1, 2)
        #
        # ✅
        # assert.Contains(t, a, "abc123")
        # assert.NotContains(t, a, "abc123")
        # assert.Subset(t, arr, 1, 2)
        # assert.NotSubset(t, arr, 1, 2)
        #
        - contains

        # https://github.com/Antonboom/testifylint?tab=readme-ov-file#empty
        #
        # для проверки длины массивов и сравнения пустых строк есть специальные
        # функции Empty, NotEmpty
        #
        # ❌
        # assert.Len(t, arr, 0)
        # assert.Zero(t, str)
        # assert.Zero(t, len(arr))
        # assert.Equal(t, 0, len(arr))
        # assert.EqualValues(t, 0, len(arr))
        # assert.Exactly(t, 0, len(arr))
        # assert.LessOrEqual(t, len(arr), 0)
        # assert.GreaterOrEqual(t, 0, len(arr))
        # assert.Less(t, len(arr), 1)
        # assert.Greater(t, 1, len(arr))
        # assert.Equal(t, "", str)
        # assert.EqualValues(t, "", str)
        # assert.Exactly(t, "", str)
        # assert.Equal(t, ``, str)
        # assert.EqualValues(t, ``, str)
        # assert.Exactly(t, ``, str)
        #
        # assert.Positive(t, len(arr))
        # assert.NotZero(t, str)
        # assert.NotZero(t, len(arr))
        # assert.NotEqual(t, 0, len(arr))
        # assert.NotEqualValues(t, 0, len(arr))
        # assert.Greater(t, len(arr), 0)
        # assert.Less(t, 0, len(arr))
        # assert.NotEqual(t, "", str)
        # assert.NotEqualValues(t, "", str)
        # assert.NotEqual(t, ``, str)
        # assert.NotEqualValues(t, ``, str)
        #
        # ✅
        # assert.Empty(t, arr)
        # assert.NotEmpty(t, arr)
        - empty

        # https://github.com/Antonboom/testifylint?tab=readme-ov-file#encoded-compare
        #
        # Обнаруживает сравнения строки в json формате которые можно заменить на .JSONEq или .YAMLEq
        #
        # ❌
        # assert.Equal(t, `{"foo": "bar"}`, body)
        # assert.EqualValues(t, `{"foo": "bar"}`, body)
        # assert.Exactly(t, `{"foo": "bar"}`, body)
        # assert.Equal(t, expectedJSON, resultJSON)
        # assert.Equal(t, expBodyConst, w.Body.String())
        # assert.Equal(t, fmt.Sprintf(`{"value":"%s"}`, hexString), result)
        # assert.Equal(t, "{}", json.RawMessage(resp))
        # assert.Equal(t, expJSON, strings.Trim(string(resultJSONBytes), "\n")) // + Replace, ReplaceAll, TrimSpace
        #
        # assert.Equal(t, expectedYML, conf)
        #
        # ✅
        # assert.JSONEq(t, `{"foo": "bar"}`, body)
        # assert.YAMLEq(t, expectedYML, conf)
        #
        # Данные функции вызывают Unmarshal на обоих строках
        # что гарантирует верный формат и исключает ошибки связанные с отсупами
        - encoded-compare

        # https://github.com/Antonboom/testifylint?tab=readme-ov-file#equal-values
        #
        # EqualValues позволяет сравнивать числовые значения не опираясь на тип
        # однако в случае если тип одинаковый необходимо использовать .Equal
        #
        # require.EqualValues(t, int32(1), 1) // валидно так как 1 == 1
        # require.Equal(t, int32(1), 1) // ошибка так как типы разные (int32 и int)
        #
        # ❌
        # assert.EqualValues(t, 42, result.IntField)
        # assert.NotEqualValues(t, 42, result.IntField)
        # // And other variations with similar types (strings, numerics, structs, etc.)...
        #
        # ✅
        # assert.Equal(t, 42, result.IntField)
        # assert.NotEqual(t, 42, result.IntField)
        #
        - equal-values

        # https://github.com/Antonboom/testifylint?tab=readme-ov-file#error-is-as
        #
        # Валидирует сравнение ошибок
        #
        # ❌
        # assert.Error(t, err, errSentinel) // второй аргумент будет передан как msgAndArgs
        # assert.NoError(t, err, errSentinel)
        # assert.IsType(t, err, errSentinel)
        # assert.IsType(t, (*http.MaxBytesError)(nil), err)
        # assert.IsNotType(t, err, errSentinel)
        # assert.IsNotType(t, store.NotFoundError{}, err)
        # assert.True(t, errors.Is(err, errSentinel))
        # assert.False(t, errors.Is(err, errSentinel))
        # assert.True(t, errors.As(err, &target))
        # assert.False(t, errors.As(err, &target))
        #
        # ✅
        # assert.ErrorIs(t, err, errSentinel)
        # assert.NotErrorIs(t, err, errSentinel)
        # assert.ErrorAs(t, err, &target)
        # assert.NotErrorAs(t, err, &target)
        - error-is-as

        # https://github.com/Antonboom/testifylint?tab=readme-ov-file#error-nil
        #
        # Для простой проверки на err != nil существуют специальные фукнции .Error, .NoError
        #
        # ❌
        # assert.Nil(t, err)
        # assert.Empty(t, err)
        # assert.Zero(t, err)
        # assert.Equal(t, nil, err)
        # assert.EqualValues(t, nil, err)
        # assert.Exactly(t, nil, err)
        # assert.ErrorIs(t, err, nil)
        # assert.IsType(t, err, nil)
        #
        # assert.NotNil(t, err)
        # assert.NotEmpty(t, err)
        # assert.NotZero(t, err)
        # assert.NotEqual(t, nil, err)
        # assert.NotEqualValues(t, nil, err)
        # assert.NotErrorIs(t, err, nil)
        # assert.IsNotType(t, err, nil)
        #
        # ✅
        # assert.NoError(t, err)
        # assert.Error(t, err)
        #
        - error-nil

        # https://github.com/Antonboom/testifylint?tab=readme-ov-file#expected-actual
        #
        # Проверят что expected аргументы идут первыми
        # expected - статичные значения или переменные названия которых
        # соответствуют заданному regexp (Настраивается)
        #
        # ❌
        # assert.Equal(t, result, expected)
        # assert.Equal(t, result, len(expected))
        # assert.Equal(t, len(resultFields), len(expectedFields))
        # assert.EqualExportedValues(t, resultObj, User{Name: "Rob"})
        # assert.EqualValues(t, result, 42)
        # assert.Exactly(t, result, int64(42))
        # assert.JSONEq(t, result, `{"version": 3}`)
        # assert.InDelta(t, result, 42.42, 1.0)
        # assert.InDeltaMapValues(t, result, map[string]float64{"score": 0.99}, 1.0)
        # assert.InDeltaSlice(t, result, []float64{0.98, 0.99}, 1.0)
        # assert.InEpsilon(t, result, 42.42, 0.0001)
        # assert.InEpsilonSlice(t, result, []float64{0.9801, 0.9902}, 0.0001)
        # assert.IsType(t, result, (*User)(nil))
        # assert.NotEqual(t, result, "expected")
        # assert.NotEqualValues(t, result, "expected")
        # assert.NotSame(t, resultPtr, &value)
        # assert.Same(t, resultPtr, &value)
        # assert.WithinDuration(t, resultTime, time.Date(2023, 01, 12, 11, 46, 33, 0, nil), time.Second)
        # assert.YAMLEq(t, result, "version: '3'")
        #
        # ✅
        # assert.Equal(t, expected, result)
        # assert.Equal(t, len(expected), result)
        # assert.Equal(t, len(expectedFields), len(resultFields))
        # assert.EqualExportedValues(t, User{Name: "Rob"}, resultObj)
        # assert.EqualValues(t, 42, result)
        # // And so on...
        #
        #
        - expected-actual

        # https://github.com/Antonboom/testifylint?tab=readme-ov-file#float-compare
        #
        # Устанавливает правила для сравнения float значений
        #
        # ❌
        # assert.Equal(t, 42.42, result)
        # assert.EqualValues(t, 42.42, result)
        # assert.Exactly(t, 42.42, result)
        # assert.True(t, result == 42.42)
        # assert.False(t, result != 42.42)
        #
        # ✅
        # assert.InEpsilon(t, 42.42, result, 0.0001) // Or assert.InDelta
        #
        # по скольку float не является точным примитивом рекомендуется сравнивать
        # с погрешностью
        #
        - float-compare

        # https://github.com/Antonboom/testifylint?tab=readme-ov-file#formatter
        #
        # Сообщает о нежелательных вызовах форматирования, которые можно заменить на встроенные функции testify
        #
        # ❌
        # assert.ElementsMatch(t, certConfig.Org, csr.Subject.Org, "organizations not equal")
        # assert.Error(t, err, fmt.Sprintf("Profile %s should not be valid", test.profile))
        # assert.Errorf(t, err, fmt.Sprintf("test %s", test.testName))
        # assert.Truef(t, targetTs.Equal(ts), "the timestamp should be as expected (%s) but was %s", targetTs)
        # // And other go vet's printf checks...
        #
        # ✅
        # assert.ElementsMatchf(t, certConfig.Org, csr.Subject.Org, "organizations not equal")
        # assert.Errorf(t, err, "Profile %s should not be valid", test.profile)
        # assert.Errorf(t, err, "test %s", test.testName)
        # assert.Truef(t, targetTs.Equal(ts), "the timestamp should be as expected (%s) but was %s", targetTs, ts)
        - formatter

        # https://github.com/Antonboom/testifylint?tab=readme-ov-file#go-require
        #
        # Сообщает о случаях вызова FailNow, require в горутинах
        # подробнее об этом рассказано в govet.testinggoroutine
        #
        # go func() {
        #     conn, err = lis.Accept()
        #     require.NoError(t, err) ❌
        #
        #     if assert.Error(err) {     ✅
        #         assert.FailNow(t, msg) ❌
        #     }
        # }()
        #
        - go-require

        # https://github.com/Antonboom/testifylint?tab=readme-ov-file#len
        #
        # Сообщает о неверном сравнении длин массивов
        #
        # ❌
        # assert.Equal(t, 42, len(arr))
        # assert.Equal(t, len(arr), 42)
        # assert.EqualValues(t, 42, len(arr))
        # assert.EqualValues(t, len(arr), 42)
        # assert.Exactly(t, 42, len(arr))
        # assert.Exactly(t, len(arr), 42)
        # assert.True(t, 42 == len(arr))
        # assert.True(t, len(arr) == 42)
        #
        # assert.Equal(t, value, len(arr))
        # assert.EqualValues(t, value, len(arr))
        # assert.Exactly(t, value, len(arr))
        # assert.True(t, len(arr) == value)
        #
        # assert.Equal(t, len(expArr), len(arr))
        # assert.EqualValues(t, len(expArr), len(arr))
        # assert.Exactly(t, len(expArr), len(arr))
        # assert.True(t, len(arr) == len(expArr))
        #
        # ✅
        # assert.Len(t, arr, 42)
        # assert.Len(t, arr, value)
        # assert.Len(t, arr, len(expArr))
        #
        - len

        # https://github.com/Antonboom/testifylint?tab=readme-ov-file#negative-positive
        #
        # Сообщает о неправильных проверках чисел положительность/отрицательность
        #
        # ❌
        # assert.Less(t, a, 0)
        # assert.Greater(t, 0, a)
        # assert.True(t, a < 0)
        # assert.True(t, 0 > a)
        # assert.False(t, a >= 0)
        # assert.False(t, 0 <= a)
        #
        # assert.Greater(t, a, 0)
        # assert.Less(t, 0, a)
        # assert.True(t, a > 0)
        # assert.True(t, 0 < a)
        # assert.False(t, a <= 0)
        # assert.False(t, 0 >= a)
        #
        # ✅
        # assert.Negative(t, a)
        # assert.Positive(t, a)
        #
        - negative-positive

        # https://github.com/Antonboom/testifylint?tab=readme-ov-file#nil-compare
        #
        # Ответственнен за некорректные сравнения с nil
        #
        # ❌
        # assert.Equal(t, nil, value)
        # assert.EqualValues(t, nil, value)
        # assert.Exactly(t, nil, value)
        #
        # assert.NotEqual(t, nil, value)
        # assert.NotEqualValues(t, nil, value)
        #
        # ✅
        # assert.Nil(t, value)
        # assert.NotNil(t, value)
        #
        - nil-compare

        # https://github.com/Antonboom/testifylint?tab=readme-ov-file#regexp
        #
        # Указывает на участки кода с неверным использованием Regexp
        #
        # ❌
        # assert.Regexp(t, regexp.MustCompile(`\[.*\] DEBUG \(.*TestNew.*\): message`), out)
        # assert.NotRegexp(t, regexp.MustCompile(`\[.*\] TRACE message`), out)
        #
        # ✅
        # assert.Regexp(t, `\[.*\] DEBUG \(.*TestNew.*\): message`, out)
        # assert.NotRegexp(t, `\[.*\] TRACE message`, out)
        #
        - regexp

        # https://github.com/Antonboom/testifylint?tab=readme-ov-file#require-error
        #
        # Запрещает проверять ошибки с помощью assert
        #
        # ❌
        # assert.Error(t, err) // s.Error(err), s.Assert().Error(err)
        # assert.ErrorIs(t, err, io.EOF)
        # assert.ErrorAs(t, err, &target)
        # assert.EqualError(t, err, "end of file")
        # assert.ErrorContains(t, err, "end of file")
        # assert.NoError(t, err)
        # assert.NotErrorIs(t, err, io.EOF)

        # ✅
        # require.Error(t, err) // s.Require().Error(err), s.Require().Error(err)
        # require.ErrorIs(t, err, io.EOF)
        # require.ErrorAs(t, err, &target)
        # // And so on...
        - require-error

        # https://github.com/Antonboom/testifylint?tab=readme-ov-file#suite-broken-parallel
        #
        # Использование s.T().Parallel() неприемлимо для suite структур
        #
        # func (s *MySuite) SetupTest() {
        #     s.T().Parallel() ❌
        # }
        #
        # // And other hooks...
        #
        # func (s *MySuite) TestSomething() {
        #     s.T().Parallel() ❌
        #
        #     for _, tt := range cases {
        #         s.Run(tt.name, func() {
        #             s.T().Parallel() ❌
        #         })
        #
        #         s.T().Run(tt.name, func(t *testing.T) {
        #             t.Parallel() ❌
        #         })
        #     }
        # }
        - suite-broken-parallel

        # https://github.com/Antonboom/testifylint?tab=readme-ov-file#suite-dont-use-pkg
        #
        # для suite необходимо использовать методы а не функции пакета
        #
        # func (s *MySuite) TestSomething() {
        #     ❌ assert.Equal(s.T(), 42, value)
        #     ✅ s.Equal(42, value)
        # }
        - suite-dont-use-pkg

        # https://github.com/Antonboom/testifylint?tab=readme-ov-file#suite-extra-assert-call
        #
        # Настраивает правила вызова (*suite.Suite).True
        #
        # mode: remove
        # func (s *MySuite) TestSomething() {
        #     ❌ s.Assert().Equal(42, value)
        #     ✅ s.Equal(42, value)
        # }
        #
        # Настраивается, можно настроить так чтобы вызов Require или Assert был обязательным
        # с помощью mode: require
        # func (s *MySuite) TestSomething() {
        #     // ...

        #     ❌
        #     s.Require().NoError(err)
        #     s.Equal(42, value)

        #     ✅
        #     s.Require().NoError(err)
        #     s.Assert().Equal(42, value)
        # }
        - suite-extra-assert-call

        # https://github.com/Antonboom/testifylint?tab=readme-ov-file#suite-method-signature
        #
        # Проверяет сигнатуры методов suite
        #
        # ❌
        # func (s *MySuite) SetupTest(i int) { /* ... */ }
        # func (s *MySuite) TestAlice(t *testing.T) { s.SetupTest(rand()) /* ... */ }
        # func (s *MySuite) TestBob() { s.SetupTest(rand()) /* ... */ }
        #
        # ✅
        # func (s *MySuite) SetupTest() { s.setupTest(rand()) } // Use inversion-of-control's methods from suite interfaces.
        # func (s *MySuite) TestAlice() { /* ... */  }          // Keep test methods clean from args and returning values.
        # func (s *MySuite) TestBob() { /* ... */  }
        # func (s *MySuite) setupTest(i int) { /* ... */ }
        - suite-method-signature

        # https://github.com/Antonboom/testifylint?tab=readme-ov-file#suite-subtest-run
        #
        # проверяет правила вызова саб-тестов suite.Suite
        #
        # func (s *MySuite) TestSomething() {
        #     ❌
        #     s.T().Run("subtest", func(t *testing.T) {
        #         assert.Equal(t, 42, result)
        #     })
        #
        #     ✅
        #     s.Run("subtest", func() {
        #         s.Equal(42, result)
        #     })
        # }
        - suite-subtest-run

        # Устанавливвает правила вызова suite.Suite.T().Helper()
        #
        #
        # Выключаем
        #
        # При ошибке testify напечатает весь stacktrace так что это не так уж и важно
        # выглядит как линтер ради линтера
        #
        # ❌
        # func (s *RoomSuite) assertRoomRound(roundID RoundID) {
        #     s.Equal(roundID, s.getRoom().CurrentRound.ID)
        # }
        #
        # ✅
        # func (s *RoomSuite) assertRoomRound(roundID RoundID) {
        #     s.T().Helper()
        #     s.Equal(roundID, s.getRoom().CurrentRound.ID)
        # }
        # - suite-thelper

        # Предохраняет код от проверки одной и той же переменной
        #
        # assert.Contains(t, tt.value, tt.value)
        # assert.ElementsMatch(t, tt.value, tt.value)
        # assert.Equal(t, tt.value, tt.value)
        # assert.EqualExportedValues(t, tt.value, tt.value)
        # // And other assert functions...
        #
        # assert.True(t, num > num)
        # assert.True(t, num < num)
        # assert.True(t, num >= num)
        # assert.True(t, num <= num)
        # assert.True(t, num == num)
        # assert.True(t, num != num)
        #
        # assert.False(t, num > num)
        # assert.False(t, num < num)
        # assert.False(t, num >= num)
        # assert.False(t, num <= num)
        # assert.False(t, num == num)
        # assert.False(t, num != num)
        #
        # Так же предохраняет от бессмысленных проверок
        #
        # assert.Empty(t, "value") // Any string literal.
        # assert.Error(t, nil)
        # assert.False(t, false) // Any bool literal.
        # assert.Implements(t, (*any)(nil), new(Conn))
        # assert.Negative(t, 42) // Any int literal.
        # assert.Nil(t, nil)
        # assert.NoError(t, nil)
        # assert.NotEmpty(t, "value") // Any string literal.
        # assert.NotImplements(t, (*any)(nil), new(Conn))
        # assert.NotNil(t, nil)
        # assert.NotZero(t, 42)      // Any int literal.
        # assert.NotZero(t, "value") // Any string literal.
        # assert.NotZero(t, nil)
        # assert.NotZero(t, false) // Any bool literal.
        # assert.Positive(t, 42)   // Any int literal.
        # assert.True(t, true)     // Any bool literal.
        # assert.Zero(t, 42)       // Any int literal.
        # assert.Zero(t, "value")  // Any string literal.
        # assert.Zero(t, nil)
        # assert.Zero(t, false) // Any bool literal.
        #
        # assert.Negative(len(x))
        # assert.Less(len(x), 0)
        # assert.Greater(0, len(x))
        # assert.GreaterOrEqual(len(x), 0)
        # assert.LessOrEqual(0, len(x))
        #
        # assert.Negative(uintVal)
        # assert.Less(uintVal, 0)
        # assert.Greater(0, uintVal)
        # assert.GreaterOrEqual(uintVal, 0)
        # assert.LessOrEqual(0, uintVal)
        - useless-assert

      bool-compare:
        # To ignore user defined types (over builtin bool).
        # Default: false
        #
        # Настройка которая позволяет игнорировать
        # кастомные типы поверх bool при валидации проверок bool
        #
        # type Bool bool
        #
        # var predicate Bool
        # ❌ assert.Equal(t, false, predicate)
        # ✅ assert.False(t, bool(predicate))
        #
        ignore-custom-types: false

      expected-actual:
        # Regexp for expected variable name.
        # Default: (^(exp(ected)?|want(ed)?)([A-Z]\w*)?$)|(^(\w*[a-z])?(Exp(ected)?|Want(ed)?)$)
        pattern: (^(exp(ected)?|want(ed)?)([A-Z]\w*)?$)|(^(\w*[a-z])?(Exp(ected)?|Want(ed)?)$)

      formatter:
        # To enable go vet's printf checks.
        # Default: true
        check-format-string: true
        # To require f-assertions (e.g. `assert.Equalf`) if format string is used, even if there are no variable-length
        # variables, i.e. it requires `require.NoErrorf` for both these cases:
        # - require.NoErrorf(t, err, "unexpected error")
        # - require.NoErrorf(t, err, "unexpected error for sid: %v", sid)
        # To understand this behavior, please read the
        # https://github.com/Antonboom/testifylint?tab=readme-ov-file#historical-reference-of-formatter.
        # Default: false
        require-f-funcs: true
        # To require that the first element of msgAndArgs (msg) has a string type.
        # For example, in such case assertion like `assert.True(t, b, tt.case)` will be considered as invalid.
        # Default: true
        require-string-msg: false

      go-require:
        # To ignore HTTP handlers (like http.HandlerFunc).
        # Default: false
        ignore-http-handlers: false

      require-error:
        # Regexp for assertions to analyze. If defined, then only matched error assertions will be reported.
        # Default: ""
        fn-pattern: ""

      suite-extra-assert-call:
        # To require or remove extra Assert() call?
        # Default: remove
        mode: require

    thelper:
      # есть три настройки
      #
      # first - проверяет что аргумент является первым или идёт после context.Context
      #
      # До
      # func myHelper(int, *testing.T) {} // идёт вторым аргументом после int
      #
      # После
      # func myHelper(*testing.T, int) {} // является первым аргументом
      #
      # name - проверяет название параметра
      # в случае если его нет или оно опущено func myHelper(_ *testing.T) проверка не происходит
      #
      # До
      # func myHelper(wrong *testing.T, _ int) {}
      #
      # После
      # func myHelper(t *testing.T, _ int) {}
      #
      # begin - функция должна начинаться с t.Helper()
      # Выключаем
      # t.Helper убирает из стека вызовов внутренние функции
      # в большинстве случаев я хочу знать где внутри моей функции произошла ошибка
      #
      # До
      # func myHelper(t *testing.T) {}
      #
      # После
      # func myHelper(t *testing.T) {
      # 	t.Helper()
      # }

      test:
        # Check *testing.T is first param (or after context.Context) of helper function.
        # Default: true
        first: true
        # Check *testing.T param has name t.
        # Default: true
        name: true
        # Check t.Helper() begins helper function.
        # Default: true
        begin: false
      benchmark:
        # Check *testing.B is first param (or after context.Context) of helper function.
        # Default: true
        first: true
        # Check *testing.B param has name b.
        # Default: true
        name: true
        # Check b.Helper() begins helper function.
        # Default: true
        begin: false
      tb:
        # Check *testing.TB is first param (or after context.Context) of helper function.
        # Default: true
        first: true
        # Check *testing.TB param has name tb.
        # Default: true
        name: true
        # Check tb.Helper() begins helper function.
        # Default: true
        begin: false
      fuzz:
        # Check *testing.F is first param (or after context.Context) of helper function.
        # Default: true
        first: true
        # Check *testing.F param has name f.
        # Default: true
        name: true
        # Check f.Helper() begins helper function.
        # Default: true
        begin: false

    # опции являются экспериментальными и выключают не совсем то что нужно
    # Оставим их по умолчанию falsec
    unconvert:
      # Remove conversions that force intermediate rounding.
      # Default: false
      fast-math: false
      # Be more conservative (experimental).
      # Default: false
      safe: false

    unparam:
      # Inspect exported functions.
      #
      # Set to true if no external program/library imports your code.
      # XXX: if you enable this setting, unparam will report a lot of false-positives in text editors:
      # if it's called for subdir of a project it can't find external interfaces. All text editor integrations
      # with golangci-lint call it on a directory with the changed file.
      #
      # Default: false
      check-exported: true

    unqueryvet:
      # Enable SQL builder checking.
      # Default: true
      check-sql-builders: true
      # Regex patterns for acceptable SELECT * usage.
      # Default:
      # - "SELECT \\* FROM information_schema\\..*"
      # - "SELECT \\* FROM pg_catalog\\..*"
      # - "SELECT COUNT\\(\\*\\)"
      # - "SELECT MAX\\(\\*\\)"
      # - "SELECT MIN\\(\\*\\)"
      allowed-patterns:
        - "SELECT \\* FROM information_schema\\..*"
        - "SELECT \\* FROM pg_catalog\\..*"
        - "SELECT COUNT\\(\\*\\)"
        - "SELECT MAX\\(\\*\\)"
        - "SELECT MIN\\(\\*\\)"

    unused:
      # Mark all struct fields that have been written to as used.
      # Default: true
      # Засчитывает случаи записи приватных полей как использование
      #
      # type Unused struct {
      # 	field string
      # }
      #
      # un := Unused{}
      # un.field = "Hello World!" // если опция выключена линтер засчитает поле как неиспользуемое
      field-writes-are-uses: true

      # Treat IncDec statement (e.g. `i++` or `i--`) as both read and write operation instead of just write.
      # Default: false
      #
      #
      # func main() {
      # 	i := 0
      # 	i++ // если выключено сообщит о неиспользуемом параметре
      # }
      post-statements-are-reads: true

      # Mark all exported fields as used.
      # default: true
      #
      # Помечает публичные поля как используемые
      # В golangci-lint все экспортируемые объявления являются используемыми
      # данная настройка необходима для встраивания приватных типов в публичные
      #
      #
      # type embedded struct { // если выключено сообщит о том что тип нигде не используется (каскадная ошибка)
      # 	Name string
      # }
      #
      # type MyStruct struct {
      # 	embedded // если выключено сообщит о том что данное поле не используется
      # }
      #
      exported-fields-are-used: true

      # Mark all function parameters as used.
      # default: true
      #
      # Помечает все параметры функции как использованные
      # это необходимо для избежания дублей с revive.unused-parameter
      #
      # func unusedParam(i int) {} // если опция выключена сообщит о неиспользуемости параметра
      parameters-are-used: true

      # Mark all local variables as used.
      # default: true
      #
      # Помечает все локальные переменные как использованные
      #
      # func main() {
      # 	un := 1 // если выключено сообщит о неиспользуемой переменной
      # 	un++
      # }
      local-variables-are-used: true

      # Mark all identifiers inside generated files as used.
      # Default: true
      #
      # Помечает всё содержимое сгенерированных файлов как используемое
      generated-is-used: true

    usestdlibvars:
      # Suggest the use of http.MethodXX.
      # Default: true
      #
      # Сообщает об использовании http методов как строковых значений
      #
      # До
      #	_, _ = http.NewRequestWithContext(context.Background(), "GET", "/path", http.NoBody)
      # После
      # _, _ = http.NewRequestWithContext(context.Background(), http.MethodGet, "/path", http.NoBody)
      #
      http-method: true

      # Suggest the use of http.StatusXX.
      # Default: true
      #
      # rec := httptest.NewRecorder()
      #
      # До
      # rec.WriteHeader(500) // можно заменить на http.StatusInternalServerError
      #
      # После
      # rec.WriteHeader(http.StatusInternalServerError)
      #
      http-status-code: true

      # Suggest the use of time.Month in time.Date.
      # Default: false
      #
      # Сообщает о замене третьего аргумента в фукнции time.Date
      # на константу месяца
      #
      # До
      # dateOfBirth := time.Date(2004, 11, 25, 12, 30, 0, 0, time.Local)
      # После
      # dateOfBirth := time.Date(2004, time.November, 25, 12, 30, 0, 0, time.Local)
      #
      time-date-month: true

      # Suggest the use of time.Weekday.String().
      # Default: true
      #
      # Сообщает о возможной замене строковых выражений на time.Weekday.String()
      #
      # До
      # friday := "Friday"
      # После
      # friday := time.Friday.String()
      #
      #
      # Есть некоторый ньанс связанный с тем что константам нельзя присвоить значения
      # функций и методов
      #
      # const friday = "Friday" // линтер сообщит о необходимости замены на time.Friday.String()
      # Однако
      #
      # const friday = time.Friday.String() // не скомпилируется
      #
      # var friday = time.Friday.String() // скопилируется, однако теперь это изменяемая переменная
      #
      # Польза данного линтера в том что мы вообще не должны создавать
      # константы с подобными значениями и если нам необходимо название месяца
      # использовать time.Weekday.String()
      #
      time-weekday: true

      # Suggest the use of time.Month.String().
      # Default: false
      #
      # До
      # february := "February"
      # После
      #	february := time.February.String()
      #
      # const february = "February" // линтер сообщит о необходимости замены на time.February.String()
      # Однако
      #
      # const february = time.February.String() // не скомпилируется
      #
      # var february = time.February.String() // скопилируется, однако теперь это изменяемая переменная
      #
      # Польза данного линтера в том что мы вообще не должны создавать
      # константы с подобными значениями и если нам необходимо название месяца
      # использовать time.Month.String()
      #
      time-month: true

      # Suggest the use of time.Layout.
      # Default: false
      #
      # Сообщает о строковых литералах которые можно заменить на time.Layout
      #
      # До
      # log.Println(time.Now().Format("2006-01-02")) // time.DateOnly равен "2006-01-02"
      # После
      # log.Println(time.Now().Format(time.DateOnly))
      #
      time-layout: true

      # Suggest the use of crypto.Hash.String().
      # Default: false
      #
      # Сообщает о строковых литералах которые можно заменить на crypto.MD4.String()
      #
      # До
      # myHash := "MD4"
      # После
      # myHash := crypto.MD4.String()
      #
      # const myHash = "MD4" // линтер сообщит о необходимости замены на crypto.MD4.String()
      #
      # const myHash = crypto.MD4.String() // не скомпилируется
      #
      # var myHash = crypto.MD4.String() // скопилируется, однако теперь это изменяемая переменная
      #
      # Польза данного линтера в том что мы вообще не должны создавать
      # константы с подобными значениями и если нам необходимо название алгоритма кеширования
      # использовать crypto.Hash.String()
      #
      crypto-hash: true

      # Suggest the use of rpc.DefaultXXPath.
      # Default: false
      #
      # Сообщает о строковых выражениях которые совпадают с константами rpc.DefaultXXPath
      #
      # До
      # debugRPCPath := "/debug/rpc"
      # rpcPath := "/_goRPC_"
      #
      # После
      # debugRPCPath := rpc.DefaultDebugPath
      # rpcPath := rpc.DefaultRPCPath
      #
      default-rpc-path: true

      # Suggest the use of sql.LevelXX.String().
      # Default: false
      #
      # Сообщает о строковых выражениях которые можно заменить на sql.IsolationLevel.String()
      #
      # До
      # readCommitted := "Read Committed"
      #
      # После
      # readCommitted := sql.LevelReadCommitted.String()
      #
      # const readCommitted = "Read Committed" // линтер сообщит о необходимости замены на sql.ReadCommitted.String()
      #
      # Однако
      # const readCommitted = sql.LevelReadCommitted.String() // не скомпилируется
      #
      # var readCommitted = sql.LevelReadCommitted.String() // скопилируется, однако теперь это изменяемая переменная
      #
      # Польза данного линтера в том что мы вообще не должны создавать
      # константы с подобными значениями и если нам необходимо название уровня изоляции транзакций
      # использовать sql.IsolationLevel.String()
      #
      sql-isolation-level: true

      # Suggest the use of tls.SignatureScheme.String().
      # Default: false
      #
      # Сообщает о строковых литералах которые можно заменить на tls.SignatureScheme.String()
      #
      # До
      # pkgcs1WithSHA1 := "PKCS1WithSHA1"
      #
      # После
      # pkgcs1WithSHA1 := tls.PKCS1WithSHA1.String()
      #
      #
      # const pkgcs1WithSHA1 = "PKCS1WithSHA1" // линтер сообщит о необходимости замены на tls.PKCS1WithSHA1.String()
      #
      # const pkgcs1WithSHA1 = tls.PKCS1WithSHA1.String() // не скомпилируется
      #
      # var pkgcs1WithSHA1 = tls.PKCS1WithSHA1.String() // скопилируется, однако теперь это изменяемая переменная
      #
      # Польза данного линтера в том что мы вообще не должны создавать
      # константы с подобными значениями и если нам необходимо название алгоритма шифрования
      # использовать sql.SignatureScheme.String()
      #
      tls-signature-scheme: true

      # Suggest the use of constant.Kind.String().
      # Default: false
      #
      # Сообщает о строковых литералах которые можно заменить на go/constant.Kind.String()
      #
      # До
      # intConstant := "Int"
      #
      # После
      # intConstant := constant.Int.String()
      #
      # Не работает на constant.Unknown по понятным причинам (Unknown достаточно общее слово и может употребляться и вне go/constant пакета)
      # unknownConstant := "Unknown" // Предупреждения не последует
      #
      # const intConstant = "Int" // линтер сообщит о необходимости замены на constant.Int.String()
      #
      # const intConstant = constant.Int.String() // не cкомпилируется
      #
      # var intConstant = constant.Int.String() // скопилируется, однако теперь это изменяемая переменная
      #
      # Польза данного линтера в том что мы вообще не должны создавать
      # константы с подобными значениями и если нам необходимо название типа константы
      # использовать constant.Kind.String()
      #
      constant-kind: true

    usetesting:
      # Enable/disable `os.CreateTemp("", ...)` detections.
      # Default: true
      #
      # const myPattern = "mypattern"
      #
      # os.CreateTemp создает файл в заданной директории открытый на чтение и запись (0o600)
      # пустое значение первого аргумента - dir означает использование os.TempDir
      #
      # для тестов необходимо использовать t.TempDir() так как она будет зачищена после завершения теста
      # через механизм t.Cleanup
      #
      # До
      # _, _ = os.CreateTemp("", myPattern) // следует заменить на *testing.T
      #
      # После
      # _, _ = os.CreateTemp(t.TempDir(), myPattern) // всё содержимое testing.TempDir() будет зачищено в t.Cleanup
      #
      # Срабатывает только когда первым аргументом является "" - равнозначное использование os.TempDir()
      #
      # Для обнаружения использования os.TempDir() существует отдельное правило
      #
      os-create-temp: true

      # Enable/disable `os.MkdirTemp()` detections.
      # Default: true
      #
      # Сообщает об использовании os.MkdirTemp
      #
      # t.TempDir() сама создаст директорию включая рутовую если она не была создана ранее
      # все повторные вызовы будут создавать директорию в рутовой
      #
      # _, _ = os.MkdirTemp("mydir", "pattern")
      #
      os-mkdir-temp: true

      # Enable/disable `os.Setenv()` detections.
      # Default: true
      #
      # Вызовы os.Setenv("ENV", "VALUE") необходимо заменить на t.Setenv("ENV", "VALUE") в рамках тестовых функций
      #
      # t.Setenv работает по следующему принципу
      #
      # 1. Просмотр текущего состояния переменной
      # 2. Привоение переменной нового значения
      # 3. Добавление в t.Cleanup возврата к результату который мы получили на этапе 1
      #    (возврат к предыдущему значению или удаления значения в случае если на момент 1 этапа переменной не было)
      #
      #
      # До
      # os.Setenv("ENV", "VALUE")
      #
      # После
      # t.Setenv("ENV", "VALUE")
      #
      os-setenv: true

      # Enable/disable `os.TempDir()` detections.
      # Default: false
      #
      # os.TempDir() должен быть заменен на t.TempDir()
      #
      # для тестов необходимо использовать t.TempDir() так как она будет зачищена после завершения теста
      # через механизм t.Cleanup
      #
      #	const myPattern = "pattern"
      #
      #
      # До
      # _, _ = os.CreateTemp(os.TempDir(), myPattern)
      #
      # После
      # _ = t.TempDir()
      #
      os-temp-dir: true

      # Enable/disable `os.Chdir()` detections.
      # Disabled if Go < 1.24.
      # Default: true
      #
      # Необходимо использовать t.Chdir вместо os.Chdir
      #
      # os.Chdir меняет текущую рабочую директорию
      #
      # t.Chdir после завершения теста вернёт текущую директорию
      # в состояние до запуска теста
      # механизм работает аналогично t.Setenv
      #
      # До
      # _ = os.Chdir("switch")
      #
      # После
      # t.Chdir("switch")
      #
      os-chdir: true

      # Enable/disable `context.Background()` detections.
      # Disabled if Go < 1.24.
      # Default: false
      #
      # Начиная с версии go 1.24 у нас появилась возможность использовать t.Context()
      #
      # Следовательно все места использования context.Background() должны быть заменены на t.Context()
      #
      #
      # t.Context() возвращает контекст которые будет отменён по окончанию теста
      #
      # До
      # _ = context.Background()
      #
      # После
      # _ = t.Context()
      #
      context-background: true

      # Enable/disable `context.TODO()` detections.
      # Disabled if Go < 1.24.
      # Default: false
      #
      #
      # Начиная с версии go 1.24 у нас появилась возможность использовать t.Context()
      #
      # Следовательно все места использования context.Background() должны быть заменены на t.Context()
      #
      # t.Context() возвращает контекст которые будет отменён по окончанию теста
      #
      # До
      # _ = context.TODO()
      #
      # После
      # _ = t.Context()
      #
      context-todo: true

    varnamelen:
      # Если переменная нигде не применяется проверки не происходит
      # Далее следует условие что если если расстояние в строках
      # от места объявления до места использования меньше или равно max-distance
      # линтер так же не сообщит о коротком названии переменной
      #
      # Ставим минимально возможное значение в единицу
      #
      # package main
      #
      # import "log"
      #
      # func main() {
      # 	const x = 0    // объявление константы, 6 строка
      # 	log.Println(x) // первое использование, 7 строка
      # }
      #
      # 7 - 6 = 1
      # max-distance = 1
      #
      # 1 == 1
      #
      # Следовательно предупреждения не возникнет
      #
      # package main
      #
      # import "log"
      #
      # func main() {
      # 	const x = 0    // объявление константы, 6 строка
      #
      # 	log.Println(x) // первое использование, 8 строка
      # }
      #
      # 8 - 6 = 2
      # max-distance = 1
      # 2 > 1
      #
      # Следовательно линтер сообщит о нарушении
      #
      max-distance: 1

      # минимально допустимая длина переменной
      #
      # package main
      #
      # import "log"
      #
      # func main() {
      # 	const x = 0       // 1 символ в названии, плохо
      #   const xxx = 101   // 3 символа в названии, хорошо
      #
      # 	log.Println(x, xxx)
      # }
      min-name-length: 3

      # Применяет правила длины переменных в фукнциях расширениях
      #
      # type Service struct{}
      #
      # func (s Service) foo() { // s слишком короткое название переменной
      # 	// отступ для работы правила max-distance
      # 	log.Printf("Hello: %+v\n", s)
      # }
      #
      # Выключаем
      check-receiver: false

      # Проверка именованых return значений
      #
      # func foo() (s string) { // s слишком короткое название
      # 	// Отступ необходимый для работы правила max-distance
      # 	return s
      # }
      #
      check-return: true

      # Проверяет generic параметры типов
      #
      # func TypeFor[T any]() {
      # 	// Отступ необходимый для работы правила max-distance
      # 	var _ T
      # }
      #
      # Идиоматично писать их сокращённо
      # Выключаем
      check-type-param: false

      # Убирает название переменной ok из проверки в случае type assertion
      #
      # var in any
      #
      # _, ok := in.(int)
      # // Отступ необходимый для работы правила m
      # _ = ok
      #
      ignore-type-assert-ok: true

      # Убирает название переменной ok из проверки в случае получения значений из map
      #
      # var in map[int]int
      #
      # _, ok := in[0]
      # // Отступ необходимый для работы правила m
      # _ = ok
      #
      ignore-map-index-ok: true

      # Убирает название переменной ok из проверки в случае получения значений из chan
      #
      # in := make(chan int)
      #
      # _, ok := <-in
      # // Отступ необходимый для работы правила m
      # _ = ok
      ignore-chan-recv-ok: true

      # Описывает названия которые будут игнорированы независимо от их типа
      ignore-names:
        - err
        - in

      # Описывает названия переменных с их типами которые мы предпочли бы игнорировать
      ignore-decls:
        - ok bool
        - wg sync.WaitGroup
        - wg *sync.WaitGroup
        - mu *sync.Mutex
        - mu sync.Mutex
        - r *http.Request
        - w http.ResponseWriter
        - w io.Writer
        - r io.Reader
        - i int

    whitespace:
      # Enforces newlines (or comments) after every multi-line if statement.
      # Default: false
      #
      # Обязывает применять пропуск строки (или комментарий) после многострочного if
      #
      # До
      # if 10%2 == 0 &&
      # 	15%2 == 1 { // ниже должен быть отступ или комментарий
      # 	log.Println("Hello World!")
      # }
      #
      # После
      # if 10%2 == 0 &&
      # 	15%2 == 1 {
      #
      # 	log.Println("Hello World!")
      # }
      #
      multi-if: true

      # Enforces newlines (or comments) after every multi-line function signature.
      # Default: false
      #
      #
      #
      # type User struct {
      # 	age  int
      # 	name string
      # }
      #
      #
      # До
      # func newUser(
      # 	age int,
      # 	name string,
      # ) User { // ниже должен быть отступ или комментарий
      # 	return User{
      # 		age:  age,
      # 		name: name,
      # 	}
      # }
      #
      # После
      # func newUser(
      # 	age int,
      # 	name string,
      # ) User {
      #
      # 	return User{
      # 		age:  age,
      # 		name: name,
      # 	}
      # }
      #
      #
      # Конфликтует с форматированием gofumpt (gofumpt автоматически убирает пропуск линии)
      #
      # Выключаем
      multi-func: false

    # Линтер работает по следующему принципу
    #
    # Если есть функция которая в наборе возвращаемых аргументов имеет тип error, то
    # такую ошибку нельзя возвращать, есть набор функций который возвращает ошибку, при этом
    # конкретно на эти функции линтер не реагирует потому что они есть в списке
    # именно этот список нам и позволяется составить с помощью параметров конфигурации
    #
    # fmt.Errorf возвращает ошибку однако тот факт что по умолчанию она есть в списке ignore-signs
    # позволяет нам оборачивать ошибку в эту функцию не получив при этом предупреждение от линтера
    #
    wrapcheck:
      # An array of strings specifying additional substrings of signatures to ignore.
      # Unlike 'ignore-sigs', this option extends the default set (or the set specified in 'ignore-sigs') without replacing it entirely.
      # This allows you to add specific signatures to the ignore list
      # while retaining the defaults or any items in 'ignore-sigs'.
      # Default: []
      #
      # Позволяет настроить список функций ошибку которых позволительно не оборачивать
      #
      # func readConfigFile() error {
      # 	_, err := os.OpenRoot(".")
      # 	if err != nil {
      # 		return err // ошибка не обернута, однако issue будет проигнорирован если мы добавим OpenRoot в список
      # 	}
      #
      # 	return nil
      # }
      #
      extra-ignore-sigs: []

      # An array of strings that specify substrings of signatures to ignore.
      # If this set, it will override the default set of ignored signatures.
      # See https://github.com/tomarrell/wrapcheck#configuration for more information.
      # Default: [".Errorf(", "errors.New(", "errors.Unwrap(", "errors.Join(", ".Wrap(", ".Wrapf(", ".WithMessage(", ".WithMessagef(", ".WithStack("]
      #
      # Набор сигнатур функций результат которых следует игнорировать при проверке
      #
      # func readConfigFile() error {
      # 	_, err := os.Open(".") // нет в списках, возвращать ошибку нельзя
      # 	if err != nil {
      # 		return fmt.Errorf("os.Open: %w", err) // fmt.Errorf есть в списке, её результат error можно возвращать
      # 	}
      #
      # 	return nil
      # }
      #
      ignore-sigs:
        [
          ".Errorf(",
          "errors.New(",
          "errors.Unwrap(",
          "errors.Join(",
          ".Wrap(",
          ".Wrapf(",
          ".WithMessage(",
          ".WithMessagef(",
          ".WithStack(",
        ]

      # An array of strings that specify regular expressions of signatures to ignore.
      # Default: []
      #
      # Позволяет задать список регулярных выражений для поиска функций ошибку которых можно вернуть
      #
      # func readConfigFile() error {
      # 	_, err := os.Open(".") // если в списках есть регулярное выражение "O*" все функции которые начинаются на O будут проигнорированы
      # 	if err != nil {
      # 		return err // не вызовет предупреждения со стороны линтера
      # 	}
      #
      # 	return nil
      # }
      #
      ignore-sig-regexps: []

      # An array of strings that specify globs of packages to ignore.
      # Default: []
      #
      # Возволяет ввести регулярные выражения исключения сразу всех функций пакетов
      #
      #
      # func readConfigFile() error {
      # 	_, err := http.NewRequestWithContext(
      # 		context.Background(),
      # 		http.MethodGet,
      # 		"/any/target",
      # 		http.NoBody,
      # 	)
      # 	if err != nil {
      # 		return err // предупреждения не будет если в данном списке есть регулярное выражение под которое подпадает "net/http" например "net/*"
      # 	}
      #
      # 	return nil
      # }
      #
      ignore-package-globs: []

      # An array of strings that specify regular expressions of interfaces to ignore.
      # Default: []
      #
      # Набор интерфейсов из текущего пакета, ошибки из которых можно не оборачивать
      #
      # type Reader interface{ Read(buf []byte) (int, error) }
      #
      # func readConfigFile(r Reader) error {
      # 	_, err := r.Read([]byte{0})
      # 	if err != nil {
      # 		return err // если указать Reader в списке линтер не будет указывать на возврат данной ошибки без оборачивания
      # 	}
      #
      # 	return nil
      # }
      #
      ignore-interface-regexps: []

      # Determines whether wrapcheck should report errors returned from inside the package.
      # Default: false
      #
      # Следует ли оборачивать фукнции текущего пакета
      #
      # По умолчанию не стоит, так как это внутренний источник
      #
      #
      # type Reader interface{ Read(buf []byte) (int, error) }
      #
      # func readConfigFile(r Reader) error {
      # 	err := read(r)
      # 	if err != nil {
      # 		return err // по умолчанию линтер не будет сообщать о необернутых ошибках из функций текущего пакета
      # 	}
      #
      # 	return nil
      # }
      #
      # func read(Reader) error {
      # 	return nil
      # }
      #
      #
      # Выключаем
      report-internal-errors: false

    wsl_v5:
      # Разрешает захват переменной если она используется первой в следующем блоке,
      # даже если оператор с блоком не использует эту переменную.
      #
      # Является настройкой для линтеров следующих правилу
      # "Никаких переменных которые не используются в выражении"
      #
      # Пример:
      # До (при allow-first-in-block: true - разрешено):
      # x := 1
      # for {
      #     x++  // x используется первым в блоке
      #     break
      # }
      #
      # После (при allow-first-in-block: false - требуется пустая строка):
      # x := 1
      #
      # for {
      #     x++
      #     break
      # }
      #
      allow-first-in-block: true

      # То же самое, что и выше,
      # но разрешает захват если переменная используется в любом месте следующего (или вложенного) блока.
      #
      # Расширяет правило allow-first-in-block
      #
      # Является настройкой для линтеров следующих правилу
      # "Никаких переменных которые не используются в выражении"
      #
      # Пример:
      # До (при allow-whole-block: true - разрешено):
      # x := 1
      # if condition {
      #     fmt.Println("start")
      #     if nested {
      #         x = 2  // x используется во вложенном блоке
      #     }
      # }
      #
      # После (при allow-whole-block: false - требуется пустая строка):
      # x := 1
      #
      # if condition {
      #     fmt.Println("start")
      #     if nested {
      #         x = 2
      #     }
      # }
      #
      # Вредит общей читаемости кода, выключаем
      allow-whole-block: false

      # Если блок содержит больше этого количества строк,
      # оператор ветвления должен быть разделен пустой строкой.
      #
      # Пример:
      # До (блок из 5 строк > branch-max-lines: 4 - требуется пустая строка):
      # for {
      #     a, err := SomeFn()
      #     if err != nil {
      #         return err
      #     }
      #     fmt.Println(a)
      #     fmt.Println(a) // блок больше 4 строк - нужна пустая строка
      #
      #     break
      # }
      #
      # После:
      # for {
      #     a, err := SomeFn()
      #     if err != nil {
      #         return err
      #     }
      #     fmt.Println(a)
      #
      #     break
      # }
      branch-max-lines: 4

      # Если количество строк в блоке case превышает указанное количество строк (или указано отрицательное значение)
      # То такой case блок должен заканчиваться пустой строкой (кроме последнего блока)
      #
      #
      # Пример:
      # До (case из 3 строк > case-max-lines: 2 - требуется пустая строка):
      # switch value {
      # case 1:
      #     fmt.Println("line 1")
      #     fmt.Println("line 2")
      #     fmt.Println("line 3")  // 3 строки > 2 - нужна пустая строка
      # case 2:
      #     return true
      # }
      #
      # После:
      # switch value {
      # case 1:
      #     fmt.Println("line 1")
      #     fmt.Println("line 2")
      #     fmt.Println("line 3")
      #
      # case 2:
      #     return true
      # }
      case-max-lines: -1

      # Проверки по умолчанию для использования.
      # Может быть `all`, `none`, `default` или пустым.
      default: none

      # Включенные проверки.
      # Будут добавлены к любым предустановкам.
      enable:
        # Присвоения должны быть разделены пустой линией с другими типами statements
        #
        # До
        # if true {
        #     fmt.Println("hello")
        # }
        # a := 1  // не присвоение выше
        #
        # После
        # if true {
        #     fmt.Println("hello")
        # }
        #
        # a := 1
        #
        # a := 1
        # b := 2  // разрешено - оба присвоения
        - assign

        # Операторы перехода должны иметь пустую строку если блок больше n строк
        #
        # Количество линий регулируется через настройку branch-max-lines
        #
        # До
        # for {
        #     a, err := SomeFn()
        #     if err != nil {
        #         return err
        #     }
        #     fmt.Println(a)
        #     break  // блок больше 4 строк - нужна пустая строка
        # }
        #
        # После
        # for {
        #     a, err := SomeFn()
        #     if err != nil {
        #         return err
        #     }
        #     fmt.Println(a)
        #
        #     break
        # }
        - branch

        # Объявления должны быть сгруппированы
        #
        # До
        # var a string
        # var b int  // множественные объявления должны быть сгруппированы
        #
        # После
        # var (
        #     a string
        #     b int
        # )
        - decl

        # Defer должен использоваться непосредственно в контексте откладываемой операции
        # Если операция не используется в defer линтер не будет жаловаться
        #
        # До
        # ctx, cancel := context.WithCancel(ctx)
        # fmt.Println("Hello World!")
        # defer cancel() // должен идти непосредственно после context.WithCancel
        #
        # После
        # ctx, cancel := context.WithCancel(ctx)
        # defer cancel()
        # fmt.Println("Hello World!")
        #
        - defer

        # Блоки инициализации переменных должны быть разделены с вызовами функция|методов если они не используются непосредственно
        # в данном вызову фукнции|метода
        #
        # До
        # a := 1
        # b := 2
        # fmt.Println("not b")  // b не используется в выражении
        #
        # После
        # a := 1
        # b := 2
        #
        # fmt.Println("not b")
        # - expr

        # For должен использовать переменные из предыдущей строки в условии
        #
        # allow-first-in-block и allow-whole-block влиют на поведение линтера
        #
        # До
        # condition := true
        # for false {
        # 	fmt.Println("false")
        # }
        #
        # После
        #
        # condition := true
        # for condition {
        # 	fmt.Println("false")
        # }
        #
        # Или
        #
        # condition := true
        # for false {
        # 	fmt.Println("false")
        # }
        #
        - for

        # Go должен использовать переменные из предыдущей строки
        #
        # allow-first-in-block и allow-whole-block влиют на поведение линтера
        #
        # До
        # path := "Hello World!" // по скольку path не используется в функции вызванной в новой горутине необходим отступ
        # go fmt.Println("Hello")
        #
        # После
        #
        # path := "Hello World!"
        # go fmt.Println(path)
        #
        # Или
        #
        # path := "Hello World!"
        #
        # go fmt.Println("Hello")
        #
        - go

        # If должен использовать переменные из предыдущей строки в условии
        #
        # allow-first-in-block и allow-whole-block влиют на поведение линтера
        #
        # До
        # y := 0
        #
        # x := 1
        # if y > 1 {  // x не используется в условии
        #     fmt.Println("y > 1")
        # }
        #
        # После
        # y := 0
        #
        # x := 1
        # if x > 1 {  // x используется в условии
        #     fmt.Println("x > 1")
        # }
        #
        # Или
        #
        # y := 0
        #
        # x := 1
        #
        # if y > 1 {  // x не используется в условии
        #     fmt.Println("y > 1")
        # }
        #
        - if

        # Инкремент/декремент должны быть разделены пустой строкой с другими типами statements
        #
        # До
        #
        # i := 1
        #
        # if true {
        # }
        # i++
        #
        # После
        #
        # i := 1
        #
        # if true {
        # }
        #
        # i++
        # - inc-dec

        # Метки всегда должны иметь пустую строку сверху
        #
        # До
        # L1:
        #     if true {
        #         _ = 1
        #     }
        # L2:  // метка без пустой строки сверху
        #     if true {
        #         _ = 1
        #     }
        #
        # После
        # L1:
        #     if true {
        #         _ = 1
        #     }
        #
        # L2:  // метка с пустой строкой сверху
        #     if true {
        #         _ = 1
        #     }
        - label

        # Range должен использовать переменные из предыдущей строки
        #
        # allow-first-in-block и allow-whole-block влиют на поведение линтера
        #
        # До
        # nums := []int{1, 2, 3}
        # for range 1 {
        # 	_ = nums
        # }
        #
        # После
        # nums := []int{1, 2, 3}
        # for range nums {
        # 	_ = nums
        # }
        #
        # Или
        #
        # nums := []int{1, 2, 3}
        #
        # for range 1 {
        # 	_ = nums
        # }
        #
        - range

        # Return должен иметь пустую строку если блок больше n строк
        #
        # Количество линий регулируется через настройку branch-max-lines
        #
        # До
        #
        # func do() error {
        # 	_, err := strconv.Atoi("1")
        # 	if err != nil {
        # 		return err
        # 	}
        # 	return nil // блок больше 4 строк - нужна пустая строка
        # }
        #
        # После
        #
        # func do() error {
        # 	_, err := strconv.Atoi("1")
        # 	if err != nil {
        # 		return err
        # 	}
        #
        # 	return nil // блок больше 4 строк - нужна пустая строка
        # }
        #
        - return

        # Select должен использовать переменные из предыдущей строки
        #
        # До
        #
        # allow-first-in-block не сработает, однако allow-whole-block предотвращает случаи когда переменная используется в тебе блока
        #
        # numCh := make(chan int) // не используется в case нижнем блоках, должен быть отступ
        # select {
        # case <-time.After(time.Second):
        # 	<-numCh
        # }
        #
        # После
        #
        # numCh := make(chan int) // используется в одной из ветвей, всё хорошо
        # select {
        # case <-time.After(time.Second):
        # 	<-numCh
        #
        # case <-numCh:
        # }
        #
        # Или
        #
        # numCh := make(chan int) // не используется в case нижнем блоках, должен быть отступ
        # // отступ
        # select {
        # case <-time.After(time.Second):
        # 	<-numCh
        # }
        #
        - select

        # Send должен использовать переменные из предыдущей строки
        #
        # До
        #
        # ch := make(chan int)
        #
        # a := 1 // ниже необходим отступ
        # ch <- 1
        #
        # После
        #
        # ch := make(chan int)
        #
        # a := 1
        # ch <- a
        #
        # Или
        #
        # ch := make(chan int)
        #
        # a := 1
        #
        # ch <- 1
        #
        - send

        # Switch должен использовать переменные из предыдущей строки
        #
        # До
        # a := 0 // переменная не используется, ниже должен быть отступ
        # switch 0 {
        # case 1:
        # }
        #
        # После
        # a := 0 // переменная используется в одной из веток case
        # switch 0 {
        # case 1:
        # case a:
        # }
        #
        # Или
        #
        # a := 0 // переменная используется в самом switch
        # switch a {
        # case 1:
        # case 0:
        # }
        #
        # Или (если включено allow-whole-block)
        # a := 0
        # switch 2 {
        # case 1:
        # 	_ = a
        #
        # case 0:
        # }
        #
        - switch

        # Type-switch должен использовать переменные из предыдущей строки
        #
        # До
        # anyWord := any("Hello World!")
        #
        # anyDigit := any(1) // ниже должен быть отступ
        # switch anyWord.(type) {
        # case int32:
        # }
        #
        # После
        # anyWord := any("Hello World!")
        # anyDigit := any(1)
        #
        # switch anyWord.(type) {
        # case int32:
        # 	_ = anyDigit
        # }
        #
        # Или с включенной опцией allow-whole-block
        #
        # anyWord := any("Hello World!")
        #
        # anyDigit := any(1)
        # switch anyWord.(type) {
        # case int32:
        # 	_ = anyDigit // any digit используется в блоке, поэтому с данной опцией линтер не ругается
        # }
        #
        - type-switch

        # Append должен использовать переменные из предыдущей строки
        #
        # До
        # digits := make([]int, 0)
        # a := 1
        #
        # b := 1
        # digits = append(digits, a)
        #
        # После
        # digits := make([]int, 0)
        # a := 1
        #
        # b := 1
        #
        # digits = append(digits, a)
        #
        # Или
        #
        # digits := make([]int, 0)
        # b := 1
        #
        # a := 1
        # digits = append(digits, a) // assign-exclusive всё ещё будет жаловаться на данную строку
        #
        # По скольку append это всегда присвоение, конфликтует с линтером assign в некоторых случаях
        - append

        # Запрещает смешивать декларацию переменных (:=) и присвоения (=)
        #
        # До
        # a := 0
        #
        # b := 1 // ниже должен быть отступ
        # a = 2
        #
        # После
        # a := 0
        #
        # b := 1
        #
        # a = 2
        #
        #
        # Является поднастройкой assign, если assign выключена assign-exclusive не имеет эффекта
        - assign-exclusive

        # Запрещает смешивать декларацию переменных полученных в результате функций с другими выражениями
        #
        # До
        # srv.Hello() // ниже необходим отступ
        # code, ok := srv.Bye()
        #
        # После
        # srv.Hello()
        #
        # code, ok := srv.Bye()
        #
        # Является поднастройкой assign, если assign выключена assign-expr не имеет эффекта
        - assign-expr

        # Запрещает пустую строку между присвоением ошибки и ее проверкой
        #
        # До
        # file, err := os.Open("README.md")
        #
        # if err != nil { // пустая строка между присвоением ошибки и её проверкой
        # 	panic(err)
        # }
        #
        # После
        # file, err := os.Open("README.md")
        # if err != nil {
        # 	panic(err)
        # }
        #
        - err

        # Запрещает ведущие пробелы в начале блока
        #
        # До
        # if true {
        #
        #     fmt.Println("hello")  // есть пустая строка в начале блока
        # }
        #
        # func hello() int {
        #
        # 	return 0 // есть пустая строка в начале блока
        # }
        #
        # После
        # if true {
        #     fmt.Println("hello")  // нет пустой строки в начале блока
        # }
        #
        # func hello() int {
        # 	return 0 // нет пустой строки в начале блока
        # }
        #
        # whitespace выполняет ту же самую функцию
        # Однако позволяет настроить правило в случае многострочных if и деклараций функции
        # Выключаем
        # - leading-whitespace

        # Запрещает trailing пробелы в конце блока
        #
        # Распространяется и на другие конструкции
        #
        # До
        # if true {
        #     fmt.Println("hello")
        #
        # } // есть пустая строка в конце блока
        #
        #
        # func hello() int {
        # 	return 0
        #
        # } // есть пустая строка в конце блока
        #
        # После
        # if true {
        #     fmt.Println("hello")
        # } // нет пустой строки в конце блока
        #
        # func hello() int {
        # 	return 0
        # } // нет пустой строки в конце блока
        #
        #
        # whitespace выполняет ту же самую функцию
        # Однако позволяет настроить правило в случае многострочных if и деклараций функции
        # Выключаем
        # - trailing-whitespace

      # Отключить проверки.
      # Будет вычитаться из любой предустановки.
      disable: []

  exclusions:
    # Сообщает что исключение не используется
    # Может немного напрягать
    # Выключаю
    warn-unused: false

    rules:
      # Так как ruleguard это функции go которые представляют собой dsl
      # они более нигде не используются
      # соответственно они исключены из проверок
      - path: .rules.go
        linters:
          - unused

      - path: _test\.go
        linters:
          # Для тестов вполне нормально если мы схлопотаем панику при a := x.(*Type)
          # По скольку зачастую в тестах если тип не тот мы спаникуем
          # Затратив при этом лишние строчки на проверку if !ok и сам вызов паники или t.Fatal
          - forcetypeassert

      - source: "^func Test"
        linters:
          # Для тестовых функций выключаем правило длины функции
          - funlen

      - source: "^func main()"
        linters:
          # Отключаем проверку длины для main функций
          - funlen

formatters:
  enable:
    # https://golangci-lint.run/docs/formatters/configuration/#gci
    # https://github.com/daixiang0/gci
    #
    # Определеяет порядок следования импортов в import ( "fmt" )
    #
    # Имеет гибкую настройку
    #
    # Будет полезен если вам необходимо сортировать импорты
    #
    # Выключаем
    # - gci

    # https://golangci-lint.run/docs/formatters/configuration/#gofmt
    # https://pkg.go.dev/cmd/gofmt
    #
    # Форматтер в gopls по умолчанию
    #
    # в golangci-lint позволяет настроить список замен
    #
    - gofmt

    # https://golangci-lint.run/docs/formatters/configuration/#gofumpt
    # https://github.com/mvdan/gofumpt
    #
    # Расширяет функциональность gofmt
    #
    # В gopls может быть включен с помощью опции gofumpt - true
    # Является форком gofmt
    #
    # Добавочные правила относительно gofmt
    #
    #
    # После оператора присвоения не должно быть пустых линий
    #
    # До
    # func foo() {
    #     foo :=
    #         "bar"
    # }
    #
    # После
    # func foo() {
    # 	foo := "bar"
    # }
    #
    #
    # В начале и конце функции не должно быть пустых линий
    #
    # До
    # func foo() {
    #
    # 	println("bar")
    #
    # }
    #
    # После
    # func foo() {
    # 	println("bar")
    # }
    #
    #
    # Функции должны отделять объявление параметров функции от ) {
    # Это помогает улучшить читаемость кода
    #
    # До
    # func foo(s string,
    # 	i int) {
    # 	println("bar")
    # }
    #
    # // With an empty line it's slightly better, but still not great.
    # func bar(s string,
    # 	i int) {
    #
    # 	println("bar")
    # }
    #
    # После
    # func foo(s string,
    # 	i int) {
    # 	println("bar")
    # }
    #
    # // With an empty line it's slightly better, but still not great.
    # func bar(s string,
    # 	i int) {
    #
    # 	println("bar")
    # }
    #
    #
    # В случае если в блоке содержится одно выражение (или комментарий) вокруг него не должно быть пустых строк
    #
    # До
    # if err != nil {
    #
    # 	return err
    # }
    #
    # if err != nil {
    #
    # 	// comment
    # 	return err
    # }
    #
    #
    # После
    # if err != nil {
    # 	return err
    # }
    #
    # if err != nil {
    # 	// comment
    # 	return err
    # }
    #
    #
    # Между получением ошибки и её проверкой не должно быть пустых линий
    #
    # До
    # foo, err := processFoo()
    #
    # if err != nil {
    # 	return err
    # }
    #
    # После
    # foo, err := processFoo()
    # if err != nil {
    # 	return err
    # }
    #
    #
    # Элементы слайсов должны использовать новые строки согласовано
    #
    # До
    # // A newline before or after an element requires newlines for the opening and
    # // closing braces.
    #
    # // Если после элемента есть отсуп в виде пропуска строки то начало и конец массива должны быть отделены пропусками строк
    # // включая тот что был сделан пользователем
    # var ints = []int{1, 2,
    # 	3, 4}
    #
    # // A newline between consecutive elements requires a newline between all
    # // elements.
    # // Если между несколькими элементами массива есть отступ то каждый
    # // элемент массива должен быть отеделен отступом
    # var matrix = [][]int{
    # 	{1},
    # 	{2}, {
    # 		3,
    # 	},
    # }
    #
    # После
    # var ints = []int{
    # 	1, 2,
    # 	3, 4,
    # }
    #
    # var matrix = [][]int{
    # 	{1},
    # 	{2},
    # 	{
    # 		3,
    # 	},
    # }
    #
    #
    # Пустой набор полей, методов, параметров должен использовать одну строку
    #
    # До
    # var V interface {
    # } = 3
    #
    # type T struct {
    # }
    #
    # func F(
    # ) {
    #
    # }
    #
    # После
    # var V interface{} = 3
    #
    # type T struct{}
    #
    # func F() {
    # }
    #
    #
    # Стандартные импорты должны быть сгруппированы в один блок и быть наверху блока import
    #
    # В случае если название вашего модуля не содержит '.' в своем имени
    # необходимо указать параметр module-path в настройках линтера
    # для избежания распознования локальных пакетов модуля как зависимостей стандартной библиотеки
    #
    # До
    # import (
    # 	"foo.com/bar"
    #
    # 	"io"
    #
    # 	"io/ioutil"
    # )
    #
    # После
    # import (
    # 	"io"
    # 	"io/ioutil"
    #
    # 	"foo.com/bar"
    # )
    #
    #
    # Если case выражение можно уместить в 60 символов то такое выжение должно быть записано в одну строчку
    # важно учитывать при настройке лимита в lll
    #
    # До
    # switch c {
    # case 'a', 'b',
    # 	'c', 'd':
    # }
    #
    # После
    # switch c {
    # case 'a', 'b', 'c', 'd':
    # }
    #
    #
    # Верхнеуровневые декларации должны быть разделены пустой строкой
    #
    # До
    # func foo() {
    # 	println("multiline foo")
    # }
    # func bar() {
    # 	println("multiline bar")
    # }
    #
    # После
    # func foo() {
    # 	println("multiline foo")
    # }
    #
    # func bar() {
    # 	println("multiline bar")
    # }
    #
    #
    # Блоки var состоящие из одной переменной должны быть записаны в одну строку
    #
    # До
    # var (
    # 	foo = "bar"
    # )
    #
    # После
    # var foo = "bar"
    #
    #
    # Идущие последовательно одиночные объявления var должны быть объединены в один блок var
    #
    # До
    # var nicer = "x"
    # var with = "y"
    # var alignment = "z"
    #
    # После
    # var (
    # 	nicer     = "x"
    # 	with      = "y"
    # 	alignment = "z"
    # )
    #
    #
    # Одиночное объявление var должно быть заменено на короткий вариант ':='
    #
    # До
    # var s = "somestring"
    #
    # После
    # s := "somestring"
    #
    #
    # Флаг -s в gofmt
    #
    # До
    # var _ = [][]int{[]int{1}}
    #
    # После
    # var _ = [][]int{{1}}
    #
    #
    # Числа в восьмеричной системе счисления должны начинаться с '0o'
    #
    # До
    # const perm = 0755
    #
    # После
    # const perm = 0o755
    #
    #
    # Комментарии не относящиеся к //go:directive должны начинаться с пробела
    # gofmt так же исправляет подобные issue
    #
    # До
    # //go:noinline
    #
    # //Foo is awesome.
    # func Foo() {}
    #
    # После
    # //go:noinline
    #
    # // Foo is awesome.
    # func Foo() {}
    #
    #
    # В slice и map не должно быть отступов строки в начале и в конце
    #
    # До
    # var _ = []string{
    #
    # 	"foo",
    #
    # }
    #
    # var _ = map[string]string{
    #
    # 	"foo": "bar",
    #
    # }
    #
    # После
    # var _ = []string{
    # 	"foo",
    # }
    #
    # var _ = map[string]string{
    # 	"foo": "bar",
    # }
    #
    #
    # В объявлениях методов интерфейса и полей структур не должно быть лишних пробелов в начале и конце
    #
    # До
    # type Person interface {
    #
    # 	Name() string
    #
    # 	Age() int
    #
    # }
    #
    # type ZeroFields struct {
    #
    # 	// No fields are needed here.
    #
    # }
    #
    # После
    # type Person interface {
    # 	Name() string
    #
    # 	Age() int
    # }
    #
    # type ZeroFields struct {
    # 	// No fields are needed here.
    # }
    #
    # Пример с интерфейсом работает и в gofmt
    #
    - gofumpt

    # https://golangci-lint.run/docs/formatters/configuration/#goimports
    # https://pkg.go.dev/golang.org/x/tools/cmd/goimports
    #
    # Убирает неиспользуемые импорты
    # Ищет вызовы функций из пакетов, которые не импортированы
    # Проверяет порядок импортов
    #
    # Имеет настройку для отдельной группировки пакетов
    - goimports

    # https://golangci-lint.run/docs/formatters/configuration/#golines
    # https://github.com/segmentio/golines
    #
    # Сокращает линии
    #
    # До
    # myMap := map[string]string{"first key": "first value", "second key": "second value", "third key": "third value", "fourth key": "fourth value", "fifth key": "fifth value"}
    #
    # После
    # myMap := map[string]string{
    # 	"first key": "first value",
    # 	"second key": "second value",
    # 	"third key": "third value",
    # 	"fourth key": "fourth value",
    # 	"fifth key": "fifth value",
    # }
    #
    # Настраивается
    - golines

    # https://golangci-lint.run/docs/formatters/configuration/#swaggo
    # https://github.com/golangci/swaggoswag
    #
    # Выравнивает комментарии https://github.com/swaggo/swag которые предназначены для генерации openapi спецификации
    #
    # До
    # // GetUser handles getting user
    # // @Summary Get user
    # // @Description Get user by ID
    # // @Tags users
    # // @Accept json
    # // @Produce json
    # // @Param id path int true "User ID"
    # // @Success 200 {object} User "OK"
    # // @Failure 400 {object} Error "Bad Request"
    # // @Router /users/{id} [get]
    # func GetUser() {}
    #
    # После
    # // GetUser handles getting user
    # // @Summary      Get user
    # // @Description  Get user by ID
    # // @Tags         users
    # // @Accept       json
    # // @Produce      json
    # // @Param        id  path  int  true  "User ID"
    # // @Success      200  {object}  User  "OK"
    # // @Failure      400  {object}  Error  "Bad Request"
    # // @Router       /users/{id} [get]
    # func GetUser() {}
    #
    - swaggo

  settings:
    gci:
      # Section configuration to compare against.
      # Section names are case-insensitive and may contain parameters in ().
      # The default order of sections is `standard > default > custom > blank > dot > alias > localmodule`.
      # If `custom-order` is `true`, it follows the order of `sections` option.
      # Default: ["standard", "default"]
      sections:
        # Standard section: captures all standard packages
        # Все импорты из стандартной библиотеки
        #
        - standard

        # Default section: contains all imports that could not be matched to another section type.
        # Все импорты которые не вошли ни в одну другую группу
        #
        # Зачастую здесь будут ваши внешние зависимости
        #
        - default

        # Custom section: groups all imports with the specified Prefix.
        # Все импорты которые начинаются с указанного префикса
        #
        - prefix(github.com)
        - prefix(golang.org)

        # Blank section: contains all blank imports. This section is not present unless explicitly enabled.
        # Импорты с alias _
        #
        # import _ "crypto/sha256"
        #
        - blank

        # Dot section: contains all dot imports. This section is not present unless explicitly enabled.
        #
        # Импорты с alias .
        #
        # import . "fmt"
        #
        - dot

        # Alias section: contains all alias imports. This section is not present unless explicitly enabled.
        #
        # import c "context"
        #
        # Если импорт имеет alias но при этом так же относится к категории localmodule
        # то такой импорт будет помещён в секцию localmodule
        #
        - alias

        # Local module section: contains all local packages. This section is not present unless explicitly enabled.
        #
        # Зависимости из пакетов самого модуля
        #
        # Структура вашего проекта github.com/bob/service
        #
        # internal
        #   app
        #     app.go
        #   client
        #     client.go
        #
        # Импорт github.com/bob/service/client будет помещён в эту секцию
        #
        - localmodule

      # Checks that no inline comments are present.
      # Default: false
      #
      # В настоящее время golangci-lint v2.7.1 не имеет силы (поле в конфиге нигде не используется)
      no-inline-comments: true

      # Checks that no prefix comments (comment lines above an import) are present.
      # Default: false
      #
      # В настоящее время golangci-lint v2.7.1 не имеет силы (поле в конфиге нигде не используется)
      no-prefix-comments: true

      # Enable custom order of sections.
      # If `true`, make the section order the same as the order of `sections`.
      # Default: false
      #
      # По умолчанию порядок секций таков
      # standard > default > custom > blank > dot > alias > localmodule
      #
      # При включении данной опции порядок будет определен порядком указания в sections
      custom-order: true

      # Drops lexical ordering for custom sections.
      # Default: false
      #
      # Размещает custom опции в порядке указанным в sections
      #
      # Если опция custom-order включена no-lex-order не используется
      #
      no-lex-order: false

    gofmt:
      # Simplify code: gofmt with `-s` option.
      # Default: true
      #
      # Если включено вводит дополнительные правила по упрощению кода
      #
      # Примеры взяты из официальной документации
      #
      # https://pkg.go.dev/cmd/gofmt#hdr-The_simplify_command
      #
      # An array, slice, or map composite literal of the form:
      # 	[]T{T{}, T{}}
      # will be simplified to:
      # 	[]T{{}, {}}
      #
      # A slice expression of the form:
      # 	s[a:len(s)]
      # will be simplified to:
      # 	s[a:]
      #
      # A range of the form:
      # 	for x, _ = range v {...}
      # will be simplified to:
      # 	for x = range v {...}
      #
      # A range of the form:
      # 	for _ = range v {...}
      # will be simplified to:
      # 	for range v {...}
      #
      # в gofumpt включено по умолчанию
      simplify: true

      # Apply the rewrite rules to the source before reformatting.
      # https://pkg.go.dev/cmd/gofmt
      # Default: []
      #
      # Позволяет настроить автоматические замены
      #
      # interface{} будет автоматически заменен на any после форматирования
      rewrite-rules:
        - pattern: "interface{}"
          replacement: "any"

        - pattern: "uuid.Nil"
          # Скобки нужны для условий if, где в случае замены без скобок появится синтаксическая ошибка
          replacement: "(uuid.UUID{})"

    gofumpt:
      # Module path which contains the source code being formatted.
      # Default: ""
      #
      # Необходим для того чтобы импорты локальных пакетов не попали в секцию std
      #
      # Например наш модуль называется foo/bar
      # Это позволит форматтеру отделить зависимости стандартной библиотеки от foo/bar
      #
      module-path: ""

      # Choose whether to use the extra rules.
      # Default: false
      #
      # Включает дополнительные правила
      #
      #
      # Соседствующие параметры одного типа должны быть сгруппированы вместе
      #
      # До
      # func Foo(bar string, baz string) {}
      #
      # После
      # func Foo(bar, baz string) {}
      #
      #
      # Необходимо избегать пустых return
      #
      # До
      # func Foo() (err error) {
      #   return
      # }
      #
      # После
      # func Foo() (err error) {
      # 	return err
      # }
      #
      extra-rules: true

    goimports:
      # A list of prefixes, which, if set, checks import paths
      # with the given prefixes are grouped after 3rd-party packages.
      # Default: []
      #
      # Набор префиксов по которым goimports отделит эти зависимости от общей массы импортов
      #
      # В документации gci (более мощный форматтер от сообщества позволяющий сортировать импорты)
      #
      # Указано на необходимость убедится что goimports запускается до gci
      # Иначе могут возникнуть конфликты
      #
      #
      # import (
      #   "os"
      #
      #   "github.com/amidgo/dependency"
      #   "you.com/local/prefix/dependency"
      #
      #   "you.com/local/prefix/dependency/v1"
      # )
      #
      # В случае если you.com указано в префиксе то после запуска мы увидим
      #
      # import (
      #   "os"
      #
      #   "github.com/amidgo/dependency"
      #
      #   "you.com/local/prefix/dependency"
      #
      #   "you.com/local/prefix/dependency/v1"
      # )
      #
      # Все зависимости с префиксом you.com отделены от остальной массы
      # НО не сгруппированы вместе
      local-prefixes: []

    golines:
      # Target maximum line length.
      # Default: 100
      #
      # Максимально допустимая длина строки
      # Желательно чтобы совпадало с настройкой lll.line-length
      max-len: 100

      # Length of a tabulation.
      # Default: 4
      #
      # Стоимость символа табуляции '\t' при расчете длины строки
      # Желательно чтобы совпадало с настройкой lll.tab-width
      tab-len: 4

      # Shorten single-line comments.
      # Default: false
      #
      # Данная опция позволяет разбивать длинные комментарии
      #
      # До
      # // Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin id odio non neque tempus elementum eget vel ipsum. Duis imperdiet id enim at eleifend. Pellentesque vitae lacinia nulla, ac pretium eros.
      #
      # После
      # // Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin id odio non neque tempus
      # // elementum eget vel ipsum. Duis imperdiet id enim at eleifend. Pellentesque vitae lacinia
      # // nulla, ac pretium eros.
      #
      shorten-comments: true

      # Default: true
      #
      # Форматирует теги полей структуры
      #
      # До
      # type Tagged struct {
      # 	Name    string `json:"name" yaml:"name"`
      # 	Surname string `yaml:"surname" json:"surname"`
      # }
      #
      # После
      # type Tagged struct {
      # 	Name    string `json:"name"    yaml:"name"`
      # 	Surname string `json:"surname" yaml:"surname"`
      # }
      #
      reformat-tags: true

      # Split chained methods on the dots as opposed to the arguments.
      # Default: true
      #
      # В случае если длина линии превышает максимально допустимое число символов
      # и состоит из .Chain().Chain
      # golines разобьёт строку на несколько
      #
      # До
      # srv.EXPECT().SayHello("Dima").Return("Hello Dima!").Times(1).Return("Hello Dima!").Times(1).Return("Hello Dima!").Times(1).Return("Hello Dima!").Times(1).Return("Hello Dima!").Times(1).Return("Hello Dima!").Times(1).Return("Hello Dima!").Times(1).Return("Hello Dima!").Times(1)
      #
      # После
      # srv.EXPECT().
      # 	SayHello("Dima").
      # 	Return("Hello Dima!").
      # 	Times(1).
      # 	Return("Hello Dima!").
      # 	Times(1).
      # 	Return("Hello Dima!").
      # 	Times(1).
      # 	Return("Hello Dima!").
      # 	Times(1).
      # 	Return("Hello Dima!").
      # 	Times(1).
      # 	Return("Hello Dima!").
      # 	Times(1).
      # 	Return("Hello Dima!").
      # 	Times(1).
      # 	Return("Hello Dima!").
      # 	Times(1) // Каждый .Method() начинается с новой строки
      chain-split-dots: true

run:
  timeout: "1m"
  issues-exit-code: 1
  tests: true

issues:
  # Не ограничивает линтеры в количестве сообщений
  # Позволяет видеть все возможные issue сразу а не постепенно
  max-issues-per-linter: 0

  # Максимальное количество сообщений с одинаковым текстом
  # Позволяет видеть все возможные issue сразу а не постепенно
  max-same-issues: 0

  # Равнозначно --fix флагу
  # НИКОГДА НЕ ВКЛЮЧАЕМ, если нам надо поправить форматирование вызываем golangci-lint fmt
  # ЗНАЧЕНИЕ true ПРИЗНАНО АНТИПАТТЕРНОМ
  fix: false

  # Позволяет нескольким линтерам жаловаться на одну и ту же строчку
  # Позволяет видеть все возможные issue сразу а не постепенно
  uniq-by-line: false
#
#
#
# Аудит линтеров измеряющих сложность и вложенность функций
# Рассматриваются
# cyclop
# gocognit
# revive.cyclomatic
# revive.cognitive-complexity
#
# cyclop и cyclomatic считают вложенность функций
# gocognit так же уделяет особое внимание вложенности функции, начисляя штрафные баллы за глубокую вложенность
# revive.cognitive-complexity тоже считает вложенность и добавляет штрафные баллы
#
# Считать вложенность функций отдельно будет не совсем объективно
# Учитывая что в gocognit и revive.cognitive-complexity дают комплексную оценку функций
#
# На этом этапе выпадают cyclop и gocognit
#
# Тест 1 Сложные логические выражения
# func test1(a, b, c, d bool) {
# 	if a && b && (c || d) && (a || b) {
# 	}
# }
#
# gocognit: 4
# revive.cognitive-complexity: 4
#
#
# Тест 2 Вложенные if-else цепочки
# func test2(x int) {
# 	if x > 0 { // revive: +1, gocognit: +1
# 		if x > 10 { // revive: +1 + 1, gocognit: +1 + 1
# 		}
# 	} else if x < -5 { // revive: +1, gocognit: +1
# 		if x < -10 { // revive: +1 + 1, gocognit: +1 + 1
# 		}
# 	} else if x == 0 { // revive: +1, gocognit: +1
# 	}
# }
#
#
#
# gocognit: 7
# revive.cognitive-complexity: 7
#
#
# Тест 3 Рекурсия + сложные условия
#
# func factorial(n int) int {
# 	if n <= 1 {
# 		return 1
# 	}
#
# 	if n > 10 && n < 100 {
# 		return n * factorial(n-1)
# 	}
#
# 	return n * factorial(n-1)
# }
#
# gocognit: 5
# revive.cognitive-complexity: 3
#
# gocognit здесь добавил по одному баллу за вызов рекурсивной функции
# gocognit добавляет балл за КАЖДЫЙ вызов рекрсии так как revive добавляет лишь один балл за использование рекурсии
#
# Данное предположение основано на следующем примере
#
# func recursion1(x int) int {
# 	if 100 > 0 {
# 		return x * nonRecursion(1-100)
# 	}
#
# 	if 14 > 75 {
# 		return x * nonRecursion(1-1000)
# 	}
#
# 	return nonRecursion(x - 1)
# }
#
# func recursion2(x int) int {
# 	if 100 > 0 {
# 		return x * recursion2(1-100)
# 	}
#
# 	if 14 > 75 {
# 		return x * recursion2(1-1000)
# 	}
#
# 	return recursion2(x - 1)
# }
#
# func nonRecursion(int) int {
# 	return 0
# }
#
# recursion1:
#   gocognit: 2
#   revive.cognitive-complexity: 2
#
# recursion2:
#   gocognit: 5
#   revive.cognitive-complexity: 3
#
#   Здесь мы заменили вызов каждой функции на рекурсию
#   gocognit увеличил оценку на 3 балла за каждый рекурсионных вызов
#   revive.cognitive-complexity увеличил всег она 1 балл, просто за наличие рекурсии
#
#
# С небольшим перевесом здесь побеждает gocognit за дополнительные баллы за рекурсивные вызовы
